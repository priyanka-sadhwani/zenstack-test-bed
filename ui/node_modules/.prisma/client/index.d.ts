
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Lab
 * 
 */
export type Lab = $Result.DefaultSelection<Prisma.$LabPayload>
/**
 * Model LabProfile
 * 
 */
export type LabProfile = $Result.DefaultSelection<Prisma.$LabProfilePayload>
/**
 * Model UserLabJoin
 * 
 */
export type UserLabJoin = $Result.DefaultSelection<Prisma.$UserLabJoinPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserLabRole
 * 
 */
export type UserLabRole = $Result.DefaultSelection<Prisma.$UserLabRolePayload>
/**
 * Model Privilege
 * 
 */
export type Privilege = $Result.DefaultSelection<Prisma.$PrivilegePayload>
/**
 * Model LabPermission
 * 
 */
export type LabPermission = $Result.DefaultSelection<Prisma.$LabPermissionPayload>
/**
 * Model RolePrivilegeJoin
 * 
 */
export type RolePrivilegeJoin = $Result.DefaultSelection<Prisma.$RolePrivilegeJoinPayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Images
 * const images = await prisma.image.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Images
   * const images = await prisma.image.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab`: Exposes CRUD operations for the **Lab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labs
    * const labs = await prisma.lab.findMany()
    * ```
    */
  get lab(): Prisma.LabDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labProfile`: Exposes CRUD operations for the **LabProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabProfiles
    * const labProfiles = await prisma.labProfile.findMany()
    * ```
    */
  get labProfile(): Prisma.LabProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLabJoin`: Exposes CRUD operations for the **UserLabJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLabJoins
    * const userLabJoins = await prisma.userLabJoin.findMany()
    * ```
    */
  get userLabJoin(): Prisma.UserLabJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLabRole`: Exposes CRUD operations for the **UserLabRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLabRoles
    * const userLabRoles = await prisma.userLabRole.findMany()
    * ```
    */
  get userLabRole(): Prisma.UserLabRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privilege`: Exposes CRUD operations for the **Privilege** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privileges
    * const privileges = await prisma.privilege.findMany()
    * ```
    */
  get privilege(): Prisma.PrivilegeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labPermission`: Exposes CRUD operations for the **LabPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabPermissions
    * const labPermissions = await prisma.labPermission.findMany()
    * ```
    */
  get labPermission(): Prisma.LabPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePrivilegeJoin`: Exposes CRUD operations for the **RolePrivilegeJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePrivilegeJoins
    * const rolePrivilegeJoins = await prisma.rolePrivilegeJoin.findMany()
    * ```
    */
  get rolePrivilegeJoin(): Prisma.RolePrivilegeJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Image: 'Image',
    Video: 'Video',
    User: 'User',
    UserProfile: 'UserProfile',
    Lab: 'Lab',
    LabProfile: 'LabProfile',
    UserLabJoin: 'UserLabJoin',
    Role: 'Role',
    UserLabRole: 'UserLabRole',
    Privilege: 'Privilege',
    LabPermission: 'LabPermission',
    RolePrivilegeJoin: 'RolePrivilegeJoin',
    Content: 'Content',
    Module: 'Module',
    Class: 'Class'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "image" | "video" | "user" | "userProfile" | "lab" | "labProfile" | "userLabJoin" | "role" | "userLabRole" | "privilege" | "labPermission" | "rolePrivilegeJoin" | "content" | "module" | "class"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Lab: {
        payload: Prisma.$LabPayload<ExtArgs>
        fields: Prisma.LabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findFirst: {
            args: Prisma.LabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findMany: {
            args: Prisma.LabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          create: {
            args: Prisma.LabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          createMany: {
            args: Prisma.LabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          delete: {
            args: Prisma.LabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          update: {
            args: Prisma.LabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          deleteMany: {
            args: Prisma.LabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          upsert: {
            args: Prisma.LabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          aggregate: {
            args: Prisma.LabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab>
          }
          groupBy: {
            args: Prisma.LabGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabCountArgs<ExtArgs>
            result: $Utils.Optional<LabCountAggregateOutputType> | number
          }
        }
      }
      LabProfile: {
        payload: Prisma.$LabProfilePayload<ExtArgs>
        fields: Prisma.LabProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          findFirst: {
            args: Prisma.LabProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          findMany: {
            args: Prisma.LabProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>[]
          }
          create: {
            args: Prisma.LabProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          createMany: {
            args: Prisma.LabProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>[]
          }
          delete: {
            args: Prisma.LabProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          update: {
            args: Prisma.LabProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          deleteMany: {
            args: Prisma.LabProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>[]
          }
          upsert: {
            args: Prisma.LabProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabProfilePayload>
          }
          aggregate: {
            args: Prisma.LabProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabProfile>
          }
          groupBy: {
            args: Prisma.LabProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LabProfileCountAggregateOutputType> | number
          }
        }
      }
      UserLabJoin: {
        payload: Prisma.$UserLabJoinPayload<ExtArgs>
        fields: Prisma.UserLabJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLabJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLabJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          findFirst: {
            args: Prisma.UserLabJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLabJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          findMany: {
            args: Prisma.UserLabJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>[]
          }
          create: {
            args: Prisma.UserLabJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          createMany: {
            args: Prisma.UserLabJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLabJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>[]
          }
          delete: {
            args: Prisma.UserLabJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          update: {
            args: Prisma.UserLabJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          deleteMany: {
            args: Prisma.UserLabJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLabJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLabJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>[]
          }
          upsert: {
            args: Prisma.UserLabJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabJoinPayload>
          }
          aggregate: {
            args: Prisma.UserLabJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLabJoin>
          }
          groupBy: {
            args: Prisma.UserLabJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLabJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLabJoinCountArgs<ExtArgs>
            result: $Utils.Optional<UserLabJoinCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserLabRole: {
        payload: Prisma.$UserLabRolePayload<ExtArgs>
        fields: Prisma.UserLabRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLabRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLabRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          findFirst: {
            args: Prisma.UserLabRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLabRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          findMany: {
            args: Prisma.UserLabRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>[]
          }
          create: {
            args: Prisma.UserLabRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          createMany: {
            args: Prisma.UserLabRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLabRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>[]
          }
          delete: {
            args: Prisma.UserLabRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          update: {
            args: Prisma.UserLabRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          deleteMany: {
            args: Prisma.UserLabRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLabRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLabRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>[]
          }
          upsert: {
            args: Prisma.UserLabRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLabRolePayload>
          }
          aggregate: {
            args: Prisma.UserLabRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLabRole>
          }
          groupBy: {
            args: Prisma.UserLabRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLabRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLabRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserLabRoleCountAggregateOutputType> | number
          }
        }
      }
      Privilege: {
        payload: Prisma.$PrivilegePayload<ExtArgs>
        fields: Prisma.PrivilegeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivilegeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivilegeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          findFirst: {
            args: Prisma.PrivilegeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivilegeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          findMany: {
            args: Prisma.PrivilegeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>[]
          }
          create: {
            args: Prisma.PrivilegeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          createMany: {
            args: Prisma.PrivilegeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivilegeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>[]
          }
          delete: {
            args: Prisma.PrivilegeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          update: {
            args: Prisma.PrivilegeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          deleteMany: {
            args: Prisma.PrivilegeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivilegeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivilegeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>[]
          }
          upsert: {
            args: Prisma.PrivilegeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          aggregate: {
            args: Prisma.PrivilegeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivilege>
          }
          groupBy: {
            args: Prisma.PrivilegeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivilegeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivilegeCountArgs<ExtArgs>
            result: $Utils.Optional<PrivilegeCountAggregateOutputType> | number
          }
        }
      }
      LabPermission: {
        payload: Prisma.$LabPermissionPayload<ExtArgs>
        fields: Prisma.LabPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          findFirst: {
            args: Prisma.LabPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          findMany: {
            args: Prisma.LabPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>[]
          }
          create: {
            args: Prisma.LabPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          createMany: {
            args: Prisma.LabPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>[]
          }
          delete: {
            args: Prisma.LabPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          update: {
            args: Prisma.LabPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          deleteMany: {
            args: Prisma.LabPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>[]
          }
          upsert: {
            args: Prisma.LabPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPermissionPayload>
          }
          aggregate: {
            args: Prisma.LabPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabPermission>
          }
          groupBy: {
            args: Prisma.LabPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<LabPermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePrivilegeJoin: {
        payload: Prisma.$RolePrivilegeJoinPayload<ExtArgs>
        fields: Prisma.RolePrivilegeJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePrivilegeJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePrivilegeJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          findFirst: {
            args: Prisma.RolePrivilegeJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePrivilegeJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          findMany: {
            args: Prisma.RolePrivilegeJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>[]
          }
          create: {
            args: Prisma.RolePrivilegeJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          createMany: {
            args: Prisma.RolePrivilegeJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePrivilegeJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>[]
          }
          delete: {
            args: Prisma.RolePrivilegeJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          update: {
            args: Prisma.RolePrivilegeJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          deleteMany: {
            args: Prisma.RolePrivilegeJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePrivilegeJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePrivilegeJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>[]
          }
          upsert: {
            args: Prisma.RolePrivilegeJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePrivilegeJoinPayload>
          }
          aggregate: {
            args: Prisma.RolePrivilegeJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePrivilegeJoin>
          }
          groupBy: {
            args: Prisma.RolePrivilegeJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePrivilegeJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePrivilegeJoinCountArgs<ExtArgs>
            result: $Utils.Optional<RolePrivilegeJoinCountAggregateOutputType> | number
          }
        }
      }
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    image?: ImageOmit
    video?: VideoOmit
    user?: UserOmit
    userProfile?: UserProfileOmit
    lab?: LabOmit
    labProfile?: LabProfileOmit
    userLabJoin?: UserLabJoinOmit
    role?: RoleOmit
    userLabRole?: UserLabRoleOmit
    privilege?: PrivilegeOmit
    labPermission?: LabPermissionOmit
    rolePrivilegeJoin?: RolePrivilegeJoinOmit
    content?: ContentOmit
    module?: ModuleOmit
    class?: ClassOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ImageCountOutputType
   */

  export type ImageCountOutputType = {
    userProfiles: number
    labProfiles: number
    contents: number
    modules: number
    classes: number
  }

  export type ImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfiles?: boolean | ImageCountOutputTypeCountUserProfilesArgs
    labProfiles?: boolean | ImageCountOutputTypeCountLabProfilesArgs
    contents?: boolean | ImageCountOutputTypeCountContentsArgs
    modules?: boolean | ImageCountOutputTypeCountModulesArgs
    classes?: boolean | ImageCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountUserProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountLabProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabProfileWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type VideoCountOutputType
   */

  export type VideoCountOutputType = {
    previewForContent: number
    previewForModule: number
    classes: number
  }

  export type VideoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    previewForContent?: boolean | VideoCountOutputTypeCountPreviewForContentArgs
    previewForModule?: boolean | VideoCountOutputTypeCountPreviewForModuleArgs
    classes?: boolean | VideoCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountPreviewForContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountPreviewForModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    labs: number
    ownedLabs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labs?: boolean | UserCountOutputTypeCountLabsArgs
    ownedLabs?: boolean | UserCountOutputTypeCountOwnedLabsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabJoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
  }


  /**
   * Count Type LabCountOutputType
   */

  export type LabCountOutputType = {
    owners: number
    community: number
    roles: number
    privileges: number
    content: number
    permissions: number
  }

  export type LabCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners?: boolean | LabCountOutputTypeCountOwnersArgs
    community?: boolean | LabCountOutputTypeCountCommunityArgs
    roles?: boolean | LabCountOutputTypeCountRolesArgs
    privileges?: boolean | LabCountOutputTypeCountPrivilegesArgs
    content?: boolean | LabCountOutputTypeCountContentArgs
    permissions?: boolean | LabCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabCountOutputType
     */
    select?: LabCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountCommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabJoinWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountPrivilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivilegeWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabPermissionWhereInput
  }


  /**
   * Count Type UserLabJoinCountOutputType
   */

  export type UserLabJoinCountOutputType = {
    userLabRoles: number
  }

  export type UserLabJoinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLabRoles?: boolean | UserLabJoinCountOutputTypeCountUserLabRolesArgs
  }

  // Custom InputTypes
  /**
   * UserLabJoinCountOutputType without action
   */
  export type UserLabJoinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoinCountOutputType
     */
    select?: UserLabJoinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserLabJoinCountOutputType without action
   */
  export type UserLabJoinCountOutputTypeCountUserLabRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabRoleWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userLabRoles: number
    privileges: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLabRoles?: boolean | RoleCountOutputTypeCountUserLabRolesArgs
    privileges?: boolean | RoleCountOutputTypeCountPrivilegesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserLabRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPrivilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePrivilegeJoinWhereInput
  }


  /**
   * Count Type PrivilegeCountOutputType
   */

  export type PrivilegeCountOutputType = {
    roles: number
    labPermissions: number
  }

  export type PrivilegeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PrivilegeCountOutputTypeCountRolesArgs
    labPermissions?: boolean | PrivilegeCountOutputTypeCountLabPermissionsArgs
  }

  // Custom InputTypes
  /**
   * PrivilegeCountOutputType without action
   */
  export type PrivilegeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivilegeCountOutputType
     */
    select?: PrivilegeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrivilegeCountOutputType without action
   */
  export type PrivilegeCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePrivilegeJoinWhereInput
  }

  /**
   * PrivilegeCountOutputType without action
   */
  export type PrivilegeCountOutputTypeCountLabPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabPermissionWhereInput
  }


  /**
   * Count Type LabPermissionCountOutputType
   */

  export type LabPermissionCountOutputType = {
    privileges: number
  }

  export type LabPermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    privileges?: boolean | LabPermissionCountOutputTypeCountPrivilegesArgs
  }

  // Custom InputTypes
  /**
   * LabPermissionCountOutputType without action
   */
  export type LabPermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermissionCountOutputType
     */
    select?: LabPermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabPermissionCountOutputType without action
   */
  export type LabPermissionCountOutputTypeCountPrivilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivilegeWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    modules: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | ContentCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    classes: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | ModuleCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    width: number | null
    height: number | null
    size: number | null
  }

  export type ImageSumAggregateOutputType = {
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type ImageMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    storageRef: string | null
    displayName: string | null
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type ImageMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    storageRef: string | null
    displayName: string | null
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type ImageCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    storageRef: number
    displayName: number
    width: number
    height: number
    size: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    width?: true
    height?: true
    size?: true
  }

  export type ImageSumAggregateInputType = {
    width?: true
    height?: true
    size?: true
  }

  export type ImageMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    width?: true
    height?: true
    size?: true
  }

  export type ImageMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    width?: true
    height?: true
    size?: true
  }

  export type ImageCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    width?: true
    height?: true
    size?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    storageRef: string
    displayName: string | null
    width: number
    height: number
    size: bigint
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    userProfiles?: boolean | Image$userProfilesArgs<ExtArgs>
    labProfiles?: boolean | Image$labProfilesArgs<ExtArgs>
    contents?: boolean | Image$contentsArgs<ExtArgs>
    modules?: boolean | Image$modulesArgs<ExtArgs>
    classes?: boolean | Image$classesArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "storageRef" | "displayName" | "width" | "height" | "size", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfiles?: boolean | Image$userProfilesArgs<ExtArgs>
    labProfiles?: boolean | Image$labProfilesArgs<ExtArgs>
    contents?: boolean | Image$contentsArgs<ExtArgs>
    modules?: boolean | Image$modulesArgs<ExtArgs>
    classes?: boolean | Image$classesArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      userProfiles: Prisma.$UserProfilePayload<ExtArgs>[]
      labProfiles: Prisma.$LabProfilePayload<ExtArgs>[]
      contents: Prisma.$ContentPayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      storageRef: string
      displayName: string | null
      width: number
      height: number
      size: bigint
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const imageWithCreatedAtOnly = await prisma.image.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `createdAt`
     * const imageWithCreatedAtOnly = await prisma.image.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `createdAt`
     * const imageWithCreatedAtOnly = await prisma.image.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfiles<T extends Image$userProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Image$userProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labProfiles<T extends Image$labProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Image$labProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contents<T extends Image$contentsArgs<ExtArgs> = {}>(args?: Subset<T, Image$contentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Image$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Image$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Image$classesArgs<ExtArgs> = {}>(args?: Subset<T, Image$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
    readonly id: FieldRef<"Image", 'String'>
    readonly storageRef: FieldRef<"Image", 'String'>
    readonly displayName: FieldRef<"Image", 'String'>
    readonly width: FieldRef<"Image", 'Int'>
    readonly height: FieldRef<"Image", 'Int'>
    readonly size: FieldRef<"Image", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image.userProfiles
   */
  export type Image$userProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * Image.labProfiles
   */
  export type Image$labProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    where?: LabProfileWhereInput
    orderBy?: LabProfileOrderByWithRelationInput | LabProfileOrderByWithRelationInput[]
    cursor?: LabProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabProfileScalarFieldEnum | LabProfileScalarFieldEnum[]
  }

  /**
   * Image.contents
   */
  export type Image$contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Image.modules
   */
  export type Image$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Image.classes
   */
  export type Image$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    durationMillis: number | null
    width: number | null
    height: number | null
    size: number | null
  }

  export type VideoSumAggregateOutputType = {
    durationMillis: number | null
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type VideoMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    storageRef: string | null
    displayName: string | null
    durationMillis: number | null
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type VideoMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    storageRef: string | null
    displayName: string | null
    durationMillis: number | null
    width: number | null
    height: number | null
    size: bigint | null
  }

  export type VideoCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    storageRef: number
    displayName: number
    durationMillis: number
    width: number
    height: number
    size: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    durationMillis?: true
    width?: true
    height?: true
    size?: true
  }

  export type VideoSumAggregateInputType = {
    durationMillis?: true
    width?: true
    height?: true
    size?: true
  }

  export type VideoMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    durationMillis?: true
    width?: true
    height?: true
    size?: true
  }

  export type VideoMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    durationMillis?: true
    width?: true
    height?: true
    size?: true
  }

  export type VideoCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    storageRef?: true
    displayName?: true
    durationMillis?: true
    width?: true
    height?: true
    size?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    storageRef: string
    displayName: string | null
    durationMillis: number
    width: number | null
    height: number | null
    size: bigint
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    durationMillis?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    previewForContent?: boolean | Video$previewForContentArgs<ExtArgs>
    previewForModule?: boolean | Video$previewForModuleArgs<ExtArgs>
    classes?: boolean | Video$classesArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    durationMillis?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    durationMillis?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    storageRef?: boolean
    displayName?: boolean
    durationMillis?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "storageRef" | "displayName" | "durationMillis" | "width" | "height" | "size", ExtArgs["result"]["video"]>
  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    previewForContent?: boolean | Video$previewForContentArgs<ExtArgs>
    previewForModule?: boolean | Video$previewForModuleArgs<ExtArgs>
    classes?: boolean | Video$classesArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      previewForContent: Prisma.$ContentPayload<ExtArgs>[]
      previewForModule: Prisma.$ModulePayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      storageRef: string
      displayName: string | null
      durationMillis: number
      width: number | null
      height: number | null
      size: bigint
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const videoWithCreatedAtOnly = await prisma.video.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `createdAt`
     * const videoWithCreatedAtOnly = await prisma.video.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideoUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `createdAt`
     * const videoWithCreatedAtOnly = await prisma.video.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    previewForContent<T extends Video$previewForContentArgs<ExtArgs> = {}>(args?: Subset<T, Video$previewForContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previewForModule<T extends Video$previewForModuleArgs<ExtArgs> = {}>(args?: Subset<T, Video$previewForModuleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Video$classesArgs<ExtArgs> = {}>(args?: Subset<T, Video$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly createdAt: FieldRef<"Video", 'DateTime'>
    readonly updatedAt: FieldRef<"Video", 'DateTime'>
    readonly id: FieldRef<"Video", 'String'>
    readonly storageRef: FieldRef<"Video", 'String'>
    readonly displayName: FieldRef<"Video", 'String'>
    readonly durationMillis: FieldRef<"Video", 'Int'>
    readonly width: FieldRef<"Video", 'Int'>
    readonly height: FieldRef<"Video", 'Int'>
    readonly size: FieldRef<"Video", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video updateManyAndReturn
   */
  export type VideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video.previewForContent
   */
  export type Video$previewForContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Video.previewForModule
   */
  export type Video$previewForModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Video.classes
   */
  export type Video$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    email: string | null
    displayName: string | null
  }

  export type UserMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    email: string | null
    displayName: string | null
  }

  export type UserCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    email: number
    displayName: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    email?: true
    displayName?: true
  }

  export type UserMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    email?: true
    displayName?: true
  }

  export type UserCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    email?: true
    displayName?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    email: string
    displayName: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    email?: boolean
    displayName?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    labs?: boolean | User$labsArgs<ExtArgs>
    ownedLabs?: boolean | User$ownedLabsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    email?: boolean
    displayName?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    email?: boolean
    displayName?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    email?: boolean
    displayName?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "email" | "displayName", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    labs?: boolean | User$labsArgs<ExtArgs>
    ownedLabs?: boolean | User$ownedLabsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      labs: Prisma.$UserLabJoinPayload<ExtArgs>[]
      ownedLabs: Prisma.$LabPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      email: string
      displayName: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const userWithCreatedAtOnly = await prisma.user.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `createdAt`
     * const userWithCreatedAtOnly = await prisma.user.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `createdAt`
     * const userWithCreatedAtOnly = await prisma.user.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labs<T extends User$labsArgs<ExtArgs> = {}>(args?: Subset<T, User$labsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedLabs<T extends User$ownedLabsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedLabsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.labs
   */
  export type User$labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    where?: UserLabJoinWhereInput
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    cursor?: UserLabJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLabJoinScalarFieldEnum | UserLabJoinScalarFieldEnum[]
  }

  /**
   * User.ownedLabs
   */
  export type User$ownedLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    cursor?: LabWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    userId: string | null
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    userId: string | null
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    userId: number
    bio: number
    instagram: number
    profilePhotoId: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    userId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
  }

  export type UserProfileMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    userId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
  }

  export type UserProfileCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    userId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    userId: string
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    userId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    userId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    userId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    userId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "userId" | "bio" | "instagram" | "profilePhotoId", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profilePhoto?: boolean | UserProfile$profilePhotoArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profilePhoto: Prisma.$ImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      userId: string
      bio: string | null
      instagram: string | null
      profilePhotoId: string | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const userProfileWithCreatedAtOnly = await prisma.userProfile.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `createdAt`
     * const userProfileWithCreatedAtOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `createdAt`
     * const userProfileWithCreatedAtOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profilePhoto<T extends UserProfile$profilePhotoArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$profilePhotoArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly instagram: FieldRef<"UserProfile", 'String'>
    readonly profilePhotoId: FieldRef<"UserProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile.profilePhoto
   */
  export type UserProfile$profilePhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Lab
   */

  export type AggregateLab = {
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  export type LabMinAggregateOutputType = {
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
  }

  export type LabMaxAggregateOutputType = {
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
  }

  export type LabCountAggregateOutputType = {
    published: number
    createdAt: number
    updatedAt: number
    id: number
    name: number
    _all: number
  }


  export type LabMinAggregateInputType = {
    published?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
  }

  export type LabMaxAggregateInputType = {
    published?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
  }

  export type LabCountAggregateInputType = {
    published?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    _all?: true
  }

  export type LabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lab to aggregate.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labs
    **/
    _count?: true | LabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaxAggregateInputType
  }

  export type GetLabAggregateType<T extends LabAggregateArgs> = {
        [P in keyof T & keyof AggregateLab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab[P]>
      : GetScalarType<T[P], AggregateLab[P]>
  }




  export type LabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
    orderBy?: LabOrderByWithAggregationInput | LabOrderByWithAggregationInput[]
    by: LabScalarFieldEnum[] | LabScalarFieldEnum
    having?: LabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabCountAggregateInputType | true
    _min?: LabMinAggregateInputType
    _max?: LabMaxAggregateInputType
  }

  export type LabGroupByOutputType = {
    published: boolean
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    _count: LabCountAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  type GetLabGroupByPayload<T extends LabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabGroupByOutputType[P]>
            : GetScalarType<T[P], LabGroupByOutputType[P]>
        }
      >
    >


  export type LabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    profile?: boolean | Lab$profileArgs<ExtArgs>
    owners?: boolean | Lab$ownersArgs<ExtArgs>
    community?: boolean | Lab$communityArgs<ExtArgs>
    roles?: boolean | Lab$rolesArgs<ExtArgs>
    privileges?: boolean | Lab$privilegesArgs<ExtArgs>
    content?: boolean | Lab$contentArgs<ExtArgs>
    permissions?: boolean | Lab$permissionsArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["lab"]>

  export type LabSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["lab"]>

  export type LabSelectScalar = {
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
  }

  export type LabOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"published" | "createdAt" | "updatedAt" | "id" | "name", ExtArgs["result"]["lab"]>
  export type LabInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | Lab$profileArgs<ExtArgs>
    owners?: boolean | Lab$ownersArgs<ExtArgs>
    community?: boolean | Lab$communityArgs<ExtArgs>
    roles?: boolean | Lab$rolesArgs<ExtArgs>
    privileges?: boolean | Lab$privilegesArgs<ExtArgs>
    content?: boolean | Lab$contentArgs<ExtArgs>
    permissions?: boolean | Lab$permissionsArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LabIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lab"
    objects: {
      profile: Prisma.$LabProfilePayload<ExtArgs> | null
      owners: Prisma.$UserPayload<ExtArgs>[]
      community: Prisma.$UserLabJoinPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      privileges: Prisma.$PrivilegePayload<ExtArgs>[]
      content: Prisma.$ContentPayload<ExtArgs>[]
      permissions: Prisma.$LabPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      published: boolean
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
    }, ExtArgs["result"]["lab"]>
    composites: {}
  }

  type LabGetPayload<S extends boolean | null | undefined | LabDefaultArgs> = $Result.GetResult<Prisma.$LabPayload, S>

  type LabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabCountAggregateInputType | true
    }

  export interface LabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lab'], meta: { name: 'Lab' } }
    /**
     * Find zero or one Lab that matches the filter.
     * @param {LabFindUniqueArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabFindUniqueArgs>(args: SelectSubset<T, LabFindUniqueArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabFindUniqueOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabFindUniqueOrThrowArgs>(args: SelectSubset<T, LabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabFindFirstArgs>(args?: SelectSubset<T, LabFindFirstArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabFindFirstOrThrowArgs>(args?: SelectSubset<T, LabFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labs
     * const labs = await prisma.lab.findMany()
     * 
     * // Get first 10 Labs
     * const labs = await prisma.lab.findMany({ take: 10 })
     * 
     * // Only select the `published`
     * const labWithPublishedOnly = await prisma.lab.findMany({ select: { published: true } })
     * 
     */
    findMany<T extends LabFindManyArgs>(args?: SelectSubset<T, LabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab.
     * @param {LabCreateArgs} args - Arguments to create a Lab.
     * @example
     * // Create one Lab
     * const Lab = await prisma.lab.create({
     *   data: {
     *     // ... data to create a Lab
     *   }
     * })
     * 
     */
    create<T extends LabCreateArgs>(args: SelectSubset<T, LabCreateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labs.
     * @param {LabCreateManyArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabCreateManyArgs>(args?: SelectSubset<T, LabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labs and returns the data saved in the database.
     * @param {LabCreateManyAndReturnArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labs and only return the `published`
     * const labWithPublishedOnly = await prisma.lab.createManyAndReturn({
     *   select: { published: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabCreateManyAndReturnArgs>(args?: SelectSubset<T, LabCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab.
     * @param {LabDeleteArgs} args - Arguments to delete one Lab.
     * @example
     * // Delete one Lab
     * const Lab = await prisma.lab.delete({
     *   where: {
     *     // ... filter to delete one Lab
     *   }
     * })
     * 
     */
    delete<T extends LabDeleteArgs>(args: SelectSubset<T, LabDeleteArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab.
     * @param {LabUpdateArgs} args - Arguments to update one Lab.
     * @example
     * // Update one Lab
     * const lab = await prisma.lab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabUpdateArgs>(args: SelectSubset<T, LabUpdateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labs.
     * @param {LabDeleteManyArgs} args - Arguments to filter Labs to delete.
     * @example
     * // Delete a few Labs
     * const { count } = await prisma.lab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabDeleteManyArgs>(args?: SelectSubset<T, LabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabUpdateManyArgs>(args: SelectSubset<T, LabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs and returns the data updated in the database.
     * @param {LabUpdateManyAndReturnArgs} args - Arguments to update many Labs.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labs and only return the `published`
     * const labWithPublishedOnly = await prisma.lab.updateManyAndReturn({
     *   select: { published: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabUpdateManyAndReturnArgs>(args: SelectSubset<T, LabUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab.
     * @param {LabUpsertArgs} args - Arguments to update or create a Lab.
     * @example
     * // Update or create a Lab
     * const lab = await prisma.lab.upsert({
     *   create: {
     *     // ... data to create a Lab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab we want to update
     *   }
     * })
     */
    upsert<T extends LabUpsertArgs>(args: SelectSubset<T, LabUpsertArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabCountArgs} args - Arguments to filter Labs to count.
     * @example
     * // Count the number of Labs
     * const count = await prisma.lab.count({
     *   where: {
     *     // ... the filter for the Labs we want to count
     *   }
     * })
    **/
    count<T extends LabCountArgs>(
      args?: Subset<T, LabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAggregateArgs>(args: Subset<T, LabAggregateArgs>): Prisma.PrismaPromise<GetLabAggregateType<T>>

    /**
     * Group by Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabGroupByArgs['orderBy'] }
        : { orderBy?: LabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lab model
   */
  readonly fields: LabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends Lab$profileArgs<ExtArgs> = {}>(args?: Subset<T, Lab$profileArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owners<T extends Lab$ownersArgs<ExtArgs> = {}>(args?: Subset<T, Lab$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    community<T extends Lab$communityArgs<ExtArgs> = {}>(args?: Subset<T, Lab$communityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Lab$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Lab$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privileges<T extends Lab$privilegesArgs<ExtArgs> = {}>(args?: Subset<T, Lab$privilegesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    content<T extends Lab$contentArgs<ExtArgs> = {}>(args?: Subset<T, Lab$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Lab$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Lab$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lab model
   */
  interface LabFieldRefs {
    readonly published: FieldRef<"Lab", 'Boolean'>
    readonly createdAt: FieldRef<"Lab", 'DateTime'>
    readonly updatedAt: FieldRef<"Lab", 'DateTime'>
    readonly id: FieldRef<"Lab", 'String'>
    readonly name: FieldRef<"Lab", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lab findUnique
   */
  export type LabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findUniqueOrThrow
   */
  export type LabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findFirst
   */
  export type LabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findFirstOrThrow
   */
  export type LabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findMany
   */
  export type LabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Labs to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab create
   */
  export type LabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to create a Lab.
     */
    data: XOR<LabCreateInput, LabUncheckedCreateInput>
  }

  /**
   * Lab createMany
   */
  export type LabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
  }

  /**
   * Lab createManyAndReturn
   */
  export type LabCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
  }

  /**
   * Lab update
   */
  export type LabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to update a Lab.
     */
    data: XOR<LabUpdateInput, LabUncheckedUpdateInput>
    /**
     * Choose, which Lab to update.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab updateMany
   */
  export type LabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
  }

  /**
   * Lab updateManyAndReturn
   */
  export type LabUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
  }

  /**
   * Lab upsert
   */
  export type LabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The filter to search for the Lab to update in case it exists.
     */
    where: LabWhereUniqueInput
    /**
     * In case the Lab found by the `where` argument doesn't exist, create a new Lab with this data.
     */
    create: XOR<LabCreateInput, LabUncheckedCreateInput>
    /**
     * In case the Lab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabUpdateInput, LabUncheckedUpdateInput>
  }

  /**
   * Lab delete
   */
  export type LabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter which Lab to delete.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab deleteMany
   */
  export type LabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labs to delete
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to delete.
     */
    limit?: number
  }

  /**
   * Lab.profile
   */
  export type Lab$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    where?: LabProfileWhereInput
  }

  /**
   * Lab.owners
   */
  export type Lab$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Lab.community
   */
  export type Lab$communityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    where?: UserLabJoinWhereInput
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    cursor?: UserLabJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLabJoinScalarFieldEnum | UserLabJoinScalarFieldEnum[]
  }

  /**
   * Lab.roles
   */
  export type Lab$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Lab.privileges
   */
  export type Lab$privilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    where?: PrivilegeWhereInput
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    cursor?: PrivilegeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Lab.content
   */
  export type Lab$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Lab.permissions
   */
  export type Lab$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    where?: LabPermissionWhereInput
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    cursor?: LabPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabPermissionScalarFieldEnum | LabPermissionScalarFieldEnum[]
  }

  /**
   * Lab without action
   */
  export type LabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
  }


  /**
   * Model LabProfile
   */

  export type AggregateLabProfile = {
    _count: LabProfileCountAggregateOutputType | null
    _min: LabProfileMinAggregateOutputType | null
    _max: LabProfileMaxAggregateOutputType | null
  }

  export type LabProfileMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    labId: string | null
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
    slug: string | null
  }

  export type LabProfileMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    labId: string | null
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
    slug: string | null
  }

  export type LabProfileCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    labId: number
    bio: number
    instagram: number
    profilePhotoId: number
    slug: number
    _all: number
  }


  export type LabProfileMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
    slug?: true
  }

  export type LabProfileMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
    slug?: true
  }

  export type LabProfileCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    bio?: true
    instagram?: true
    profilePhotoId?: true
    slug?: true
    _all?: true
  }

  export type LabProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabProfile to aggregate.
     */
    where?: LabProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabProfiles to fetch.
     */
    orderBy?: LabProfileOrderByWithRelationInput | LabProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabProfiles
    **/
    _count?: true | LabProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabProfileMaxAggregateInputType
  }

  export type GetLabProfileAggregateType<T extends LabProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLabProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabProfile[P]>
      : GetScalarType<T[P], AggregateLabProfile[P]>
  }




  export type LabProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabProfileWhereInput
    orderBy?: LabProfileOrderByWithAggregationInput | LabProfileOrderByWithAggregationInput[]
    by: LabProfileScalarFieldEnum[] | LabProfileScalarFieldEnum
    having?: LabProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabProfileCountAggregateInputType | true
    _min?: LabProfileMinAggregateInputType
    _max?: LabProfileMaxAggregateInputType
  }

  export type LabProfileGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    labId: string
    bio: string | null
    instagram: string | null
    profilePhotoId: string | null
    slug: string | null
    _count: LabProfileCountAggregateOutputType | null
    _min: LabProfileMinAggregateOutputType | null
    _max: LabProfileMaxAggregateOutputType | null
  }

  type GetLabProfileGroupByPayload<T extends LabProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LabProfileGroupByOutputType[P]>
        }
      >
    >


  export type LabProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    slug?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["labProfile"]>

  export type LabProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    slug?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["labProfile"]>

  export type LabProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    slug?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["labProfile"]>

  export type LabProfileSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    bio?: boolean
    instagram?: boolean
    profilePhotoId?: boolean
    slug?: boolean
  }

  export type LabProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "labId" | "bio" | "instagram" | "profilePhotoId" | "slug", ExtArgs["result"]["labProfile"]>
  export type LabProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }
  export type LabProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }
  export type LabProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    profilePhoto?: boolean | LabProfile$profilePhotoArgs<ExtArgs>
  }

  export type $LabProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabProfile"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      profilePhoto: Prisma.$ImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      labId: string
      bio: string | null
      instagram: string | null
      profilePhotoId: string | null
      slug: string | null
    }, ExtArgs["result"]["labProfile"]>
    composites: {}
  }

  type LabProfileGetPayload<S extends boolean | null | undefined | LabProfileDefaultArgs> = $Result.GetResult<Prisma.$LabProfilePayload, S>

  type LabProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabProfileCountAggregateInputType | true
    }

  export interface LabProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabProfile'], meta: { name: 'LabProfile' } }
    /**
     * Find zero or one LabProfile that matches the filter.
     * @param {LabProfileFindUniqueArgs} args - Arguments to find a LabProfile
     * @example
     * // Get one LabProfile
     * const labProfile = await prisma.labProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabProfileFindUniqueArgs>(args: SelectSubset<T, LabProfileFindUniqueArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabProfileFindUniqueOrThrowArgs} args - Arguments to find a LabProfile
     * @example
     * // Get one LabProfile
     * const labProfile = await prisma.labProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LabProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileFindFirstArgs} args - Arguments to find a LabProfile
     * @example
     * // Get one LabProfile
     * const labProfile = await prisma.labProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabProfileFindFirstArgs>(args?: SelectSubset<T, LabProfileFindFirstArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileFindFirstOrThrowArgs} args - Arguments to find a LabProfile
     * @example
     * // Get one LabProfile
     * const labProfile = await prisma.labProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LabProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabProfiles
     * const labProfiles = await prisma.labProfile.findMany()
     * 
     * // Get first 10 LabProfiles
     * const labProfiles = await prisma.labProfile.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const labProfileWithCreatedAtOnly = await prisma.labProfile.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends LabProfileFindManyArgs>(args?: SelectSubset<T, LabProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabProfile.
     * @param {LabProfileCreateArgs} args - Arguments to create a LabProfile.
     * @example
     * // Create one LabProfile
     * const LabProfile = await prisma.labProfile.create({
     *   data: {
     *     // ... data to create a LabProfile
     *   }
     * })
     * 
     */
    create<T extends LabProfileCreateArgs>(args: SelectSubset<T, LabProfileCreateArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabProfiles.
     * @param {LabProfileCreateManyArgs} args - Arguments to create many LabProfiles.
     * @example
     * // Create many LabProfiles
     * const labProfile = await prisma.labProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabProfileCreateManyArgs>(args?: SelectSubset<T, LabProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabProfiles and returns the data saved in the database.
     * @param {LabProfileCreateManyAndReturnArgs} args - Arguments to create many LabProfiles.
     * @example
     * // Create many LabProfiles
     * const labProfile = await prisma.labProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabProfiles and only return the `createdAt`
     * const labProfileWithCreatedAtOnly = await prisma.labProfile.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LabProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabProfile.
     * @param {LabProfileDeleteArgs} args - Arguments to delete one LabProfile.
     * @example
     * // Delete one LabProfile
     * const LabProfile = await prisma.labProfile.delete({
     *   where: {
     *     // ... filter to delete one LabProfile
     *   }
     * })
     * 
     */
    delete<T extends LabProfileDeleteArgs>(args: SelectSubset<T, LabProfileDeleteArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabProfile.
     * @param {LabProfileUpdateArgs} args - Arguments to update one LabProfile.
     * @example
     * // Update one LabProfile
     * const labProfile = await prisma.labProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabProfileUpdateArgs>(args: SelectSubset<T, LabProfileUpdateArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabProfiles.
     * @param {LabProfileDeleteManyArgs} args - Arguments to filter LabProfiles to delete.
     * @example
     * // Delete a few LabProfiles
     * const { count } = await prisma.labProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabProfileDeleteManyArgs>(args?: SelectSubset<T, LabProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabProfiles
     * const labProfile = await prisma.labProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabProfileUpdateManyArgs>(args: SelectSubset<T, LabProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabProfiles and returns the data updated in the database.
     * @param {LabProfileUpdateManyAndReturnArgs} args - Arguments to update many LabProfiles.
     * @example
     * // Update many LabProfiles
     * const labProfile = await prisma.labProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabProfiles and only return the `createdAt`
     * const labProfileWithCreatedAtOnly = await prisma.labProfile.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LabProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabProfile.
     * @param {LabProfileUpsertArgs} args - Arguments to update or create a LabProfile.
     * @example
     * // Update or create a LabProfile
     * const labProfile = await prisma.labProfile.upsert({
     *   create: {
     *     // ... data to create a LabProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabProfile we want to update
     *   }
     * })
     */
    upsert<T extends LabProfileUpsertArgs>(args: SelectSubset<T, LabProfileUpsertArgs<ExtArgs>>): Prisma__LabProfileClient<$Result.GetResult<Prisma.$LabProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileCountArgs} args - Arguments to filter LabProfiles to count.
     * @example
     * // Count the number of LabProfiles
     * const count = await prisma.labProfile.count({
     *   where: {
     *     // ... the filter for the LabProfiles we want to count
     *   }
     * })
    **/
    count<T extends LabProfileCountArgs>(
      args?: Subset<T, LabProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabProfileAggregateArgs>(args: Subset<T, LabProfileAggregateArgs>): Prisma.PrismaPromise<GetLabProfileAggregateType<T>>

    /**
     * Group by LabProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabProfileGroupByArgs['orderBy'] }
        : { orderBy?: LabProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabProfile model
   */
  readonly fields: LabProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profilePhoto<T extends LabProfile$profilePhotoArgs<ExtArgs> = {}>(args?: Subset<T, LabProfile$profilePhotoArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabProfile model
   */
  interface LabProfileFieldRefs {
    readonly createdAt: FieldRef<"LabProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LabProfile", 'DateTime'>
    readonly id: FieldRef<"LabProfile", 'String'>
    readonly labId: FieldRef<"LabProfile", 'String'>
    readonly bio: FieldRef<"LabProfile", 'String'>
    readonly instagram: FieldRef<"LabProfile", 'String'>
    readonly profilePhotoId: FieldRef<"LabProfile", 'String'>
    readonly slug: FieldRef<"LabProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabProfile findUnique
   */
  export type LabProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabProfile to fetch.
     */
    where: LabProfileWhereUniqueInput
  }

  /**
   * LabProfile findUniqueOrThrow
   */
  export type LabProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabProfile to fetch.
     */
    where: LabProfileWhereUniqueInput
  }

  /**
   * LabProfile findFirst
   */
  export type LabProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabProfile to fetch.
     */
    where?: LabProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabProfiles to fetch.
     */
    orderBy?: LabProfileOrderByWithRelationInput | LabProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabProfiles.
     */
    cursor?: LabProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabProfiles.
     */
    distinct?: LabProfileScalarFieldEnum | LabProfileScalarFieldEnum[]
  }

  /**
   * LabProfile findFirstOrThrow
   */
  export type LabProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabProfile to fetch.
     */
    where?: LabProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabProfiles to fetch.
     */
    orderBy?: LabProfileOrderByWithRelationInput | LabProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabProfiles.
     */
    cursor?: LabProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabProfiles.
     */
    distinct?: LabProfileScalarFieldEnum | LabProfileScalarFieldEnum[]
  }

  /**
   * LabProfile findMany
   */
  export type LabProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter, which LabProfiles to fetch.
     */
    where?: LabProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabProfiles to fetch.
     */
    orderBy?: LabProfileOrderByWithRelationInput | LabProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabProfiles.
     */
    cursor?: LabProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabProfiles.
     */
    skip?: number
    distinct?: LabProfileScalarFieldEnum | LabProfileScalarFieldEnum[]
  }

  /**
   * LabProfile create
   */
  export type LabProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LabProfile.
     */
    data: XOR<LabProfileCreateInput, LabProfileUncheckedCreateInput>
  }

  /**
   * LabProfile createMany
   */
  export type LabProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabProfiles.
     */
    data: LabProfileCreateManyInput | LabProfileCreateManyInput[]
  }

  /**
   * LabProfile createManyAndReturn
   */
  export type LabProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LabProfiles.
     */
    data: LabProfileCreateManyInput | LabProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabProfile update
   */
  export type LabProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LabProfile.
     */
    data: XOR<LabProfileUpdateInput, LabProfileUncheckedUpdateInput>
    /**
     * Choose, which LabProfile to update.
     */
    where: LabProfileWhereUniqueInput
  }

  /**
   * LabProfile updateMany
   */
  export type LabProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabProfiles.
     */
    data: XOR<LabProfileUpdateManyMutationInput, LabProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabProfiles to update
     */
    where?: LabProfileWhereInput
    /**
     * Limit how many LabProfiles to update.
     */
    limit?: number
  }

  /**
   * LabProfile updateManyAndReturn
   */
  export type LabProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * The data used to update LabProfiles.
     */
    data: XOR<LabProfileUpdateManyMutationInput, LabProfileUncheckedUpdateManyInput>
    /**
     * Filter which LabProfiles to update
     */
    where?: LabProfileWhereInput
    /**
     * Limit how many LabProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabProfile upsert
   */
  export type LabProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LabProfile to update in case it exists.
     */
    where: LabProfileWhereUniqueInput
    /**
     * In case the LabProfile found by the `where` argument doesn't exist, create a new LabProfile with this data.
     */
    create: XOR<LabProfileCreateInput, LabProfileUncheckedCreateInput>
    /**
     * In case the LabProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabProfileUpdateInput, LabProfileUncheckedUpdateInput>
  }

  /**
   * LabProfile delete
   */
  export type LabProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
    /**
     * Filter which LabProfile to delete.
     */
    where: LabProfileWhereUniqueInput
  }

  /**
   * LabProfile deleteMany
   */
  export type LabProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabProfiles to delete
     */
    where?: LabProfileWhereInput
    /**
     * Limit how many LabProfiles to delete.
     */
    limit?: number
  }

  /**
   * LabProfile.profilePhoto
   */
  export type LabProfile$profilePhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * LabProfile without action
   */
  export type LabProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabProfile
     */
    select?: LabProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabProfile
     */
    omit?: LabProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserLabJoin
   */

  export type AggregateUserLabJoin = {
    _count: UserLabJoinCountAggregateOutputType | null
    _min: UserLabJoinMinAggregateOutputType | null
    _max: UserLabJoinMaxAggregateOutputType | null
  }

  export type UserLabJoinMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    labId: string | null
  }

  export type UserLabJoinMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    labId: string | null
  }

  export type UserLabJoinCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    userId: number
    labId: number
    _all: number
  }


  export type UserLabJoinMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
  }

  export type UserLabJoinMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
  }

  export type UserLabJoinCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
    _all?: true
  }

  export type UserLabJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLabJoin to aggregate.
     */
    where?: UserLabJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabJoins to fetch.
     */
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLabJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLabJoins
    **/
    _count?: true | UserLabJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLabJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLabJoinMaxAggregateInputType
  }

  export type GetUserLabJoinAggregateType<T extends UserLabJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLabJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLabJoin[P]>
      : GetScalarType<T[P], AggregateUserLabJoin[P]>
  }




  export type UserLabJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabJoinWhereInput
    orderBy?: UserLabJoinOrderByWithAggregationInput | UserLabJoinOrderByWithAggregationInput[]
    by: UserLabJoinScalarFieldEnum[] | UserLabJoinScalarFieldEnum
    having?: UserLabJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLabJoinCountAggregateInputType | true
    _min?: UserLabJoinMinAggregateInputType
    _max?: UserLabJoinMaxAggregateInputType
  }

  export type UserLabJoinGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    userId: string
    labId: string
    _count: UserLabJoinCountAggregateOutputType | null
    _min: UserLabJoinMinAggregateOutputType | null
    _max: UserLabJoinMaxAggregateOutputType | null
  }

  type GetUserLabJoinGroupByPayload<T extends UserLabJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLabJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLabJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLabJoinGroupByOutputType[P]>
            : GetScalarType<T[P], UserLabJoinGroupByOutputType[P]>
        }
      >
    >


  export type UserLabJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
    userLabRoles?: boolean | UserLabJoin$userLabRolesArgs<ExtArgs>
    _count?: boolean | UserLabJoinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabJoin"]>

  export type UserLabJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabJoin"]>

  export type UserLabJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabJoin"]>

  export type UserLabJoinSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
  }

  export type UserLabJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "userId" | "labId", ExtArgs["result"]["userLabJoin"]>
  export type UserLabJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
    userLabRoles?: boolean | UserLabJoin$userLabRolesArgs<ExtArgs>
    _count?: boolean | UserLabJoinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserLabJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }
  export type UserLabJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }

  export type $UserLabJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLabJoin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lab: Prisma.$LabPayload<ExtArgs>
      userLabRoles: Prisma.$UserLabRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      userId: string
      labId: string
    }, ExtArgs["result"]["userLabJoin"]>
    composites: {}
  }

  type UserLabJoinGetPayload<S extends boolean | null | undefined | UserLabJoinDefaultArgs> = $Result.GetResult<Prisma.$UserLabJoinPayload, S>

  type UserLabJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLabJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLabJoinCountAggregateInputType | true
    }

  export interface UserLabJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLabJoin'], meta: { name: 'UserLabJoin' } }
    /**
     * Find zero or one UserLabJoin that matches the filter.
     * @param {UserLabJoinFindUniqueArgs} args - Arguments to find a UserLabJoin
     * @example
     * // Get one UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLabJoinFindUniqueArgs>(args: SelectSubset<T, UserLabJoinFindUniqueArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLabJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLabJoinFindUniqueOrThrowArgs} args - Arguments to find a UserLabJoin
     * @example
     * // Get one UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLabJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLabJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLabJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinFindFirstArgs} args - Arguments to find a UserLabJoin
     * @example
     * // Get one UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLabJoinFindFirstArgs>(args?: SelectSubset<T, UserLabJoinFindFirstArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLabJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinFindFirstOrThrowArgs} args - Arguments to find a UserLabJoin
     * @example
     * // Get one UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLabJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLabJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLabJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLabJoins
     * const userLabJoins = await prisma.userLabJoin.findMany()
     * 
     * // Get first 10 UserLabJoins
     * const userLabJoins = await prisma.userLabJoin.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const userLabJoinWithCreatedAtOnly = await prisma.userLabJoin.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends UserLabJoinFindManyArgs>(args?: SelectSubset<T, UserLabJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLabJoin.
     * @param {UserLabJoinCreateArgs} args - Arguments to create a UserLabJoin.
     * @example
     * // Create one UserLabJoin
     * const UserLabJoin = await prisma.userLabJoin.create({
     *   data: {
     *     // ... data to create a UserLabJoin
     *   }
     * })
     * 
     */
    create<T extends UserLabJoinCreateArgs>(args: SelectSubset<T, UserLabJoinCreateArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLabJoins.
     * @param {UserLabJoinCreateManyArgs} args - Arguments to create many UserLabJoins.
     * @example
     * // Create many UserLabJoins
     * const userLabJoin = await prisma.userLabJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLabJoinCreateManyArgs>(args?: SelectSubset<T, UserLabJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLabJoins and returns the data saved in the database.
     * @param {UserLabJoinCreateManyAndReturnArgs} args - Arguments to create many UserLabJoins.
     * @example
     * // Create many UserLabJoins
     * const userLabJoin = await prisma.userLabJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLabJoins and only return the `createdAt`
     * const userLabJoinWithCreatedAtOnly = await prisma.userLabJoin.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLabJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLabJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLabJoin.
     * @param {UserLabJoinDeleteArgs} args - Arguments to delete one UserLabJoin.
     * @example
     * // Delete one UserLabJoin
     * const UserLabJoin = await prisma.userLabJoin.delete({
     *   where: {
     *     // ... filter to delete one UserLabJoin
     *   }
     * })
     * 
     */
    delete<T extends UserLabJoinDeleteArgs>(args: SelectSubset<T, UserLabJoinDeleteArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLabJoin.
     * @param {UserLabJoinUpdateArgs} args - Arguments to update one UserLabJoin.
     * @example
     * // Update one UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLabJoinUpdateArgs>(args: SelectSubset<T, UserLabJoinUpdateArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLabJoins.
     * @param {UserLabJoinDeleteManyArgs} args - Arguments to filter UserLabJoins to delete.
     * @example
     * // Delete a few UserLabJoins
     * const { count } = await prisma.userLabJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLabJoinDeleteManyArgs>(args?: SelectSubset<T, UserLabJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLabJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLabJoins
     * const userLabJoin = await prisma.userLabJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLabJoinUpdateManyArgs>(args: SelectSubset<T, UserLabJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLabJoins and returns the data updated in the database.
     * @param {UserLabJoinUpdateManyAndReturnArgs} args - Arguments to update many UserLabJoins.
     * @example
     * // Update many UserLabJoins
     * const userLabJoin = await prisma.userLabJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLabJoins and only return the `createdAt`
     * const userLabJoinWithCreatedAtOnly = await prisma.userLabJoin.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLabJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLabJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLabJoin.
     * @param {UserLabJoinUpsertArgs} args - Arguments to update or create a UserLabJoin.
     * @example
     * // Update or create a UserLabJoin
     * const userLabJoin = await prisma.userLabJoin.upsert({
     *   create: {
     *     // ... data to create a UserLabJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLabJoin we want to update
     *   }
     * })
     */
    upsert<T extends UserLabJoinUpsertArgs>(args: SelectSubset<T, UserLabJoinUpsertArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLabJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinCountArgs} args - Arguments to filter UserLabJoins to count.
     * @example
     * // Count the number of UserLabJoins
     * const count = await prisma.userLabJoin.count({
     *   where: {
     *     // ... the filter for the UserLabJoins we want to count
     *   }
     * })
    **/
    count<T extends UserLabJoinCountArgs>(
      args?: Subset<T, UserLabJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLabJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLabJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLabJoinAggregateArgs>(args: Subset<T, UserLabJoinAggregateArgs>): Prisma.PrismaPromise<GetUserLabJoinAggregateType<T>>

    /**
     * Group by UserLabJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLabJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLabJoinGroupByArgs['orderBy'] }
        : { orderBy?: UserLabJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLabJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLabJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLabJoin model
   */
  readonly fields: UserLabJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLabJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLabJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userLabRoles<T extends UserLabJoin$userLabRolesArgs<ExtArgs> = {}>(args?: Subset<T, UserLabJoin$userLabRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLabJoin model
   */
  interface UserLabJoinFieldRefs {
    readonly createdAt: FieldRef<"UserLabJoin", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLabJoin", 'DateTime'>
    readonly userId: FieldRef<"UserLabJoin", 'String'>
    readonly labId: FieldRef<"UserLabJoin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserLabJoin findUnique
   */
  export type UserLabJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserLabJoin to fetch.
     */
    where: UserLabJoinWhereUniqueInput
  }

  /**
   * UserLabJoin findUniqueOrThrow
   */
  export type UserLabJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserLabJoin to fetch.
     */
    where: UserLabJoinWhereUniqueInput
  }

  /**
   * UserLabJoin findFirst
   */
  export type UserLabJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserLabJoin to fetch.
     */
    where?: UserLabJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabJoins to fetch.
     */
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLabJoins.
     */
    cursor?: UserLabJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLabJoins.
     */
    distinct?: UserLabJoinScalarFieldEnum | UserLabJoinScalarFieldEnum[]
  }

  /**
   * UserLabJoin findFirstOrThrow
   */
  export type UserLabJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserLabJoin to fetch.
     */
    where?: UserLabJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabJoins to fetch.
     */
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLabJoins.
     */
    cursor?: UserLabJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLabJoins.
     */
    distinct?: UserLabJoinScalarFieldEnum | UserLabJoinScalarFieldEnum[]
  }

  /**
   * UserLabJoin findMany
   */
  export type UserLabJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserLabJoins to fetch.
     */
    where?: UserLabJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabJoins to fetch.
     */
    orderBy?: UserLabJoinOrderByWithRelationInput | UserLabJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLabJoins.
     */
    cursor?: UserLabJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabJoins.
     */
    skip?: number
    distinct?: UserLabJoinScalarFieldEnum | UserLabJoinScalarFieldEnum[]
  }

  /**
   * UserLabJoin create
   */
  export type UserLabJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLabJoin.
     */
    data: XOR<UserLabJoinCreateInput, UserLabJoinUncheckedCreateInput>
  }

  /**
   * UserLabJoin createMany
   */
  export type UserLabJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLabJoins.
     */
    data: UserLabJoinCreateManyInput | UserLabJoinCreateManyInput[]
  }

  /**
   * UserLabJoin createManyAndReturn
   */
  export type UserLabJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * The data used to create many UserLabJoins.
     */
    data: UserLabJoinCreateManyInput | UserLabJoinCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLabJoin update
   */
  export type UserLabJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLabJoin.
     */
    data: XOR<UserLabJoinUpdateInput, UserLabJoinUncheckedUpdateInput>
    /**
     * Choose, which UserLabJoin to update.
     */
    where: UserLabJoinWhereUniqueInput
  }

  /**
   * UserLabJoin updateMany
   */
  export type UserLabJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLabJoins.
     */
    data: XOR<UserLabJoinUpdateManyMutationInput, UserLabJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserLabJoins to update
     */
    where?: UserLabJoinWhereInput
    /**
     * Limit how many UserLabJoins to update.
     */
    limit?: number
  }

  /**
   * UserLabJoin updateManyAndReturn
   */
  export type UserLabJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * The data used to update UserLabJoins.
     */
    data: XOR<UserLabJoinUpdateManyMutationInput, UserLabJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserLabJoins to update
     */
    where?: UserLabJoinWhereInput
    /**
     * Limit how many UserLabJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLabJoin upsert
   */
  export type UserLabJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLabJoin to update in case it exists.
     */
    where: UserLabJoinWhereUniqueInput
    /**
     * In case the UserLabJoin found by the `where` argument doesn't exist, create a new UserLabJoin with this data.
     */
    create: XOR<UserLabJoinCreateInput, UserLabJoinUncheckedCreateInput>
    /**
     * In case the UserLabJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLabJoinUpdateInput, UserLabJoinUncheckedUpdateInput>
  }

  /**
   * UserLabJoin delete
   */
  export type UserLabJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
    /**
     * Filter which UserLabJoin to delete.
     */
    where: UserLabJoinWhereUniqueInput
  }

  /**
   * UserLabJoin deleteMany
   */
  export type UserLabJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLabJoins to delete
     */
    where?: UserLabJoinWhereInput
    /**
     * Limit how many UserLabJoins to delete.
     */
    limit?: number
  }

  /**
   * UserLabJoin.userLabRoles
   */
  export type UserLabJoin$userLabRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    where?: UserLabRoleWhereInput
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    cursor?: UserLabRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLabRoleScalarFieldEnum | UserLabRoleScalarFieldEnum[]
  }

  /**
   * UserLabJoin without action
   */
  export type UserLabJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabJoin
     */
    select?: UserLabJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabJoin
     */
    omit?: UserLabJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabJoinInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    priority: number | null
  }

  export type RoleSumAggregateOutputType = {
    priority: number | null
  }

  export type RoleMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    labId: string | null
    public: boolean | null
    priority: number | null
    isTeamRole: boolean | null
  }

  export type RoleMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    labId: string | null
    public: boolean | null
    priority: number | null
    isTeamRole: boolean | null
  }

  export type RoleCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    name: number
    shortDescription: number
    longDescription: number
    labId: number
    public: number
    priority: number
    isTeamRole: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    priority?: true
  }

  export type RoleSumAggregateInputType = {
    priority?: true
  }

  export type RoleMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    labId?: true
    public?: true
    priority?: true
    isTeamRole?: true
  }

  export type RoleMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    labId?: true
    public?: true
    priority?: true
    isTeamRole?: true
  }

  export type RoleCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    labId?: true
    public?: true
    priority?: true
    isTeamRole?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    shortDescription: string | null
    longDescription: string | null
    labId: string
    public: boolean
    priority: number
    isTeamRole: boolean
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    labId?: boolean
    public?: boolean
    priority?: boolean
    isTeamRole?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    userLabRoles?: boolean | Role$userLabRolesArgs<ExtArgs>
    privileges?: boolean | Role$privilegesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    labId?: boolean
    public?: boolean
    priority?: boolean
    isTeamRole?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    labId?: boolean
    public?: boolean
    priority?: boolean
    isTeamRole?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    labId?: boolean
    public?: boolean
    priority?: boolean
    isTeamRole?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "name" | "shortDescription" | "longDescription" | "labId" | "public" | "priority" | "isTeamRole", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    userLabRoles?: boolean | Role$userLabRolesArgs<ExtArgs>
    privileges?: boolean | Role$privilegesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      userLabRoles: Prisma.$UserLabRolePayload<ExtArgs>[]
      privileges: Prisma.$RolePrivilegeJoinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
      shortDescription: string | null
      longDescription: string | null
      labId: string
      public: boolean
      priority: number
      isTeamRole: boolean
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const roleWithCreatedAtOnly = await prisma.role.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `createdAt`
     * const roleWithCreatedAtOnly = await prisma.role.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `createdAt`
     * const roleWithCreatedAtOnly = await prisma.role.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userLabRoles<T extends Role$userLabRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userLabRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privileges<T extends Role$privilegesArgs<ExtArgs> = {}>(args?: Subset<T, Role$privilegesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly shortDescription: FieldRef<"Role", 'String'>
    readonly longDescription: FieldRef<"Role", 'String'>
    readonly labId: FieldRef<"Role", 'String'>
    readonly public: FieldRef<"Role", 'Boolean'>
    readonly priority: FieldRef<"Role", 'Int'>
    readonly isTeamRole: FieldRef<"Role", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userLabRoles
   */
  export type Role$userLabRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    where?: UserLabRoleWhereInput
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    cursor?: UserLabRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLabRoleScalarFieldEnum | UserLabRoleScalarFieldEnum[]
  }

  /**
   * Role.privileges
   */
  export type Role$privilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    where?: RolePrivilegeJoinWhereInput
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    cursor?: RolePrivilegeJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePrivilegeJoinScalarFieldEnum | RolePrivilegeJoinScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserLabRole
   */

  export type AggregateUserLabRole = {
    _count: UserLabRoleCountAggregateOutputType | null
    _min: UserLabRoleMinAggregateOutputType | null
    _max: UserLabRoleMaxAggregateOutputType | null
  }

  export type UserLabRoleMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    labId: string | null
    roleId: string | null
    expiresAt: Date | null
  }

  export type UserLabRoleMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    labId: string | null
    roleId: string | null
    expiresAt: Date | null
  }

  export type UserLabRoleCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    userId: number
    labId: number
    roleId: number
    expiresAt: number
    _all: number
  }


  export type UserLabRoleMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
    roleId?: true
    expiresAt?: true
  }

  export type UserLabRoleMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
    roleId?: true
    expiresAt?: true
  }

  export type UserLabRoleCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    userId?: true
    labId?: true
    roleId?: true
    expiresAt?: true
    _all?: true
  }

  export type UserLabRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLabRole to aggregate.
     */
    where?: UserLabRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabRoles to fetch.
     */
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLabRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLabRoles
    **/
    _count?: true | UserLabRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLabRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLabRoleMaxAggregateInputType
  }

  export type GetUserLabRoleAggregateType<T extends UserLabRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLabRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLabRole[P]>
      : GetScalarType<T[P], AggregateUserLabRole[P]>
  }




  export type UserLabRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLabRoleWhereInput
    orderBy?: UserLabRoleOrderByWithAggregationInput | UserLabRoleOrderByWithAggregationInput[]
    by: UserLabRoleScalarFieldEnum[] | UserLabRoleScalarFieldEnum
    having?: UserLabRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLabRoleCountAggregateInputType | true
    _min?: UserLabRoleMinAggregateInputType
    _max?: UserLabRoleMaxAggregateInputType
  }

  export type UserLabRoleGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    userId: string
    labId: string
    roleId: string
    expiresAt: Date | null
    _count: UserLabRoleCountAggregateOutputType | null
    _min: UserLabRoleMinAggregateOutputType | null
    _max: UserLabRoleMaxAggregateOutputType | null
  }

  type GetUserLabRoleGroupByPayload<T extends UserLabRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLabRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLabRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLabRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserLabRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserLabRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    roleId?: boolean
    expiresAt?: boolean
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabRole"]>

  export type UserLabRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    roleId?: boolean
    expiresAt?: boolean
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabRole"]>

  export type UserLabRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    roleId?: boolean
    expiresAt?: boolean
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLabRole"]>

  export type UserLabRoleSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    labId?: boolean
    roleId?: boolean
    expiresAt?: boolean
  }

  export type UserLabRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "userId" | "labId" | "roleId" | "expiresAt", ExtArgs["result"]["userLabRole"]>
  export type UserLabRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserLabRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserLabRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLabJoin?: boolean | UserLabJoinDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserLabRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLabRole"
    objects: {
      userLabJoin: Prisma.$UserLabJoinPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      userId: string
      labId: string
      roleId: string
      expiresAt: Date | null
    }, ExtArgs["result"]["userLabRole"]>
    composites: {}
  }

  type UserLabRoleGetPayload<S extends boolean | null | undefined | UserLabRoleDefaultArgs> = $Result.GetResult<Prisma.$UserLabRolePayload, S>

  type UserLabRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLabRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLabRoleCountAggregateInputType | true
    }

  export interface UserLabRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLabRole'], meta: { name: 'UserLabRole' } }
    /**
     * Find zero or one UserLabRole that matches the filter.
     * @param {UserLabRoleFindUniqueArgs} args - Arguments to find a UserLabRole
     * @example
     * // Get one UserLabRole
     * const userLabRole = await prisma.userLabRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLabRoleFindUniqueArgs>(args: SelectSubset<T, UserLabRoleFindUniqueArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLabRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLabRoleFindUniqueOrThrowArgs} args - Arguments to find a UserLabRole
     * @example
     * // Get one UserLabRole
     * const userLabRole = await prisma.userLabRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLabRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLabRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLabRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleFindFirstArgs} args - Arguments to find a UserLabRole
     * @example
     * // Get one UserLabRole
     * const userLabRole = await prisma.userLabRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLabRoleFindFirstArgs>(args?: SelectSubset<T, UserLabRoleFindFirstArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLabRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleFindFirstOrThrowArgs} args - Arguments to find a UserLabRole
     * @example
     * // Get one UserLabRole
     * const userLabRole = await prisma.userLabRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLabRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLabRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLabRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLabRoles
     * const userLabRoles = await prisma.userLabRole.findMany()
     * 
     * // Get first 10 UserLabRoles
     * const userLabRoles = await prisma.userLabRole.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const userLabRoleWithCreatedAtOnly = await prisma.userLabRole.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends UserLabRoleFindManyArgs>(args?: SelectSubset<T, UserLabRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLabRole.
     * @param {UserLabRoleCreateArgs} args - Arguments to create a UserLabRole.
     * @example
     * // Create one UserLabRole
     * const UserLabRole = await prisma.userLabRole.create({
     *   data: {
     *     // ... data to create a UserLabRole
     *   }
     * })
     * 
     */
    create<T extends UserLabRoleCreateArgs>(args: SelectSubset<T, UserLabRoleCreateArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLabRoles.
     * @param {UserLabRoleCreateManyArgs} args - Arguments to create many UserLabRoles.
     * @example
     * // Create many UserLabRoles
     * const userLabRole = await prisma.userLabRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLabRoleCreateManyArgs>(args?: SelectSubset<T, UserLabRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLabRoles and returns the data saved in the database.
     * @param {UserLabRoleCreateManyAndReturnArgs} args - Arguments to create many UserLabRoles.
     * @example
     * // Create many UserLabRoles
     * const userLabRole = await prisma.userLabRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLabRoles and only return the `createdAt`
     * const userLabRoleWithCreatedAtOnly = await prisma.userLabRole.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLabRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLabRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLabRole.
     * @param {UserLabRoleDeleteArgs} args - Arguments to delete one UserLabRole.
     * @example
     * // Delete one UserLabRole
     * const UserLabRole = await prisma.userLabRole.delete({
     *   where: {
     *     // ... filter to delete one UserLabRole
     *   }
     * })
     * 
     */
    delete<T extends UserLabRoleDeleteArgs>(args: SelectSubset<T, UserLabRoleDeleteArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLabRole.
     * @param {UserLabRoleUpdateArgs} args - Arguments to update one UserLabRole.
     * @example
     * // Update one UserLabRole
     * const userLabRole = await prisma.userLabRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLabRoleUpdateArgs>(args: SelectSubset<T, UserLabRoleUpdateArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLabRoles.
     * @param {UserLabRoleDeleteManyArgs} args - Arguments to filter UserLabRoles to delete.
     * @example
     * // Delete a few UserLabRoles
     * const { count } = await prisma.userLabRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLabRoleDeleteManyArgs>(args?: SelectSubset<T, UserLabRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLabRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLabRoles
     * const userLabRole = await prisma.userLabRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLabRoleUpdateManyArgs>(args: SelectSubset<T, UserLabRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLabRoles and returns the data updated in the database.
     * @param {UserLabRoleUpdateManyAndReturnArgs} args - Arguments to update many UserLabRoles.
     * @example
     * // Update many UserLabRoles
     * const userLabRole = await prisma.userLabRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLabRoles and only return the `createdAt`
     * const userLabRoleWithCreatedAtOnly = await prisma.userLabRole.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLabRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLabRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLabRole.
     * @param {UserLabRoleUpsertArgs} args - Arguments to update or create a UserLabRole.
     * @example
     * // Update or create a UserLabRole
     * const userLabRole = await prisma.userLabRole.upsert({
     *   create: {
     *     // ... data to create a UserLabRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLabRole we want to update
     *   }
     * })
     */
    upsert<T extends UserLabRoleUpsertArgs>(args: SelectSubset<T, UserLabRoleUpsertArgs<ExtArgs>>): Prisma__UserLabRoleClient<$Result.GetResult<Prisma.$UserLabRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLabRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleCountArgs} args - Arguments to filter UserLabRoles to count.
     * @example
     * // Count the number of UserLabRoles
     * const count = await prisma.userLabRole.count({
     *   where: {
     *     // ... the filter for the UserLabRoles we want to count
     *   }
     * })
    **/
    count<T extends UserLabRoleCountArgs>(
      args?: Subset<T, UserLabRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLabRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLabRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLabRoleAggregateArgs>(args: Subset<T, UserLabRoleAggregateArgs>): Prisma.PrismaPromise<GetUserLabRoleAggregateType<T>>

    /**
     * Group by UserLabRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLabRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLabRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLabRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserLabRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLabRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLabRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLabRole model
   */
  readonly fields: UserLabRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLabRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLabRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userLabJoin<T extends UserLabJoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserLabJoinDefaultArgs<ExtArgs>>): Prisma__UserLabJoinClient<$Result.GetResult<Prisma.$UserLabJoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLabRole model
   */
  interface UserLabRoleFieldRefs {
    readonly createdAt: FieldRef<"UserLabRole", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLabRole", 'DateTime'>
    readonly userId: FieldRef<"UserLabRole", 'String'>
    readonly labId: FieldRef<"UserLabRole", 'String'>
    readonly roleId: FieldRef<"UserLabRole", 'String'>
    readonly expiresAt: FieldRef<"UserLabRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLabRole findUnique
   */
  export type UserLabRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserLabRole to fetch.
     */
    where: UserLabRoleWhereUniqueInput
  }

  /**
   * UserLabRole findUniqueOrThrow
   */
  export type UserLabRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserLabRole to fetch.
     */
    where: UserLabRoleWhereUniqueInput
  }

  /**
   * UserLabRole findFirst
   */
  export type UserLabRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserLabRole to fetch.
     */
    where?: UserLabRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabRoles to fetch.
     */
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLabRoles.
     */
    cursor?: UserLabRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLabRoles.
     */
    distinct?: UserLabRoleScalarFieldEnum | UserLabRoleScalarFieldEnum[]
  }

  /**
   * UserLabRole findFirstOrThrow
   */
  export type UserLabRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserLabRole to fetch.
     */
    where?: UserLabRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabRoles to fetch.
     */
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLabRoles.
     */
    cursor?: UserLabRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLabRoles.
     */
    distinct?: UserLabRoleScalarFieldEnum | UserLabRoleScalarFieldEnum[]
  }

  /**
   * UserLabRole findMany
   */
  export type UserLabRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserLabRoles to fetch.
     */
    where?: UserLabRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLabRoles to fetch.
     */
    orderBy?: UserLabRoleOrderByWithRelationInput | UserLabRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLabRoles.
     */
    cursor?: UserLabRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLabRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLabRoles.
     */
    skip?: number
    distinct?: UserLabRoleScalarFieldEnum | UserLabRoleScalarFieldEnum[]
  }

  /**
   * UserLabRole create
   */
  export type UserLabRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLabRole.
     */
    data: XOR<UserLabRoleCreateInput, UserLabRoleUncheckedCreateInput>
  }

  /**
   * UserLabRole createMany
   */
  export type UserLabRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLabRoles.
     */
    data: UserLabRoleCreateManyInput | UserLabRoleCreateManyInput[]
  }

  /**
   * UserLabRole createManyAndReturn
   */
  export type UserLabRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserLabRoles.
     */
    data: UserLabRoleCreateManyInput | UserLabRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLabRole update
   */
  export type UserLabRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLabRole.
     */
    data: XOR<UserLabRoleUpdateInput, UserLabRoleUncheckedUpdateInput>
    /**
     * Choose, which UserLabRole to update.
     */
    where: UserLabRoleWhereUniqueInput
  }

  /**
   * UserLabRole updateMany
   */
  export type UserLabRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLabRoles.
     */
    data: XOR<UserLabRoleUpdateManyMutationInput, UserLabRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserLabRoles to update
     */
    where?: UserLabRoleWhereInput
    /**
     * Limit how many UserLabRoles to update.
     */
    limit?: number
  }

  /**
   * UserLabRole updateManyAndReturn
   */
  export type UserLabRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserLabRoles.
     */
    data: XOR<UserLabRoleUpdateManyMutationInput, UserLabRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserLabRoles to update
     */
    where?: UserLabRoleWhereInput
    /**
     * Limit how many UserLabRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLabRole upsert
   */
  export type UserLabRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLabRole to update in case it exists.
     */
    where: UserLabRoleWhereUniqueInput
    /**
     * In case the UserLabRole found by the `where` argument doesn't exist, create a new UserLabRole with this data.
     */
    create: XOR<UserLabRoleCreateInput, UserLabRoleUncheckedCreateInput>
    /**
     * In case the UserLabRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLabRoleUpdateInput, UserLabRoleUncheckedUpdateInput>
  }

  /**
   * UserLabRole delete
   */
  export type UserLabRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
    /**
     * Filter which UserLabRole to delete.
     */
    where: UserLabRoleWhereUniqueInput
  }

  /**
   * UserLabRole deleteMany
   */
  export type UserLabRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLabRoles to delete
     */
    where?: UserLabRoleWhereInput
    /**
     * Limit how many UserLabRoles to delete.
     */
    limit?: number
  }

  /**
   * UserLabRole without action
   */
  export type UserLabRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLabRole
     */
    select?: UserLabRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLabRole
     */
    omit?: UserLabRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLabRoleInclude<ExtArgs> | null
  }


  /**
   * Model Privilege
   */

  export type AggregatePrivilege = {
    _count: PrivilegeCountAggregateOutputType | null
    _min: PrivilegeMinAggregateOutputType | null
    _max: PrivilegeMaxAggregateOutputType | null
  }

  export type PrivilegeMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    longDescription: string | null
    shortDescription: string | null
    labId: string | null
    public: boolean | null
  }

  export type PrivilegeMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    longDescription: string | null
    shortDescription: string | null
    labId: string | null
    public: boolean | null
  }

  export type PrivilegeCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    name: number
    longDescription: number
    shortDescription: number
    labId: number
    public: number
    _all: number
  }


  export type PrivilegeMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    longDescription?: true
    shortDescription?: true
    labId?: true
    public?: true
  }

  export type PrivilegeMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    longDescription?: true
    shortDescription?: true
    labId?: true
    public?: true
  }

  export type PrivilegeCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    longDescription?: true
    shortDescription?: true
    labId?: true
    public?: true
    _all?: true
  }

  export type PrivilegeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privilege to aggregate.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Privileges
    **/
    _count?: true | PrivilegeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivilegeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivilegeMaxAggregateInputType
  }

  export type GetPrivilegeAggregateType<T extends PrivilegeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivilege]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivilege[P]>
      : GetScalarType<T[P], AggregatePrivilege[P]>
  }




  export type PrivilegeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivilegeWhereInput
    orderBy?: PrivilegeOrderByWithAggregationInput | PrivilegeOrderByWithAggregationInput[]
    by: PrivilegeScalarFieldEnum[] | PrivilegeScalarFieldEnum
    having?: PrivilegeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivilegeCountAggregateInputType | true
    _min?: PrivilegeMinAggregateInputType
    _max?: PrivilegeMaxAggregateInputType
  }

  export type PrivilegeGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    longDescription: string | null
    shortDescription: string
    labId: string
    public: boolean
    _count: PrivilegeCountAggregateOutputType | null
    _min: PrivilegeMinAggregateOutputType | null
    _max: PrivilegeMaxAggregateOutputType | null
  }

  type GetPrivilegeGroupByPayload<T extends PrivilegeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivilegeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivilegeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivilegeGroupByOutputType[P]>
            : GetScalarType<T[P], PrivilegeGroupByOutputType[P]>
        }
      >
    >


  export type PrivilegeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    longDescription?: boolean
    shortDescription?: boolean
    labId?: boolean
    public?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    roles?: boolean | Privilege$rolesArgs<ExtArgs>
    labPermissions?: boolean | Privilege$labPermissionsArgs<ExtArgs>
    _count?: boolean | PrivilegeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privilege"]>

  export type PrivilegeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    longDescription?: boolean
    shortDescription?: boolean
    labId?: boolean
    public?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privilege"]>

  export type PrivilegeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    longDescription?: boolean
    shortDescription?: boolean
    labId?: boolean
    public?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privilege"]>

  export type PrivilegeSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    longDescription?: boolean
    shortDescription?: boolean
    labId?: boolean
    public?: boolean
  }

  export type PrivilegeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "name" | "longDescription" | "shortDescription" | "labId" | "public", ExtArgs["result"]["privilege"]>
  export type PrivilegeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    roles?: boolean | Privilege$rolesArgs<ExtArgs>
    labPermissions?: boolean | Privilege$labPermissionsArgs<ExtArgs>
    _count?: boolean | PrivilegeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrivilegeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }
  export type PrivilegeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }

  export type $PrivilegePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Privilege"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      roles: Prisma.$RolePrivilegeJoinPayload<ExtArgs>[]
      labPermissions: Prisma.$LabPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
      longDescription: string | null
      shortDescription: string
      labId: string
      public: boolean
    }, ExtArgs["result"]["privilege"]>
    composites: {}
  }

  type PrivilegeGetPayload<S extends boolean | null | undefined | PrivilegeDefaultArgs> = $Result.GetResult<Prisma.$PrivilegePayload, S>

  type PrivilegeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivilegeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivilegeCountAggregateInputType | true
    }

  export interface PrivilegeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Privilege'], meta: { name: 'Privilege' } }
    /**
     * Find zero or one Privilege that matches the filter.
     * @param {PrivilegeFindUniqueArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivilegeFindUniqueArgs>(args: SelectSubset<T, PrivilegeFindUniqueArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Privilege that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivilegeFindUniqueOrThrowArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivilegeFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivilegeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privilege that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindFirstArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivilegeFindFirstArgs>(args?: SelectSubset<T, PrivilegeFindFirstArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privilege that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindFirstOrThrowArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivilegeFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivilegeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Privileges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privileges
     * const privileges = await prisma.privilege.findMany()
     * 
     * // Get first 10 Privileges
     * const privileges = await prisma.privilege.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const privilegeWithCreatedAtOnly = await prisma.privilege.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends PrivilegeFindManyArgs>(args?: SelectSubset<T, PrivilegeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Privilege.
     * @param {PrivilegeCreateArgs} args - Arguments to create a Privilege.
     * @example
     * // Create one Privilege
     * const Privilege = await prisma.privilege.create({
     *   data: {
     *     // ... data to create a Privilege
     *   }
     * })
     * 
     */
    create<T extends PrivilegeCreateArgs>(args: SelectSubset<T, PrivilegeCreateArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Privileges.
     * @param {PrivilegeCreateManyArgs} args - Arguments to create many Privileges.
     * @example
     * // Create many Privileges
     * const privilege = await prisma.privilege.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivilegeCreateManyArgs>(args?: SelectSubset<T, PrivilegeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Privileges and returns the data saved in the database.
     * @param {PrivilegeCreateManyAndReturnArgs} args - Arguments to create many Privileges.
     * @example
     * // Create many Privileges
     * const privilege = await prisma.privilege.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Privileges and only return the `createdAt`
     * const privilegeWithCreatedAtOnly = await prisma.privilege.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivilegeCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivilegeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Privilege.
     * @param {PrivilegeDeleteArgs} args - Arguments to delete one Privilege.
     * @example
     * // Delete one Privilege
     * const Privilege = await prisma.privilege.delete({
     *   where: {
     *     // ... filter to delete one Privilege
     *   }
     * })
     * 
     */
    delete<T extends PrivilegeDeleteArgs>(args: SelectSubset<T, PrivilegeDeleteArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Privilege.
     * @param {PrivilegeUpdateArgs} args - Arguments to update one Privilege.
     * @example
     * // Update one Privilege
     * const privilege = await prisma.privilege.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivilegeUpdateArgs>(args: SelectSubset<T, PrivilegeUpdateArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Privileges.
     * @param {PrivilegeDeleteManyArgs} args - Arguments to filter Privileges to delete.
     * @example
     * // Delete a few Privileges
     * const { count } = await prisma.privilege.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivilegeDeleteManyArgs>(args?: SelectSubset<T, PrivilegeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privileges
     * const privilege = await prisma.privilege.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivilegeUpdateManyArgs>(args: SelectSubset<T, PrivilegeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privileges and returns the data updated in the database.
     * @param {PrivilegeUpdateManyAndReturnArgs} args - Arguments to update many Privileges.
     * @example
     * // Update many Privileges
     * const privilege = await prisma.privilege.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Privileges and only return the `createdAt`
     * const privilegeWithCreatedAtOnly = await prisma.privilege.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivilegeUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivilegeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Privilege.
     * @param {PrivilegeUpsertArgs} args - Arguments to update or create a Privilege.
     * @example
     * // Update or create a Privilege
     * const privilege = await prisma.privilege.upsert({
     *   create: {
     *     // ... data to create a Privilege
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privilege we want to update
     *   }
     * })
     */
    upsert<T extends PrivilegeUpsertArgs>(args: SelectSubset<T, PrivilegeUpsertArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeCountArgs} args - Arguments to filter Privileges to count.
     * @example
     * // Count the number of Privileges
     * const count = await prisma.privilege.count({
     *   where: {
     *     // ... the filter for the Privileges we want to count
     *   }
     * })
    **/
    count<T extends PrivilegeCountArgs>(
      args?: Subset<T, PrivilegeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivilegeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Privilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivilegeAggregateArgs>(args: Subset<T, PrivilegeAggregateArgs>): Prisma.PrismaPromise<GetPrivilegeAggregateType<T>>

    /**
     * Group by Privilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivilegeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivilegeGroupByArgs['orderBy'] }
        : { orderBy?: PrivilegeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivilegeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivilegeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Privilege model
   */
  readonly fields: PrivilegeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Privilege.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivilegeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends Privilege$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Privilege$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labPermissions<T extends Privilege$labPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Privilege$labPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Privilege model
   */
  interface PrivilegeFieldRefs {
    readonly createdAt: FieldRef<"Privilege", 'DateTime'>
    readonly updatedAt: FieldRef<"Privilege", 'DateTime'>
    readonly id: FieldRef<"Privilege", 'String'>
    readonly name: FieldRef<"Privilege", 'String'>
    readonly longDescription: FieldRef<"Privilege", 'String'>
    readonly shortDescription: FieldRef<"Privilege", 'String'>
    readonly labId: FieldRef<"Privilege", 'String'>
    readonly public: FieldRef<"Privilege", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Privilege findUnique
   */
  export type PrivilegeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege findUniqueOrThrow
   */
  export type PrivilegeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege findFirst
   */
  export type PrivilegeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privileges.
     */
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege findFirstOrThrow
   */
  export type PrivilegeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privileges.
     */
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege findMany
   */
  export type PrivilegeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privileges to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege create
   */
  export type PrivilegeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to create a Privilege.
     */
    data: XOR<PrivilegeCreateInput, PrivilegeUncheckedCreateInput>
  }

  /**
   * Privilege createMany
   */
  export type PrivilegeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Privileges.
     */
    data: PrivilegeCreateManyInput | PrivilegeCreateManyInput[]
  }

  /**
   * Privilege createManyAndReturn
   */
  export type PrivilegeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * The data used to create many Privileges.
     */
    data: PrivilegeCreateManyInput | PrivilegeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Privilege update
   */
  export type PrivilegeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to update a Privilege.
     */
    data: XOR<PrivilegeUpdateInput, PrivilegeUncheckedUpdateInput>
    /**
     * Choose, which Privilege to update.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege updateMany
   */
  export type PrivilegeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Privileges.
     */
    data: XOR<PrivilegeUpdateManyMutationInput, PrivilegeUncheckedUpdateManyInput>
    /**
     * Filter which Privileges to update
     */
    where?: PrivilegeWhereInput
    /**
     * Limit how many Privileges to update.
     */
    limit?: number
  }

  /**
   * Privilege updateManyAndReturn
   */
  export type PrivilegeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * The data used to update Privileges.
     */
    data: XOR<PrivilegeUpdateManyMutationInput, PrivilegeUncheckedUpdateManyInput>
    /**
     * Filter which Privileges to update
     */
    where?: PrivilegeWhereInput
    /**
     * Limit how many Privileges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Privilege upsert
   */
  export type PrivilegeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The filter to search for the Privilege to update in case it exists.
     */
    where: PrivilegeWhereUniqueInput
    /**
     * In case the Privilege found by the `where` argument doesn't exist, create a new Privilege with this data.
     */
    create: XOR<PrivilegeCreateInput, PrivilegeUncheckedCreateInput>
    /**
     * In case the Privilege was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivilegeUpdateInput, PrivilegeUncheckedUpdateInput>
  }

  /**
   * Privilege delete
   */
  export type PrivilegeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter which Privilege to delete.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege deleteMany
   */
  export type PrivilegeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privileges to delete
     */
    where?: PrivilegeWhereInput
    /**
     * Limit how many Privileges to delete.
     */
    limit?: number
  }

  /**
   * Privilege.roles
   */
  export type Privilege$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    where?: RolePrivilegeJoinWhereInput
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    cursor?: RolePrivilegeJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePrivilegeJoinScalarFieldEnum | RolePrivilegeJoinScalarFieldEnum[]
  }

  /**
   * Privilege.labPermissions
   */
  export type Privilege$labPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    where?: LabPermissionWhereInput
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    cursor?: LabPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabPermissionScalarFieldEnum | LabPermissionScalarFieldEnum[]
  }

  /**
   * Privilege without action
   */
  export type PrivilegeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
  }


  /**
   * Model LabPermission
   */

  export type AggregateLabPermission = {
    _count: LabPermissionCountAggregateOutputType | null
    _min: LabPermissionMinAggregateOutputType | null
    _max: LabPermissionMaxAggregateOutputType | null
  }

  export type LabPermissionMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    labId: string | null
    type: string | null
  }

  export type LabPermissionMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    labId: string | null
    type: string | null
  }

  export type LabPermissionCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    name: number
    labId: number
    type: number
    _all: number
  }


  export type LabPermissionMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    labId?: true
    type?: true
  }

  export type LabPermissionMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    labId?: true
    type?: true
  }

  export type LabPermissionCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    labId?: true
    type?: true
    _all?: true
  }

  export type LabPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabPermission to aggregate.
     */
    where?: LabPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabPermissions to fetch.
     */
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabPermissions
    **/
    _count?: true | LabPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabPermissionMaxAggregateInputType
  }

  export type GetLabPermissionAggregateType<T extends LabPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateLabPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabPermission[P]>
      : GetScalarType<T[P], AggregateLabPermission[P]>
  }




  export type LabPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabPermissionWhereInput
    orderBy?: LabPermissionOrderByWithAggregationInput | LabPermissionOrderByWithAggregationInput[]
    by: LabPermissionScalarFieldEnum[] | LabPermissionScalarFieldEnum
    having?: LabPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabPermissionCountAggregateInputType | true
    _min?: LabPermissionMinAggregateInputType
    _max?: LabPermissionMaxAggregateInputType
  }

  export type LabPermissionGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    labId: string
    type: string
    _count: LabPermissionCountAggregateOutputType | null
    _min: LabPermissionMinAggregateOutputType | null
    _max: LabPermissionMaxAggregateOutputType | null
  }

  type GetLabPermissionGroupByPayload<T extends LabPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], LabPermissionGroupByOutputType[P]>
        }
      >
    >


  export type LabPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    labId?: boolean
    type?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    privileges?: boolean | LabPermission$privilegesArgs<ExtArgs>
    _count?: boolean | LabPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labPermission"]>

  export type LabPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    labId?: boolean
    type?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labPermission"]>

  export type LabPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    labId?: boolean
    type?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labPermission"]>

  export type LabPermissionSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    labId?: boolean
    type?: boolean
  }

  export type LabPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "name" | "labId" | "type", ExtArgs["result"]["labPermission"]>
  export type LabPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    privileges?: boolean | LabPermission$privilegesArgs<ExtArgs>
    _count?: boolean | LabPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }
  export type LabPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
  }

  export type $LabPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabPermission"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      privileges: Prisma.$PrivilegePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
      labId: string
      type: string
    }, ExtArgs["result"]["labPermission"]>
    composites: {}
  }

  type LabPermissionGetPayload<S extends boolean | null | undefined | LabPermissionDefaultArgs> = $Result.GetResult<Prisma.$LabPermissionPayload, S>

  type LabPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabPermissionCountAggregateInputType | true
    }

  export interface LabPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabPermission'], meta: { name: 'LabPermission' } }
    /**
     * Find zero or one LabPermission that matches the filter.
     * @param {LabPermissionFindUniqueArgs} args - Arguments to find a LabPermission
     * @example
     * // Get one LabPermission
     * const labPermission = await prisma.labPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabPermissionFindUniqueArgs>(args: SelectSubset<T, LabPermissionFindUniqueArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabPermissionFindUniqueOrThrowArgs} args - Arguments to find a LabPermission
     * @example
     * // Get one LabPermission
     * const labPermission = await prisma.labPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, LabPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionFindFirstArgs} args - Arguments to find a LabPermission
     * @example
     * // Get one LabPermission
     * const labPermission = await prisma.labPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabPermissionFindFirstArgs>(args?: SelectSubset<T, LabPermissionFindFirstArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionFindFirstOrThrowArgs} args - Arguments to find a LabPermission
     * @example
     * // Get one LabPermission
     * const labPermission = await prisma.labPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, LabPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabPermissions
     * const labPermissions = await prisma.labPermission.findMany()
     * 
     * // Get first 10 LabPermissions
     * const labPermissions = await prisma.labPermission.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const labPermissionWithCreatedAtOnly = await prisma.labPermission.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends LabPermissionFindManyArgs>(args?: SelectSubset<T, LabPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabPermission.
     * @param {LabPermissionCreateArgs} args - Arguments to create a LabPermission.
     * @example
     * // Create one LabPermission
     * const LabPermission = await prisma.labPermission.create({
     *   data: {
     *     // ... data to create a LabPermission
     *   }
     * })
     * 
     */
    create<T extends LabPermissionCreateArgs>(args: SelectSubset<T, LabPermissionCreateArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabPermissions.
     * @param {LabPermissionCreateManyArgs} args - Arguments to create many LabPermissions.
     * @example
     * // Create many LabPermissions
     * const labPermission = await prisma.labPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabPermissionCreateManyArgs>(args?: SelectSubset<T, LabPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabPermissions and returns the data saved in the database.
     * @param {LabPermissionCreateManyAndReturnArgs} args - Arguments to create many LabPermissions.
     * @example
     * // Create many LabPermissions
     * const labPermission = await prisma.labPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabPermissions and only return the `createdAt`
     * const labPermissionWithCreatedAtOnly = await prisma.labPermission.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, LabPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabPermission.
     * @param {LabPermissionDeleteArgs} args - Arguments to delete one LabPermission.
     * @example
     * // Delete one LabPermission
     * const LabPermission = await prisma.labPermission.delete({
     *   where: {
     *     // ... filter to delete one LabPermission
     *   }
     * })
     * 
     */
    delete<T extends LabPermissionDeleteArgs>(args: SelectSubset<T, LabPermissionDeleteArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabPermission.
     * @param {LabPermissionUpdateArgs} args - Arguments to update one LabPermission.
     * @example
     * // Update one LabPermission
     * const labPermission = await prisma.labPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabPermissionUpdateArgs>(args: SelectSubset<T, LabPermissionUpdateArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabPermissions.
     * @param {LabPermissionDeleteManyArgs} args - Arguments to filter LabPermissions to delete.
     * @example
     * // Delete a few LabPermissions
     * const { count } = await prisma.labPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabPermissionDeleteManyArgs>(args?: SelectSubset<T, LabPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabPermissions
     * const labPermission = await prisma.labPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabPermissionUpdateManyArgs>(args: SelectSubset<T, LabPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabPermissions and returns the data updated in the database.
     * @param {LabPermissionUpdateManyAndReturnArgs} args - Arguments to update many LabPermissions.
     * @example
     * // Update many LabPermissions
     * const labPermission = await prisma.labPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabPermissions and only return the `createdAt`
     * const labPermissionWithCreatedAtOnly = await prisma.labPermission.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, LabPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabPermission.
     * @param {LabPermissionUpsertArgs} args - Arguments to update or create a LabPermission.
     * @example
     * // Update or create a LabPermission
     * const labPermission = await prisma.labPermission.upsert({
     *   create: {
     *     // ... data to create a LabPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabPermission we want to update
     *   }
     * })
     */
    upsert<T extends LabPermissionUpsertArgs>(args: SelectSubset<T, LabPermissionUpsertArgs<ExtArgs>>): Prisma__LabPermissionClient<$Result.GetResult<Prisma.$LabPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionCountArgs} args - Arguments to filter LabPermissions to count.
     * @example
     * // Count the number of LabPermissions
     * const count = await prisma.labPermission.count({
     *   where: {
     *     // ... the filter for the LabPermissions we want to count
     *   }
     * })
    **/
    count<T extends LabPermissionCountArgs>(
      args?: Subset<T, LabPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabPermissionAggregateArgs>(args: Subset<T, LabPermissionAggregateArgs>): Prisma.PrismaPromise<GetLabPermissionAggregateType<T>>

    /**
     * Group by LabPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabPermissionGroupByArgs['orderBy'] }
        : { orderBy?: LabPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabPermission model
   */
  readonly fields: LabPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    privileges<T extends LabPermission$privilegesArgs<ExtArgs> = {}>(args?: Subset<T, LabPermission$privilegesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabPermission model
   */
  interface LabPermissionFieldRefs {
    readonly createdAt: FieldRef<"LabPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"LabPermission", 'DateTime'>
    readonly id: FieldRef<"LabPermission", 'String'>
    readonly name: FieldRef<"LabPermission", 'String'>
    readonly labId: FieldRef<"LabPermission", 'String'>
    readonly type: FieldRef<"LabPermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabPermission findUnique
   */
  export type LabPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter, which LabPermission to fetch.
     */
    where: LabPermissionWhereUniqueInput
  }

  /**
   * LabPermission findUniqueOrThrow
   */
  export type LabPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter, which LabPermission to fetch.
     */
    where: LabPermissionWhereUniqueInput
  }

  /**
   * LabPermission findFirst
   */
  export type LabPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter, which LabPermission to fetch.
     */
    where?: LabPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabPermissions to fetch.
     */
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabPermissions.
     */
    cursor?: LabPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabPermissions.
     */
    distinct?: LabPermissionScalarFieldEnum | LabPermissionScalarFieldEnum[]
  }

  /**
   * LabPermission findFirstOrThrow
   */
  export type LabPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter, which LabPermission to fetch.
     */
    where?: LabPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabPermissions to fetch.
     */
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabPermissions.
     */
    cursor?: LabPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabPermissions.
     */
    distinct?: LabPermissionScalarFieldEnum | LabPermissionScalarFieldEnum[]
  }

  /**
   * LabPermission findMany
   */
  export type LabPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter, which LabPermissions to fetch.
     */
    where?: LabPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabPermissions to fetch.
     */
    orderBy?: LabPermissionOrderByWithRelationInput | LabPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabPermissions.
     */
    cursor?: LabPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabPermissions.
     */
    skip?: number
    distinct?: LabPermissionScalarFieldEnum | LabPermissionScalarFieldEnum[]
  }

  /**
   * LabPermission create
   */
  export type LabPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a LabPermission.
     */
    data: XOR<LabPermissionCreateInput, LabPermissionUncheckedCreateInput>
  }

  /**
   * LabPermission createMany
   */
  export type LabPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabPermissions.
     */
    data: LabPermissionCreateManyInput | LabPermissionCreateManyInput[]
  }

  /**
   * LabPermission createManyAndReturn
   */
  export type LabPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many LabPermissions.
     */
    data: LabPermissionCreateManyInput | LabPermissionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabPermission update
   */
  export type LabPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a LabPermission.
     */
    data: XOR<LabPermissionUpdateInput, LabPermissionUncheckedUpdateInput>
    /**
     * Choose, which LabPermission to update.
     */
    where: LabPermissionWhereUniqueInput
  }

  /**
   * LabPermission updateMany
   */
  export type LabPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabPermissions.
     */
    data: XOR<LabPermissionUpdateManyMutationInput, LabPermissionUncheckedUpdateManyInput>
    /**
     * Filter which LabPermissions to update
     */
    where?: LabPermissionWhereInput
    /**
     * Limit how many LabPermissions to update.
     */
    limit?: number
  }

  /**
   * LabPermission updateManyAndReturn
   */
  export type LabPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * The data used to update LabPermissions.
     */
    data: XOR<LabPermissionUpdateManyMutationInput, LabPermissionUncheckedUpdateManyInput>
    /**
     * Filter which LabPermissions to update
     */
    where?: LabPermissionWhereInput
    /**
     * Limit how many LabPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabPermission upsert
   */
  export type LabPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the LabPermission to update in case it exists.
     */
    where: LabPermissionWhereUniqueInput
    /**
     * In case the LabPermission found by the `where` argument doesn't exist, create a new LabPermission with this data.
     */
    create: XOR<LabPermissionCreateInput, LabPermissionUncheckedCreateInput>
    /**
     * In case the LabPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabPermissionUpdateInput, LabPermissionUncheckedUpdateInput>
  }

  /**
   * LabPermission delete
   */
  export type LabPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
    /**
     * Filter which LabPermission to delete.
     */
    where: LabPermissionWhereUniqueInput
  }

  /**
   * LabPermission deleteMany
   */
  export type LabPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabPermissions to delete
     */
    where?: LabPermissionWhereInput
    /**
     * Limit how many LabPermissions to delete.
     */
    limit?: number
  }

  /**
   * LabPermission.privileges
   */
  export type LabPermission$privilegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    where?: PrivilegeWhereInput
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    cursor?: PrivilegeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * LabPermission without action
   */
  export type LabPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabPermission
     */
    select?: LabPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabPermission
     */
    omit?: LabPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabPermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePrivilegeJoin
   */

  export type AggregateRolePrivilegeJoin = {
    _count: RolePrivilegeJoinCountAggregateOutputType | null
    _avg: RolePrivilegeJoinAvgAggregateOutputType | null
    _sum: RolePrivilegeJoinSumAggregateOutputType | null
    _min: RolePrivilegeJoinMinAggregateOutputType | null
    _max: RolePrivilegeJoinMaxAggregateOutputType | null
  }

  export type RolePrivilegeJoinAvgAggregateOutputType = {
    order: number | null
  }

  export type RolePrivilegeJoinSumAggregateOutputType = {
    order: number | null
  }

  export type RolePrivilegeJoinMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    privilegeId: string | null
    order: number | null
  }

  export type RolePrivilegeJoinMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    privilegeId: string | null
    order: number | null
  }

  export type RolePrivilegeJoinCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    roleId: number
    privilegeId: number
    order: number
    _all: number
  }


  export type RolePrivilegeJoinAvgAggregateInputType = {
    order?: true
  }

  export type RolePrivilegeJoinSumAggregateInputType = {
    order?: true
  }

  export type RolePrivilegeJoinMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    roleId?: true
    privilegeId?: true
    order?: true
  }

  export type RolePrivilegeJoinMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    roleId?: true
    privilegeId?: true
    order?: true
  }

  export type RolePrivilegeJoinCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    roleId?: true
    privilegeId?: true
    order?: true
    _all?: true
  }

  export type RolePrivilegeJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePrivilegeJoin to aggregate.
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePrivilegeJoins to fetch.
     */
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePrivilegeJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePrivilegeJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePrivilegeJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePrivilegeJoins
    **/
    _count?: true | RolePrivilegeJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePrivilegeJoinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePrivilegeJoinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePrivilegeJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePrivilegeJoinMaxAggregateInputType
  }

  export type GetRolePrivilegeJoinAggregateType<T extends RolePrivilegeJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePrivilegeJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePrivilegeJoin[P]>
      : GetScalarType<T[P], AggregateRolePrivilegeJoin[P]>
  }




  export type RolePrivilegeJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePrivilegeJoinWhereInput
    orderBy?: RolePrivilegeJoinOrderByWithAggregationInput | RolePrivilegeJoinOrderByWithAggregationInput[]
    by: RolePrivilegeJoinScalarFieldEnum[] | RolePrivilegeJoinScalarFieldEnum
    having?: RolePrivilegeJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePrivilegeJoinCountAggregateInputType | true
    _avg?: RolePrivilegeJoinAvgAggregateInputType
    _sum?: RolePrivilegeJoinSumAggregateInputType
    _min?: RolePrivilegeJoinMinAggregateInputType
    _max?: RolePrivilegeJoinMaxAggregateInputType
  }

  export type RolePrivilegeJoinGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    roleId: string
    privilegeId: string
    order: number | null
    _count: RolePrivilegeJoinCountAggregateOutputType | null
    _avg: RolePrivilegeJoinAvgAggregateOutputType | null
    _sum: RolePrivilegeJoinSumAggregateOutputType | null
    _min: RolePrivilegeJoinMinAggregateOutputType | null
    _max: RolePrivilegeJoinMaxAggregateOutputType | null
  }

  type GetRolePrivilegeJoinGroupByPayload<T extends RolePrivilegeJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePrivilegeJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePrivilegeJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePrivilegeJoinGroupByOutputType[P]>
            : GetScalarType<T[P], RolePrivilegeJoinGroupByOutputType[P]>
        }
      >
    >


  export type RolePrivilegeJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    privilegeId?: boolean
    order?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePrivilegeJoin"]>

  export type RolePrivilegeJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    privilegeId?: boolean
    order?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePrivilegeJoin"]>

  export type RolePrivilegeJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    privilegeId?: boolean
    order?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePrivilegeJoin"]>

  export type RolePrivilegeJoinSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    privilegeId?: boolean
    order?: boolean
  }

  export type RolePrivilegeJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "roleId" | "privilegeId" | "order", ExtArgs["result"]["rolePrivilegeJoin"]>
  export type RolePrivilegeJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }
  export type RolePrivilegeJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }
  export type RolePrivilegeJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
  }

  export type $RolePrivilegeJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePrivilegeJoin"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      privilege: Prisma.$PrivilegePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      roleId: string
      privilegeId: string
      order: number | null
    }, ExtArgs["result"]["rolePrivilegeJoin"]>
    composites: {}
  }

  type RolePrivilegeJoinGetPayload<S extends boolean | null | undefined | RolePrivilegeJoinDefaultArgs> = $Result.GetResult<Prisma.$RolePrivilegeJoinPayload, S>

  type RolePrivilegeJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePrivilegeJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePrivilegeJoinCountAggregateInputType | true
    }

  export interface RolePrivilegeJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePrivilegeJoin'], meta: { name: 'RolePrivilegeJoin' } }
    /**
     * Find zero or one RolePrivilegeJoin that matches the filter.
     * @param {RolePrivilegeJoinFindUniqueArgs} args - Arguments to find a RolePrivilegeJoin
     * @example
     * // Get one RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePrivilegeJoinFindUniqueArgs>(args: SelectSubset<T, RolePrivilegeJoinFindUniqueArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePrivilegeJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePrivilegeJoinFindUniqueOrThrowArgs} args - Arguments to find a RolePrivilegeJoin
     * @example
     * // Get one RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePrivilegeJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePrivilegeJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePrivilegeJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinFindFirstArgs} args - Arguments to find a RolePrivilegeJoin
     * @example
     * // Get one RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePrivilegeJoinFindFirstArgs>(args?: SelectSubset<T, RolePrivilegeJoinFindFirstArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePrivilegeJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinFindFirstOrThrowArgs} args - Arguments to find a RolePrivilegeJoin
     * @example
     * // Get one RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePrivilegeJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePrivilegeJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePrivilegeJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePrivilegeJoins
     * const rolePrivilegeJoins = await prisma.rolePrivilegeJoin.findMany()
     * 
     * // Get first 10 RolePrivilegeJoins
     * const rolePrivilegeJoins = await prisma.rolePrivilegeJoin.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const rolePrivilegeJoinWithCreatedAtOnly = await prisma.rolePrivilegeJoin.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends RolePrivilegeJoinFindManyArgs>(args?: SelectSubset<T, RolePrivilegeJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePrivilegeJoin.
     * @param {RolePrivilegeJoinCreateArgs} args - Arguments to create a RolePrivilegeJoin.
     * @example
     * // Create one RolePrivilegeJoin
     * const RolePrivilegeJoin = await prisma.rolePrivilegeJoin.create({
     *   data: {
     *     // ... data to create a RolePrivilegeJoin
     *   }
     * })
     * 
     */
    create<T extends RolePrivilegeJoinCreateArgs>(args: SelectSubset<T, RolePrivilegeJoinCreateArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePrivilegeJoins.
     * @param {RolePrivilegeJoinCreateManyArgs} args - Arguments to create many RolePrivilegeJoins.
     * @example
     * // Create many RolePrivilegeJoins
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePrivilegeJoinCreateManyArgs>(args?: SelectSubset<T, RolePrivilegeJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePrivilegeJoins and returns the data saved in the database.
     * @param {RolePrivilegeJoinCreateManyAndReturnArgs} args - Arguments to create many RolePrivilegeJoins.
     * @example
     * // Create many RolePrivilegeJoins
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePrivilegeJoins and only return the `createdAt`
     * const rolePrivilegeJoinWithCreatedAtOnly = await prisma.rolePrivilegeJoin.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePrivilegeJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePrivilegeJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePrivilegeJoin.
     * @param {RolePrivilegeJoinDeleteArgs} args - Arguments to delete one RolePrivilegeJoin.
     * @example
     * // Delete one RolePrivilegeJoin
     * const RolePrivilegeJoin = await prisma.rolePrivilegeJoin.delete({
     *   where: {
     *     // ... filter to delete one RolePrivilegeJoin
     *   }
     * })
     * 
     */
    delete<T extends RolePrivilegeJoinDeleteArgs>(args: SelectSubset<T, RolePrivilegeJoinDeleteArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePrivilegeJoin.
     * @param {RolePrivilegeJoinUpdateArgs} args - Arguments to update one RolePrivilegeJoin.
     * @example
     * // Update one RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePrivilegeJoinUpdateArgs>(args: SelectSubset<T, RolePrivilegeJoinUpdateArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePrivilegeJoins.
     * @param {RolePrivilegeJoinDeleteManyArgs} args - Arguments to filter RolePrivilegeJoins to delete.
     * @example
     * // Delete a few RolePrivilegeJoins
     * const { count } = await prisma.rolePrivilegeJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePrivilegeJoinDeleteManyArgs>(args?: SelectSubset<T, RolePrivilegeJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePrivilegeJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePrivilegeJoins
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePrivilegeJoinUpdateManyArgs>(args: SelectSubset<T, RolePrivilegeJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePrivilegeJoins and returns the data updated in the database.
     * @param {RolePrivilegeJoinUpdateManyAndReturnArgs} args - Arguments to update many RolePrivilegeJoins.
     * @example
     * // Update many RolePrivilegeJoins
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePrivilegeJoins and only return the `createdAt`
     * const rolePrivilegeJoinWithCreatedAtOnly = await prisma.rolePrivilegeJoin.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePrivilegeJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePrivilegeJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePrivilegeJoin.
     * @param {RolePrivilegeJoinUpsertArgs} args - Arguments to update or create a RolePrivilegeJoin.
     * @example
     * // Update or create a RolePrivilegeJoin
     * const rolePrivilegeJoin = await prisma.rolePrivilegeJoin.upsert({
     *   create: {
     *     // ... data to create a RolePrivilegeJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePrivilegeJoin we want to update
     *   }
     * })
     */
    upsert<T extends RolePrivilegeJoinUpsertArgs>(args: SelectSubset<T, RolePrivilegeJoinUpsertArgs<ExtArgs>>): Prisma__RolePrivilegeJoinClient<$Result.GetResult<Prisma.$RolePrivilegeJoinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePrivilegeJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinCountArgs} args - Arguments to filter RolePrivilegeJoins to count.
     * @example
     * // Count the number of RolePrivilegeJoins
     * const count = await prisma.rolePrivilegeJoin.count({
     *   where: {
     *     // ... the filter for the RolePrivilegeJoins we want to count
     *   }
     * })
    **/
    count<T extends RolePrivilegeJoinCountArgs>(
      args?: Subset<T, RolePrivilegeJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePrivilegeJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePrivilegeJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePrivilegeJoinAggregateArgs>(args: Subset<T, RolePrivilegeJoinAggregateArgs>): Prisma.PrismaPromise<GetRolePrivilegeJoinAggregateType<T>>

    /**
     * Group by RolePrivilegeJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePrivilegeJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePrivilegeJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePrivilegeJoinGroupByArgs['orderBy'] }
        : { orderBy?: RolePrivilegeJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePrivilegeJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePrivilegeJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePrivilegeJoin model
   */
  readonly fields: RolePrivilegeJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePrivilegeJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePrivilegeJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    privilege<T extends PrivilegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivilegeDefaultArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePrivilegeJoin model
   */
  interface RolePrivilegeJoinFieldRefs {
    readonly createdAt: FieldRef<"RolePrivilegeJoin", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePrivilegeJoin", 'DateTime'>
    readonly roleId: FieldRef<"RolePrivilegeJoin", 'String'>
    readonly privilegeId: FieldRef<"RolePrivilegeJoin", 'String'>
    readonly order: FieldRef<"RolePrivilegeJoin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePrivilegeJoin findUnique
   */
  export type RolePrivilegeJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter, which RolePrivilegeJoin to fetch.
     */
    where: RolePrivilegeJoinWhereUniqueInput
  }

  /**
   * RolePrivilegeJoin findUniqueOrThrow
   */
  export type RolePrivilegeJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter, which RolePrivilegeJoin to fetch.
     */
    where: RolePrivilegeJoinWhereUniqueInput
  }

  /**
   * RolePrivilegeJoin findFirst
   */
  export type RolePrivilegeJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter, which RolePrivilegeJoin to fetch.
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePrivilegeJoins to fetch.
     */
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePrivilegeJoins.
     */
    cursor?: RolePrivilegeJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePrivilegeJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePrivilegeJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePrivilegeJoins.
     */
    distinct?: RolePrivilegeJoinScalarFieldEnum | RolePrivilegeJoinScalarFieldEnum[]
  }

  /**
   * RolePrivilegeJoin findFirstOrThrow
   */
  export type RolePrivilegeJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter, which RolePrivilegeJoin to fetch.
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePrivilegeJoins to fetch.
     */
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePrivilegeJoins.
     */
    cursor?: RolePrivilegeJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePrivilegeJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePrivilegeJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePrivilegeJoins.
     */
    distinct?: RolePrivilegeJoinScalarFieldEnum | RolePrivilegeJoinScalarFieldEnum[]
  }

  /**
   * RolePrivilegeJoin findMany
   */
  export type RolePrivilegeJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter, which RolePrivilegeJoins to fetch.
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePrivilegeJoins to fetch.
     */
    orderBy?: RolePrivilegeJoinOrderByWithRelationInput | RolePrivilegeJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePrivilegeJoins.
     */
    cursor?: RolePrivilegeJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePrivilegeJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePrivilegeJoins.
     */
    skip?: number
    distinct?: RolePrivilegeJoinScalarFieldEnum | RolePrivilegeJoinScalarFieldEnum[]
  }

  /**
   * RolePrivilegeJoin create
   */
  export type RolePrivilegeJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePrivilegeJoin.
     */
    data: XOR<RolePrivilegeJoinCreateInput, RolePrivilegeJoinUncheckedCreateInput>
  }

  /**
   * RolePrivilegeJoin createMany
   */
  export type RolePrivilegeJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePrivilegeJoins.
     */
    data: RolePrivilegeJoinCreateManyInput | RolePrivilegeJoinCreateManyInput[]
  }

  /**
   * RolePrivilegeJoin createManyAndReturn
   */
  export type RolePrivilegeJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * The data used to create many RolePrivilegeJoins.
     */
    data: RolePrivilegeJoinCreateManyInput | RolePrivilegeJoinCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePrivilegeJoin update
   */
  export type RolePrivilegeJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePrivilegeJoin.
     */
    data: XOR<RolePrivilegeJoinUpdateInput, RolePrivilegeJoinUncheckedUpdateInput>
    /**
     * Choose, which RolePrivilegeJoin to update.
     */
    where: RolePrivilegeJoinWhereUniqueInput
  }

  /**
   * RolePrivilegeJoin updateMany
   */
  export type RolePrivilegeJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePrivilegeJoins.
     */
    data: XOR<RolePrivilegeJoinUpdateManyMutationInput, RolePrivilegeJoinUncheckedUpdateManyInput>
    /**
     * Filter which RolePrivilegeJoins to update
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * Limit how many RolePrivilegeJoins to update.
     */
    limit?: number
  }

  /**
   * RolePrivilegeJoin updateManyAndReturn
   */
  export type RolePrivilegeJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * The data used to update RolePrivilegeJoins.
     */
    data: XOR<RolePrivilegeJoinUpdateManyMutationInput, RolePrivilegeJoinUncheckedUpdateManyInput>
    /**
     * Filter which RolePrivilegeJoins to update
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * Limit how many RolePrivilegeJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePrivilegeJoin upsert
   */
  export type RolePrivilegeJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePrivilegeJoin to update in case it exists.
     */
    where: RolePrivilegeJoinWhereUniqueInput
    /**
     * In case the RolePrivilegeJoin found by the `where` argument doesn't exist, create a new RolePrivilegeJoin with this data.
     */
    create: XOR<RolePrivilegeJoinCreateInput, RolePrivilegeJoinUncheckedCreateInput>
    /**
     * In case the RolePrivilegeJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePrivilegeJoinUpdateInput, RolePrivilegeJoinUncheckedUpdateInput>
  }

  /**
   * RolePrivilegeJoin delete
   */
  export type RolePrivilegeJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
    /**
     * Filter which RolePrivilegeJoin to delete.
     */
    where: RolePrivilegeJoinWhereUniqueInput
  }

  /**
   * RolePrivilegeJoin deleteMany
   */
  export type RolePrivilegeJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePrivilegeJoins to delete
     */
    where?: RolePrivilegeJoinWhereInput
    /**
     * Limit how many RolePrivilegeJoins to delete.
     */
    limit?: number
  }

  /**
   * RolePrivilegeJoin without action
   */
  export type RolePrivilegeJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePrivilegeJoin
     */
    select?: RolePrivilegeJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePrivilegeJoin
     */
    omit?: RolePrivilegeJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePrivilegeJoinInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentSumAggregateOutputType = {
    order: number | null
  }

  export type ContentMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    labId: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    published: boolean | null
    previewVideoId: string | null
    order: number | null
  }

  export type ContentMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    labId: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    published: boolean | null
    previewVideoId: string | null
    order: number | null
  }

  export type ContentCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    labId: number
    name: number
    shortDescription: number
    longDescription: number
    thumbnailId: number
    published: number
    previewVideoId: number
    order: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    order?: true
  }

  export type ContentSumAggregateInputType = {
    order?: true
  }

  export type ContentMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    published?: true
    previewVideoId?: true
    order?: true
  }

  export type ContentMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    published?: true
    previewVideoId?: true
    order?: true
  }

  export type ContentCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    labId?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    published?: true
    previewVideoId?: true
    order?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    labId: string
    name: string
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    published: boolean
    previewVideoId: string | null
    order: number
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    published?: boolean
    previewVideoId?: boolean
    order?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    modules?: boolean | Content$modulesArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    published?: boolean
    previewVideoId?: boolean
    order?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    published?: boolean
    previewVideoId?: boolean
    order?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    labId?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    published?: boolean
    previewVideoId?: boolean
    order?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "labId" | "name" | "shortDescription" | "longDescription" | "thumbnailId" | "published" | "previewVideoId" | "order", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    modules?: boolean | Content$modulesArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
  }
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    thumbnail?: boolean | Content$thumbnailArgs<ExtArgs>
    previewVideo?: boolean | Content$previewVideoArgs<ExtArgs>
  }

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      thumbnail: Prisma.$ImagePayload<ExtArgs> | null
      modules: Prisma.$ModulePayload<ExtArgs>[]
      previewVideo: Prisma.$VideoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      labId: string
      name: string
      shortDescription: string | null
      longDescription: string | null
      thumbnailId: string | null
      published: boolean
      previewVideoId: string | null
      order: number
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const contentWithCreatedAtOnly = await prisma.content.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `createdAt`
     * const contentWithCreatedAtOnly = await prisma.content.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `createdAt`
     * const contentWithCreatedAtOnly = await prisma.content.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends Content$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Content$thumbnailArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    modules<T extends Content$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Content$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previewVideo<T extends Content$previewVideoArgs<ExtArgs> = {}>(args?: Subset<T, Content$previewVideoArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */
  interface ContentFieldRefs {
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
    readonly id: FieldRef<"Content", 'String'>
    readonly labId: FieldRef<"Content", 'String'>
    readonly name: FieldRef<"Content", 'String'>
    readonly shortDescription: FieldRef<"Content", 'String'>
    readonly longDescription: FieldRef<"Content", 'String'>
    readonly thumbnailId: FieldRef<"Content", 'String'>
    readonly published: FieldRef<"Content", 'Boolean'>
    readonly previewVideoId: FieldRef<"Content", 'String'>
    readonly order: FieldRef<"Content", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.thumbnail
   */
  export type Content$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * Content.modules
   */
  export type Content$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Content.previewVideo
   */
  export type Content$previewVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    order: number | null
  }

  export type ModuleSumAggregateOutputType = {
    order: number | null
  }

  export type ModuleMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    contentId: string | null
    order: number | null
    published: boolean | null
    category: string | null
    previewVideoId: string | null
  }

  export type ModuleMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    contentId: string | null
    order: number | null
    published: boolean | null
    category: string | null
    previewVideoId: string | null
  }

  export type ModuleCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    name: number
    shortDescription: number
    longDescription: number
    thumbnailId: number
    contentId: number
    order: number
    published: number
    category: number
    previewVideoId: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    order?: true
  }

  export type ModuleSumAggregateInputType = {
    order?: true
  }

  export type ModuleMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    contentId?: true
    order?: true
    published?: true
    category?: true
    previewVideoId?: true
  }

  export type ModuleMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    contentId?: true
    order?: true
    published?: true
    category?: true
    previewVideoId?: true
  }

  export type ModuleCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    contentId?: true
    order?: true
    published?: true
    category?: true
    previewVideoId?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    contentId: string
    order: number
    published: boolean
    category: string | null
    previewVideoId: string | null
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    contentId?: boolean
    order?: boolean
    published?: boolean
    category?: boolean
    previewVideoId?: boolean
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    classes?: boolean | Module$classesArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    contentId?: boolean
    order?: boolean
    published?: boolean
    category?: boolean
    previewVideoId?: boolean
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    contentId?: boolean
    order?: boolean
    published?: boolean
    category?: boolean
    previewVideoId?: boolean
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    contentId?: boolean
    order?: boolean
    published?: boolean
    category?: boolean
    previewVideoId?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "name" | "shortDescription" | "longDescription" | "thumbnailId" | "contentId" | "order" | "published" | "category" | "previewVideoId", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    classes?: boolean | Module$classesArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Module$thumbnailArgs<ExtArgs>
    content?: boolean | ContentDefaultArgs<ExtArgs>
    previewVideo?: boolean | Module$previewVideoArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      thumbnail: Prisma.$ImagePayload<ExtArgs> | null
      content: Prisma.$ContentPayload<ExtArgs>
      classes: Prisma.$ClassPayload<ExtArgs>[]
      previewVideo: Prisma.$VideoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
      shortDescription: string | null
      longDescription: string | null
      thumbnailId: string | null
      contentId: string
      order: number
      published: boolean
      category: string | null
      previewVideoId: string | null
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const moduleWithCreatedAtOnly = await prisma.module.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `createdAt`
     * const moduleWithCreatedAtOnly = await prisma.module.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `createdAt`
     * const moduleWithCreatedAtOnly = await prisma.module.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thumbnail<T extends Module$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Module$thumbnailArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classes<T extends Module$classesArgs<ExtArgs> = {}>(args?: Subset<T, Module$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previewVideo<T extends Module$previewVideoArgs<ExtArgs> = {}>(args?: Subset<T, Module$previewVideoArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
    readonly id: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly shortDescription: FieldRef<"Module", 'String'>
    readonly longDescription: FieldRef<"Module", 'String'>
    readonly thumbnailId: FieldRef<"Module", 'String'>
    readonly contentId: FieldRef<"Module", 'String'>
    readonly order: FieldRef<"Module", 'Int'>
    readonly published: FieldRef<"Module", 'Boolean'>
    readonly category: FieldRef<"Module", 'String'>
    readonly previewVideoId: FieldRef<"Module", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.thumbnail
   */
  export type Module$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * Module.classes
   */
  export type Module$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Module.previewVideo
   */
  export type Module$previewVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    order: number | null
  }

  export type ClassSumAggregateOutputType = {
    order: number | null
  }

  export type ClassMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    moduleId: string | null
    order: number | null
    published: boolean | null
    videoId: string | null
    category: string | null
  }

  export type ClassMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    moduleId: string | null
    order: number | null
    published: boolean | null
    videoId: string | null
    category: string | null
  }

  export type ClassCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    id: number
    name: number
    shortDescription: number
    longDescription: number
    thumbnailId: number
    moduleId: number
    order: number
    published: number
    videoId: number
    category: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    order?: true
  }

  export type ClassSumAggregateInputType = {
    order?: true
  }

  export type ClassMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    moduleId?: true
    order?: true
    published?: true
    videoId?: true
    category?: true
  }

  export type ClassMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    moduleId?: true
    order?: true
    published?: true
    videoId?: true
    category?: true
  }

  export type ClassCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    thumbnailId?: true
    moduleId?: true
    order?: true
    published?: true
    videoId?: true
    category?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    id: string
    name: string
    shortDescription: string | null
    longDescription: string | null
    thumbnailId: string | null
    moduleId: string
    order: number
    published: boolean
    videoId: string | null
    category: string | null
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    moduleId?: boolean
    order?: boolean
    published?: boolean
    videoId?: boolean
    category?: boolean
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    moduleId?: boolean
    order?: boolean
    published?: boolean
    videoId?: boolean
    category?: boolean
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    moduleId?: boolean
    order?: boolean
    published?: boolean
    videoId?: boolean
    category?: boolean
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    thumbnailId?: boolean
    moduleId?: boolean
    order?: boolean
    published?: boolean
    videoId?: boolean
    category?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "id" | "name" | "shortDescription" | "longDescription" | "thumbnailId" | "moduleId" | "order" | "published" | "videoId" | "category", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Class$thumbnailArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    video?: boolean | Class$videoArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      thumbnail: Prisma.$ImagePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs>
      video: Prisma.$VideoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      id: string
      name: string
      shortDescription: string | null
      longDescription: string | null
      thumbnailId: string | null
      moduleId: string
      order: number
      published: boolean
      videoId: string | null
      category: string | null
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const classWithCreatedAtOnly = await prisma.class.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `createdAt`
     * const classWithCreatedAtOnly = await prisma.class.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `createdAt`
     * const classWithCreatedAtOnly = await prisma.class.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thumbnail<T extends Class$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Class$thumbnailArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    video<T extends Class$videoArgs<ExtArgs> = {}>(args?: Subset<T, Class$videoArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly shortDescription: FieldRef<"Class", 'String'>
    readonly longDescription: FieldRef<"Class", 'String'>
    readonly thumbnailId: FieldRef<"Class", 'String'>
    readonly moduleId: FieldRef<"Class", 'String'>
    readonly order: FieldRef<"Class", 'Int'>
    readonly published: FieldRef<"Class", 'Boolean'>
    readonly videoId: FieldRef<"Class", 'String'>
    readonly category: FieldRef<"Class", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.thumbnail
   */
  export type Class$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
  }

  /**
   * Class.video
   */
  export type Class$videoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ImageScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    storageRef: 'storageRef',
    displayName: 'displayName',
    width: 'width',
    height: 'height',
    size: 'size'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    storageRef: 'storageRef',
    displayName: 'displayName',
    durationMillis: 'durationMillis',
    width: 'width',
    height: 'height',
    size: 'size'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const UserScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    email: 'email',
    displayName: 'displayName'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    instagram: 'instagram',
    profilePhotoId: 'profilePhotoId'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const LabScalarFieldEnum: {
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name'
  };

  export type LabScalarFieldEnum = (typeof LabScalarFieldEnum)[keyof typeof LabScalarFieldEnum]


  export const LabProfileScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    labId: 'labId',
    bio: 'bio',
    instagram: 'instagram',
    profilePhotoId: 'profilePhotoId',
    slug: 'slug'
  };

  export type LabProfileScalarFieldEnum = (typeof LabProfileScalarFieldEnum)[keyof typeof LabProfileScalarFieldEnum]


  export const UserLabJoinScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    labId: 'labId'
  };

  export type UserLabJoinScalarFieldEnum = (typeof UserLabJoinScalarFieldEnum)[keyof typeof UserLabJoinScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    labId: 'labId',
    public: 'public',
    priority: 'priority',
    isTeamRole: 'isTeamRole'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserLabRoleScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    labId: 'labId',
    roleId: 'roleId',
    expiresAt: 'expiresAt'
  };

  export type UserLabRoleScalarFieldEnum = (typeof UserLabRoleScalarFieldEnum)[keyof typeof UserLabRoleScalarFieldEnum]


  export const PrivilegeScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name',
    longDescription: 'longDescription',
    shortDescription: 'shortDescription',
    labId: 'labId',
    public: 'public'
  };

  export type PrivilegeScalarFieldEnum = (typeof PrivilegeScalarFieldEnum)[keyof typeof PrivilegeScalarFieldEnum]


  export const LabPermissionScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name',
    labId: 'labId',
    type: 'type'
  };

  export type LabPermissionScalarFieldEnum = (typeof LabPermissionScalarFieldEnum)[keyof typeof LabPermissionScalarFieldEnum]


  export const RolePrivilegeJoinScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roleId: 'roleId',
    privilegeId: 'privilegeId',
    order: 'order'
  };

  export type RolePrivilegeJoinScalarFieldEnum = (typeof RolePrivilegeJoinScalarFieldEnum)[keyof typeof RolePrivilegeJoinScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    labId: 'labId',
    name: 'name',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    thumbnailId: 'thumbnailId',
    published: 'published',
    previewVideoId: 'previewVideoId',
    order: 'order'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    thumbnailId: 'thumbnailId',
    contentId: 'contentId',
    order: 'order',
    published: 'published',
    category: 'category',
    previewVideoId: 'previewVideoId'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    name: 'name',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    thumbnailId: 'thumbnailId',
    moduleId: 'moduleId',
    order: 'order',
    published: 'published',
    videoId: 'videoId',
    category: 'category'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    id?: StringFilter<"Image"> | string
    storageRef?: StringFilter<"Image"> | string
    displayName?: StringNullableFilter<"Image"> | string | null
    width?: IntFilter<"Image"> | number
    height?: IntFilter<"Image"> | number
    size?: BigIntFilter<"Image"> | bigint | number
    userProfiles?: UserProfileListRelationFilter
    labProfiles?: LabProfileListRelationFilter
    contents?: ContentListRelationFilter
    modules?: ModuleListRelationFilter
    classes?: ClassListRelationFilter
  }

  export type ImageOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    userProfiles?: UserProfileOrderByRelationAggregateInput
    labProfiles?: LabProfileOrderByRelationAggregateInput
    contents?: ContentOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    storageRef?: StringFilter<"Image"> | string
    displayName?: StringNullableFilter<"Image"> | string | null
    width?: IntFilter<"Image"> | number
    height?: IntFilter<"Image"> | number
    size?: BigIntFilter<"Image"> | bigint | number
    userProfiles?: UserProfileListRelationFilter
    labProfiles?: LabProfileListRelationFilter
    contents?: ContentListRelationFilter
    modules?: ModuleListRelationFilter
    classes?: ClassListRelationFilter
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    id?: StringWithAggregatesFilter<"Image"> | string
    storageRef?: StringWithAggregatesFilter<"Image"> | string
    displayName?: StringNullableWithAggregatesFilter<"Image"> | string | null
    width?: IntWithAggregatesFilter<"Image"> | number
    height?: IntWithAggregatesFilter<"Image"> | number
    size?: BigIntWithAggregatesFilter<"Image"> | bigint | number
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    id?: StringFilter<"Video"> | string
    storageRef?: StringFilter<"Video"> | string
    displayName?: StringNullableFilter<"Video"> | string | null
    durationMillis?: IntFilter<"Video"> | number
    width?: IntNullableFilter<"Video"> | number | null
    height?: IntNullableFilter<"Video"> | number | null
    size?: BigIntFilter<"Video"> | bigint | number
    previewForContent?: ContentListRelationFilter
    previewForModule?: ModuleListRelationFilter
    classes?: ClassListRelationFilter
  }

  export type VideoOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrderInput | SortOrder
    durationMillis?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    size?: SortOrder
    previewForContent?: ContentOrderByRelationAggregateInput
    previewForModule?: ModuleOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    storageRef?: StringFilter<"Video"> | string
    displayName?: StringNullableFilter<"Video"> | string | null
    durationMillis?: IntFilter<"Video"> | number
    width?: IntNullableFilter<"Video"> | number | null
    height?: IntNullableFilter<"Video"> | number | null
    size?: BigIntFilter<"Video"> | bigint | number
    previewForContent?: ContentListRelationFilter
    previewForModule?: ModuleListRelationFilter
    classes?: ClassListRelationFilter
  }, "id">

  export type VideoOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrderInput | SortOrder
    durationMillis?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    size?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    id?: StringWithAggregatesFilter<"Video"> | string
    storageRef?: StringWithAggregatesFilter<"Video"> | string
    displayName?: StringNullableWithAggregatesFilter<"Video"> | string | null
    durationMillis?: IntWithAggregatesFilter<"Video"> | number
    width?: IntNullableWithAggregatesFilter<"Video"> | number | null
    height?: IntNullableWithAggregatesFilter<"Video"> | number | null
    size?: BigIntWithAggregatesFilter<"Video"> | bigint | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    labs?: UserLabJoinListRelationFilter
    ownedLabs?: LabListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    profile?: UserProfileOrderByWithRelationInput
    labs?: UserLabJoinOrderByRelationAggregateInput
    ownedLabs?: LabOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    displayName?: StringNullableFilter<"User"> | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    labs?: UserLabJoinListRelationFilter
    ownedLabs?: LabListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    bio?: StringNullableFilter<"UserProfile"> | string | null
    instagram?: StringNullableFilter<"UserProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"UserProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profilePhoto?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
  }

  export type UserProfileOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    profilePhotoId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    profilePhoto?: ImageOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    bio?: StringNullableFilter<"UserProfile"> | string | null
    instagram?: StringNullableFilter<"UserProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"UserProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profilePhoto?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    profilePhotoId?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    profilePhotoId?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
  }

  export type LabWhereInput = {
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    published?: BoolFilter<"Lab"> | boolean
    createdAt?: DateTimeFilter<"Lab"> | Date | string
    updatedAt?: DateTimeFilter<"Lab"> | Date | string
    id?: StringFilter<"Lab"> | string
    name?: StringFilter<"Lab"> | string
    profile?: XOR<LabProfileNullableScalarRelationFilter, LabProfileWhereInput> | null
    owners?: UserListRelationFilter
    community?: UserLabJoinListRelationFilter
    roles?: RoleListRelationFilter
    privileges?: PrivilegeListRelationFilter
    content?: ContentListRelationFilter
    permissions?: LabPermissionListRelationFilter
  }

  export type LabOrderByWithRelationInput = {
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    profile?: LabProfileOrderByWithRelationInput
    owners?: UserOrderByRelationAggregateInput
    community?: UserLabJoinOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    privileges?: PrivilegeOrderByRelationAggregateInput
    content?: ContentOrderByRelationAggregateInput
    permissions?: LabPermissionOrderByRelationAggregateInput
  }

  export type LabWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    published?: BoolFilter<"Lab"> | boolean
    createdAt?: DateTimeFilter<"Lab"> | Date | string
    updatedAt?: DateTimeFilter<"Lab"> | Date | string
    name?: StringFilter<"Lab"> | string
    profile?: XOR<LabProfileNullableScalarRelationFilter, LabProfileWhereInput> | null
    owners?: UserListRelationFilter
    community?: UserLabJoinListRelationFilter
    roles?: RoleListRelationFilter
    privileges?: PrivilegeListRelationFilter
    content?: ContentListRelationFilter
    permissions?: LabPermissionListRelationFilter
  }, "id">

  export type LabOrderByWithAggregationInput = {
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: LabCountOrderByAggregateInput
    _max?: LabMaxOrderByAggregateInput
    _min?: LabMinOrderByAggregateInput
  }

  export type LabScalarWhereWithAggregatesInput = {
    AND?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    OR?: LabScalarWhereWithAggregatesInput[]
    NOT?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    published?: BoolWithAggregatesFilter<"Lab"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lab"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lab"> | Date | string
    id?: StringWithAggregatesFilter<"Lab"> | string
    name?: StringWithAggregatesFilter<"Lab"> | string
  }

  export type LabProfileWhereInput = {
    AND?: LabProfileWhereInput | LabProfileWhereInput[]
    OR?: LabProfileWhereInput[]
    NOT?: LabProfileWhereInput | LabProfileWhereInput[]
    createdAt?: DateTimeFilter<"LabProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabProfile"> | Date | string
    id?: StringFilter<"LabProfile"> | string
    labId?: StringFilter<"LabProfile"> | string
    bio?: StringNullableFilter<"LabProfile"> | string | null
    instagram?: StringNullableFilter<"LabProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"LabProfile"> | string | null
    slug?: StringNullableFilter<"LabProfile"> | string | null
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    profilePhoto?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
  }

  export type LabProfileOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    profilePhotoId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    lab?: LabOrderByWithRelationInput
    profilePhoto?: ImageOrderByWithRelationInput
  }

  export type LabProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    labId?: string
    slug?: string
    AND?: LabProfileWhereInput | LabProfileWhereInput[]
    OR?: LabProfileWhereInput[]
    NOT?: LabProfileWhereInput | LabProfileWhereInput[]
    createdAt?: DateTimeFilter<"LabProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabProfile"> | Date | string
    bio?: StringNullableFilter<"LabProfile"> | string | null
    instagram?: StringNullableFilter<"LabProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"LabProfile"> | string | null
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    profilePhoto?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
  }, "id" | "labId" | "slug">

  export type LabProfileOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    bio?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    profilePhotoId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    _count?: LabProfileCountOrderByAggregateInput
    _max?: LabProfileMaxOrderByAggregateInput
    _min?: LabProfileMinOrderByAggregateInput
  }

  export type LabProfileScalarWhereWithAggregatesInput = {
    AND?: LabProfileScalarWhereWithAggregatesInput | LabProfileScalarWhereWithAggregatesInput[]
    OR?: LabProfileScalarWhereWithAggregatesInput[]
    NOT?: LabProfileScalarWhereWithAggregatesInput | LabProfileScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"LabProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabProfile"> | Date | string
    id?: StringWithAggregatesFilter<"LabProfile"> | string
    labId?: StringWithAggregatesFilter<"LabProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"LabProfile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"LabProfile"> | string | null
    profilePhotoId?: StringNullableWithAggregatesFilter<"LabProfile"> | string | null
    slug?: StringNullableWithAggregatesFilter<"LabProfile"> | string | null
  }

  export type UserLabJoinWhereInput = {
    AND?: UserLabJoinWhereInput | UserLabJoinWhereInput[]
    OR?: UserLabJoinWhereInput[]
    NOT?: UserLabJoinWhereInput | UserLabJoinWhereInput[]
    createdAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    userId?: StringFilter<"UserLabJoin"> | string
    labId?: StringFilter<"UserLabJoin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    userLabRoles?: UserLabRoleListRelationFilter
  }

  export type UserLabJoinOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    user?: UserOrderByWithRelationInput
    lab?: LabOrderByWithRelationInput
    userLabRoles?: UserLabRoleOrderByRelationAggregateInput
  }

  export type UserLabJoinWhereUniqueInput = Prisma.AtLeast<{
    userLabJoinId?: UserLabJoinUserLabJoinIdCompoundUniqueInput
    AND?: UserLabJoinWhereInput | UserLabJoinWhereInput[]
    OR?: UserLabJoinWhereInput[]
    NOT?: UserLabJoinWhereInput | UserLabJoinWhereInput[]
    createdAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    userId?: StringFilter<"UserLabJoin"> | string
    labId?: StringFilter<"UserLabJoin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    userLabRoles?: UserLabRoleListRelationFilter
  }, "userLabJoinId">

  export type UserLabJoinOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    _count?: UserLabJoinCountOrderByAggregateInput
    _max?: UserLabJoinMaxOrderByAggregateInput
    _min?: UserLabJoinMinOrderByAggregateInput
  }

  export type UserLabJoinScalarWhereWithAggregatesInput = {
    AND?: UserLabJoinScalarWhereWithAggregatesInput | UserLabJoinScalarWhereWithAggregatesInput[]
    OR?: UserLabJoinScalarWhereWithAggregatesInput[]
    NOT?: UserLabJoinScalarWhereWithAggregatesInput | UserLabJoinScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"UserLabJoin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLabJoin"> | Date | string
    userId?: StringWithAggregatesFilter<"UserLabJoin"> | string
    labId?: StringWithAggregatesFilter<"UserLabJoin"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    shortDescription?: StringNullableFilter<"Role"> | string | null
    longDescription?: StringNullableFilter<"Role"> | string | null
    labId?: StringFilter<"Role"> | string
    public?: BoolFilter<"Role"> | boolean
    priority?: IntFilter<"Role"> | number
    isTeamRole?: BoolFilter<"Role"> | boolean
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    userLabRoles?: UserLabRoleListRelationFilter
    privileges?: RolePrivilegeJoinListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    labId?: SortOrder
    public?: SortOrder
    priority?: SortOrder
    isTeamRole?: SortOrder
    lab?: LabOrderByWithRelationInput
    userLabRoles?: UserLabRoleOrderByRelationAggregateInput
    privileges?: RolePrivilegeJoinOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    labId_id?: RoleLabIdIdCompoundUniqueInput
    name_labId?: RoleNameLabIdCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    name?: StringFilter<"Role"> | string
    shortDescription?: StringNullableFilter<"Role"> | string | null
    longDescription?: StringNullableFilter<"Role"> | string | null
    labId?: StringFilter<"Role"> | string
    public?: BoolFilter<"Role"> | boolean
    priority?: IntFilter<"Role"> | number
    isTeamRole?: BoolFilter<"Role"> | boolean
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    userLabRoles?: UserLabRoleListRelationFilter
    privileges?: RolePrivilegeJoinListRelationFilter
  }, "id" | "labId_id" | "name_labId">

  export type RoleOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    labId?: SortOrder
    public?: SortOrder
    priority?: SortOrder
    isTeamRole?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Role"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"Role"> | string | null
    labId?: StringWithAggregatesFilter<"Role"> | string
    public?: BoolWithAggregatesFilter<"Role"> | boolean
    priority?: IntWithAggregatesFilter<"Role"> | number
    isTeamRole?: BoolWithAggregatesFilter<"Role"> | boolean
  }

  export type UserLabRoleWhereInput = {
    AND?: UserLabRoleWhereInput | UserLabRoleWhereInput[]
    OR?: UserLabRoleWhereInput[]
    NOT?: UserLabRoleWhereInput | UserLabRoleWhereInput[]
    createdAt?: DateTimeFilter<"UserLabRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabRole"> | Date | string
    userId?: StringFilter<"UserLabRole"> | string
    labId?: StringFilter<"UserLabRole"> | string
    roleId?: StringFilter<"UserLabRole"> | string
    expiresAt?: DateTimeNullableFilter<"UserLabRole"> | Date | string | null
    userLabJoin?: XOR<UserLabJoinScalarRelationFilter, UserLabJoinWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserLabRoleOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    roleId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    userLabJoin?: UserLabJoinOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserLabRoleWhereUniqueInput = Prisma.AtLeast<{
    userLabRoleId?: UserLabRoleUserLabRoleIdCompoundUniqueInput
    AND?: UserLabRoleWhereInput | UserLabRoleWhereInput[]
    OR?: UserLabRoleWhereInput[]
    NOT?: UserLabRoleWhereInput | UserLabRoleWhereInput[]
    createdAt?: DateTimeFilter<"UserLabRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabRole"> | Date | string
    userId?: StringFilter<"UserLabRole"> | string
    labId?: StringFilter<"UserLabRole"> | string
    roleId?: StringFilter<"UserLabRole"> | string
    expiresAt?: DateTimeNullableFilter<"UserLabRole"> | Date | string | null
    userLabJoin?: XOR<UserLabJoinScalarRelationFilter, UserLabJoinWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userLabRoleId">

  export type UserLabRoleOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    roleId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: UserLabRoleCountOrderByAggregateInput
    _max?: UserLabRoleMaxOrderByAggregateInput
    _min?: UserLabRoleMinOrderByAggregateInput
  }

  export type UserLabRoleScalarWhereWithAggregatesInput = {
    AND?: UserLabRoleScalarWhereWithAggregatesInput | UserLabRoleScalarWhereWithAggregatesInput[]
    OR?: UserLabRoleScalarWhereWithAggregatesInput[]
    NOT?: UserLabRoleScalarWhereWithAggregatesInput | UserLabRoleScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"UserLabRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLabRole"> | Date | string
    userId?: StringWithAggregatesFilter<"UserLabRole"> | string
    labId?: StringWithAggregatesFilter<"UserLabRole"> | string
    roleId?: StringWithAggregatesFilter<"UserLabRole"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserLabRole"> | Date | string | null
  }

  export type PrivilegeWhereInput = {
    AND?: PrivilegeWhereInput | PrivilegeWhereInput[]
    OR?: PrivilegeWhereInput[]
    NOT?: PrivilegeWhereInput | PrivilegeWhereInput[]
    createdAt?: DateTimeFilter<"Privilege"> | Date | string
    updatedAt?: DateTimeFilter<"Privilege"> | Date | string
    id?: StringFilter<"Privilege"> | string
    name?: StringFilter<"Privilege"> | string
    longDescription?: StringNullableFilter<"Privilege"> | string | null
    shortDescription?: StringFilter<"Privilege"> | string
    labId?: StringFilter<"Privilege"> | string
    public?: BoolFilter<"Privilege"> | boolean
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    roles?: RolePrivilegeJoinListRelationFilter
    labPermissions?: LabPermissionListRelationFilter
  }

  export type PrivilegeOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
    lab?: LabOrderByWithRelationInput
    roles?: RolePrivilegeJoinOrderByRelationAggregateInput
    labPermissions?: LabPermissionOrderByRelationAggregateInput
  }

  export type PrivilegeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_labId?: PrivilegeNameLabIdCompoundUniqueInput
    AND?: PrivilegeWhereInput | PrivilegeWhereInput[]
    OR?: PrivilegeWhereInput[]
    NOT?: PrivilegeWhereInput | PrivilegeWhereInput[]
    createdAt?: DateTimeFilter<"Privilege"> | Date | string
    updatedAt?: DateTimeFilter<"Privilege"> | Date | string
    name?: StringFilter<"Privilege"> | string
    longDescription?: StringNullableFilter<"Privilege"> | string | null
    shortDescription?: StringFilter<"Privilege"> | string
    labId?: StringFilter<"Privilege"> | string
    public?: BoolFilter<"Privilege"> | boolean
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    roles?: RolePrivilegeJoinListRelationFilter
    labPermissions?: LabPermissionListRelationFilter
  }, "id" | "name_labId">

  export type PrivilegeOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    shortDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
    _count?: PrivilegeCountOrderByAggregateInput
    _max?: PrivilegeMaxOrderByAggregateInput
    _min?: PrivilegeMinOrderByAggregateInput
  }

  export type PrivilegeScalarWhereWithAggregatesInput = {
    AND?: PrivilegeScalarWhereWithAggregatesInput | PrivilegeScalarWhereWithAggregatesInput[]
    OR?: PrivilegeScalarWhereWithAggregatesInput[]
    NOT?: PrivilegeScalarWhereWithAggregatesInput | PrivilegeScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Privilege"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Privilege"> | Date | string
    id?: StringWithAggregatesFilter<"Privilege"> | string
    name?: StringWithAggregatesFilter<"Privilege"> | string
    longDescription?: StringNullableWithAggregatesFilter<"Privilege"> | string | null
    shortDescription?: StringWithAggregatesFilter<"Privilege"> | string
    labId?: StringWithAggregatesFilter<"Privilege"> | string
    public?: BoolWithAggregatesFilter<"Privilege"> | boolean
  }

  export type LabPermissionWhereInput = {
    AND?: LabPermissionWhereInput | LabPermissionWhereInput[]
    OR?: LabPermissionWhereInput[]
    NOT?: LabPermissionWhereInput | LabPermissionWhereInput[]
    createdAt?: DateTimeFilter<"LabPermission"> | Date | string
    updatedAt?: DateTimeFilter<"LabPermission"> | Date | string
    id?: StringFilter<"LabPermission"> | string
    name?: StringFilter<"LabPermission"> | string
    labId?: StringFilter<"LabPermission"> | string
    type?: StringFilter<"LabPermission"> | string
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    privileges?: PrivilegeListRelationFilter
  }

  export type LabPermissionOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    labId?: SortOrder
    type?: SortOrder
    lab?: LabOrderByWithRelationInput
    privileges?: PrivilegeOrderByRelationAggregateInput
  }

  export type LabPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_labId?: LabPermissionNameLabIdCompoundUniqueInput
    AND?: LabPermissionWhereInput | LabPermissionWhereInput[]
    OR?: LabPermissionWhereInput[]
    NOT?: LabPermissionWhereInput | LabPermissionWhereInput[]
    createdAt?: DateTimeFilter<"LabPermission"> | Date | string
    updatedAt?: DateTimeFilter<"LabPermission"> | Date | string
    name?: StringFilter<"LabPermission"> | string
    labId?: StringFilter<"LabPermission"> | string
    type?: StringFilter<"LabPermission"> | string
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    privileges?: PrivilegeListRelationFilter
  }, "id" | "name_labId">

  export type LabPermissionOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    labId?: SortOrder
    type?: SortOrder
    _count?: LabPermissionCountOrderByAggregateInput
    _max?: LabPermissionMaxOrderByAggregateInput
    _min?: LabPermissionMinOrderByAggregateInput
  }

  export type LabPermissionScalarWhereWithAggregatesInput = {
    AND?: LabPermissionScalarWhereWithAggregatesInput | LabPermissionScalarWhereWithAggregatesInput[]
    OR?: LabPermissionScalarWhereWithAggregatesInput[]
    NOT?: LabPermissionScalarWhereWithAggregatesInput | LabPermissionScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"LabPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabPermission"> | Date | string
    id?: StringWithAggregatesFilter<"LabPermission"> | string
    name?: StringWithAggregatesFilter<"LabPermission"> | string
    labId?: StringWithAggregatesFilter<"LabPermission"> | string
    type?: StringWithAggregatesFilter<"LabPermission"> | string
  }

  export type RolePrivilegeJoinWhereInput = {
    AND?: RolePrivilegeJoinWhereInput | RolePrivilegeJoinWhereInput[]
    OR?: RolePrivilegeJoinWhereInput[]
    NOT?: RolePrivilegeJoinWhereInput | RolePrivilegeJoinWhereInput[]
    createdAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    updatedAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    roleId?: StringFilter<"RolePrivilegeJoin"> | string
    privilegeId?: StringFilter<"RolePrivilegeJoin"> | string
    order?: IntNullableFilter<"RolePrivilegeJoin"> | number | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    privilege?: XOR<PrivilegeScalarRelationFilter, PrivilegeWhereInput>
  }

  export type RolePrivilegeJoinOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    privilegeId?: SortOrder
    order?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    privilege?: PrivilegeOrderByWithRelationInput
  }

  export type RolePrivilegeJoinWhereUniqueInput = Prisma.AtLeast<{
    rolePrivilegeJoinId?: RolePrivilegeJoinRolePrivilegeJoinIdCompoundUniqueInput
    AND?: RolePrivilegeJoinWhereInput | RolePrivilegeJoinWhereInput[]
    OR?: RolePrivilegeJoinWhereInput[]
    NOT?: RolePrivilegeJoinWhereInput | RolePrivilegeJoinWhereInput[]
    createdAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    updatedAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    roleId?: StringFilter<"RolePrivilegeJoin"> | string
    privilegeId?: StringFilter<"RolePrivilegeJoin"> | string
    order?: IntNullableFilter<"RolePrivilegeJoin"> | number | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    privilege?: XOR<PrivilegeScalarRelationFilter, PrivilegeWhereInput>
  }, "rolePrivilegeJoinId">

  export type RolePrivilegeJoinOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    privilegeId?: SortOrder
    order?: SortOrderInput | SortOrder
    _count?: RolePrivilegeJoinCountOrderByAggregateInput
    _avg?: RolePrivilegeJoinAvgOrderByAggregateInput
    _max?: RolePrivilegeJoinMaxOrderByAggregateInput
    _min?: RolePrivilegeJoinMinOrderByAggregateInput
    _sum?: RolePrivilegeJoinSumOrderByAggregateInput
  }

  export type RolePrivilegeJoinScalarWhereWithAggregatesInput = {
    AND?: RolePrivilegeJoinScalarWhereWithAggregatesInput | RolePrivilegeJoinScalarWhereWithAggregatesInput[]
    OR?: RolePrivilegeJoinScalarWhereWithAggregatesInput[]
    NOT?: RolePrivilegeJoinScalarWhereWithAggregatesInput | RolePrivilegeJoinScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"RolePrivilegeJoin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePrivilegeJoin"> | Date | string
    roleId?: StringWithAggregatesFilter<"RolePrivilegeJoin"> | string
    privilegeId?: StringWithAggregatesFilter<"RolePrivilegeJoin"> | string
    order?: IntNullableWithAggregatesFilter<"RolePrivilegeJoin"> | number | null
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    id?: StringFilter<"Content"> | string
    labId?: StringFilter<"Content"> | string
    name?: StringFilter<"Content"> | string
    shortDescription?: StringNullableFilter<"Content"> | string | null
    longDescription?: StringNullableFilter<"Content"> | string | null
    thumbnailId?: StringNullableFilter<"Content"> | string | null
    published?: BoolFilter<"Content"> | boolean
    previewVideoId?: StringNullableFilter<"Content"> | string | null
    order?: IntFilter<"Content"> | number
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    modules?: ModuleListRelationFilter
    previewVideo?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }

  export type ContentOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    published?: SortOrder
    previewVideoId?: SortOrderInput | SortOrder
    order?: SortOrder
    lab?: LabOrderByWithRelationInput
    thumbnail?: ImageOrderByWithRelationInput
    modules?: ModuleOrderByRelationAggregateInput
    previewVideo?: VideoOrderByWithRelationInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    labId_order?: ContentLabIdOrderCompoundUniqueInput
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    labId?: StringFilter<"Content"> | string
    name?: StringFilter<"Content"> | string
    shortDescription?: StringNullableFilter<"Content"> | string | null
    longDescription?: StringNullableFilter<"Content"> | string | null
    thumbnailId?: StringNullableFilter<"Content"> | string | null
    published?: BoolFilter<"Content"> | boolean
    previewVideoId?: StringNullableFilter<"Content"> | string | null
    order?: IntFilter<"Content"> | number
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    modules?: ModuleListRelationFilter
    previewVideo?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }, "id" | "labId_order">

  export type ContentOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    published?: SortOrder
    previewVideoId?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    id?: StringWithAggregatesFilter<"Content"> | string
    labId?: StringWithAggregatesFilter<"Content"> | string
    name?: StringWithAggregatesFilter<"Content"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Content"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"Content"> | string | null
    thumbnailId?: StringNullableWithAggregatesFilter<"Content"> | string | null
    published?: BoolWithAggregatesFilter<"Content"> | boolean
    previewVideoId?: StringNullableWithAggregatesFilter<"Content"> | string | null
    order?: IntWithAggregatesFilter<"Content"> | number
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    shortDescription?: StringNullableFilter<"Module"> | string | null
    longDescription?: StringNullableFilter<"Module"> | string | null
    thumbnailId?: StringNullableFilter<"Module"> | string | null
    contentId?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    published?: BoolFilter<"Module"> | boolean
    category?: StringNullableFilter<"Module"> | string | null
    previewVideoId?: StringNullableFilter<"Module"> | string | null
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    classes?: ClassListRelationFilter
    previewVideo?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }

  export type ModuleOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    contentId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    category?: SortOrderInput | SortOrder
    previewVideoId?: SortOrderInput | SortOrder
    thumbnail?: ImageOrderByWithRelationInput
    content?: ContentOrderByWithRelationInput
    classes?: ClassOrderByRelationAggregateInput
    previewVideo?: VideoOrderByWithRelationInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_category_contentId?: ModuleOrderCategoryContentIdCompoundUniqueInput
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    name?: StringFilter<"Module"> | string
    shortDescription?: StringNullableFilter<"Module"> | string | null
    longDescription?: StringNullableFilter<"Module"> | string | null
    thumbnailId?: StringNullableFilter<"Module"> | string | null
    contentId?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    published?: BoolFilter<"Module"> | boolean
    category?: StringNullableFilter<"Module"> | string | null
    previewVideoId?: StringNullableFilter<"Module"> | string | null
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    classes?: ClassListRelationFilter
    previewVideo?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }, "id" | "order_category_contentId">

  export type ModuleOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    contentId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    category?: SortOrderInput | SortOrder
    previewVideoId?: SortOrderInput | SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    id?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Module"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"Module"> | string | null
    thumbnailId?: StringNullableWithAggregatesFilter<"Module"> | string | null
    contentId?: StringWithAggregatesFilter<"Module"> | string
    order?: IntWithAggregatesFilter<"Module"> | number
    published?: BoolWithAggregatesFilter<"Module"> | boolean
    category?: StringNullableWithAggregatesFilter<"Module"> | string | null
    previewVideoId?: StringNullableWithAggregatesFilter<"Module"> | string | null
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    shortDescription?: StringNullableFilter<"Class"> | string | null
    longDescription?: StringNullableFilter<"Class"> | string | null
    thumbnailId?: StringNullableFilter<"Class"> | string | null
    moduleId?: StringFilter<"Class"> | string
    order?: IntFilter<"Class"> | number
    published?: BoolFilter<"Class"> | boolean
    videoId?: StringNullableFilter<"Class"> | string | null
    category?: StringNullableFilter<"Class"> | string | null
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    video?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }

  export type ClassOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    videoId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    thumbnail?: ImageOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    video?: VideoOrderByWithRelationInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_category_moduleId?: ClassOrderCategoryModuleIdCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    name?: StringFilter<"Class"> | string
    shortDescription?: StringNullableFilter<"Class"> | string | null
    longDescription?: StringNullableFilter<"Class"> | string | null
    thumbnailId?: StringNullableFilter<"Class"> | string | null
    moduleId?: StringFilter<"Class"> | string
    order?: IntFilter<"Class"> | number
    published?: BoolFilter<"Class"> | boolean
    videoId?: StringNullableFilter<"Class"> | string | null
    category?: StringNullableFilter<"Class"> | string | null
    thumbnail?: XOR<ImageNullableScalarRelationFilter, ImageWhereInput> | null
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    video?: XOR<VideoNullableScalarRelationFilter, VideoWhereInput> | null
  }, "id" | "order_category_moduleId">

  export type ClassOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    videoId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Class"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"Class"> | string | null
    thumbnailId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    moduleId?: StringWithAggregatesFilter<"Class"> | string
    order?: IntWithAggregatesFilter<"Class"> | number
    published?: BoolWithAggregatesFilter<"Class"> | boolean
    videoId?: StringNullableWithAggregatesFilter<"Class"> | string | null
    category?: StringNullableWithAggregatesFilter<"Class"> | string | null
  }

  export type ImageCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentCreateNestedManyWithoutThumbnailInput
    modules?: ModuleCreateNestedManyWithoutThumbnailInput
    classes?: ClassCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentUncheckedCreateNestedManyWithoutThumbnailInput
    modules?: ModuleUncheckedCreateNestedManyWithoutThumbnailInput
    classes?: ClassUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUncheckedUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
  }

  export type ImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ImageUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VideoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentCreateNestedManyWithoutPreviewVideoInput
    previewForModule?: ModuleCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentUncheckedCreateNestedManyWithoutPreviewVideoInput
    previewForModule?: ModuleUncheckedCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUpdateManyWithoutPreviewVideoNestedInput
    previewForModule?: ModuleUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUncheckedUpdateManyWithoutPreviewVideoNestedInput
    previewForModule?: ModuleUncheckedUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
  }

  export type VideoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VideoUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    labs?: UserLabJoinCreateNestedManyWithoutUserInput
    ownedLabs?: LabCreateNestedManyWithoutOwnersInput
  }

  export type UserUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    labs?: UserLabJoinUncheckedCreateNestedManyWithoutUserInput
    ownedLabs?: LabUncheckedCreateNestedManyWithoutOwnersInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    labs?: UserLabJoinUpdateManyWithoutUserNestedInput
    ownedLabs?: LabUpdateManyWithoutOwnersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    labs?: UserLabJoinUncheckedUpdateManyWithoutUserNestedInput
    ownedLabs?: LabUncheckedUpdateManyWithoutOwnersNestedInput
  }

  export type UserCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    user: UserCreateNestedOneWithoutProfileInput
    profilePhoto?: ImageCreateNestedOneWithoutUserProfilesInput
  }

  export type UserProfileUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    userId: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
  }

  export type UserProfileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    profilePhoto?: ImageUpdateOneWithoutUserProfilesNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    userId: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
  }

  export type UserProfileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabCreateInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabUpdateInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabCreateManyInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
  }

  export type LabUpdateManyMutationInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LabUncheckedUpdateManyInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LabProfileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    slug?: string | null
    lab: LabCreateNestedOneWithoutProfileInput
    profilePhoto?: ImageCreateNestedOneWithoutLabProfilesInput
  }

  export type LabProfileUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
    slug?: string | null
  }

  export type LabProfileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    lab?: LabUpdateOneRequiredWithoutProfileNestedInput
    profilePhoto?: ImageUpdateOneWithoutLabProfilesNestedInput
  }

  export type LabProfileUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabProfileCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
    slug?: string | null
  }

  export type LabProfileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabProfileUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLabJoinCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLabsInput
    lab: LabCreateNestedOneWithoutCommunityInput
    userLabRoles?: UserLabRoleCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    labId: string
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabsNestedInput
    lab?: LabUpdateOneRequiredWithoutCommunityNestedInput
    userLabRoles?: UserLabRoleUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    labId: string
  }

  export type UserLabJoinUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLabJoinUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    lab: LabCreateNestedOneWithoutRolesInput
    userLabRoles?: UserLabRoleCreateNestedManyWithoutRoleInput
    privileges?: RolePrivilegeJoinCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    labId: string
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutRoleInput
    privileges?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutRolesNestedInput
    userLabRoles?: UserLabRoleUpdateManyWithoutRoleNestedInput
    privileges?: RolePrivilegeJoinUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutRoleNestedInput
    privileges?: RolePrivilegeJoinUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    labId: string
    public?: boolean
    priority?: number
    isTeamRole?: boolean
  }

  export type RoleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLabRoleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    userLabJoin: UserLabJoinCreateNestedOneWithoutUserLabRolesInput
    role: RoleCreateNestedOneWithoutUserLabRolesInput
  }

  export type UserLabRoleUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    labId: string
    roleId: string
    expiresAt?: Date | string | null
  }

  export type UserLabRoleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userLabJoin?: UserLabJoinUpdateOneRequiredWithoutUserLabRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserLabRolesNestedInput
  }

  export type UserLabRoleUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLabRoleCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    labId: string
    roleId: string
    expiresAt?: Date | string | null
  }

  export type UserLabRoleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLabRoleUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrivilegeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
    lab: LabCreateNestedOneWithoutPrivilegesInput
    roles?: RolePrivilegeJoinCreateNestedManyWithoutPrivilegeInput
    labPermissions?: LabPermissionCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    labId: string
    public?: boolean
    roles?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutPrivilegeInput
    labPermissions?: LabPermissionUncheckedCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutPrivilegesNestedInput
    roles?: RolePrivilegeJoinUpdateManyWithoutPrivilegeNestedInput
    labPermissions?: LabPermissionUpdateManyWithoutPrivilegesNestedInput
  }

  export type PrivilegeUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    roles?: RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeNestedInput
    labPermissions?: LabPermissionUncheckedUpdateManyWithoutPrivilegesNestedInput
  }

  export type PrivilegeCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    labId: string
    public?: boolean
  }

  export type PrivilegeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrivilegeUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabPermissionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    type: string
    lab: LabCreateNestedOneWithoutPermissionsInput
    privileges?: PrivilegeCreateNestedManyWithoutLabPermissionsInput
  }

  export type LabPermissionUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    labId: string
    type: string
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabPermissionsInput
  }

  export type LabPermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lab?: LabUpdateOneRequiredWithoutPermissionsNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabPermissionsNestedInput
  }

  export type LabPermissionUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabPermissionsNestedInput
  }

  export type LabPermissionCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    labId: string
    type: string
  }

  export type LabPermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LabPermissionUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RolePrivilegeJoinCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    role: RoleCreateNestedOneWithoutPrivilegesInput
    privilege: PrivilegeCreateNestedOneWithoutRolesInput
  }

  export type RolePrivilegeJoinUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    privilegeId: string
    order?: number | null
  }

  export type RolePrivilegeJoinUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutPrivilegesNestedInput
    privilege?: PrivilegeUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePrivilegeJoinUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePrivilegeJoinCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    privilegeId: string
    order?: number | null
  }

  export type RolePrivilegeJoinUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePrivilegeJoinUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    order: number
    lab: LabCreateNestedOneWithoutContentInput
    thumbnail?: ImageCreateNestedOneWithoutContentsInput
    modules?: ModuleCreateNestedManyWithoutContentInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForContentInput
  }

  export type ContentUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
    modules?: ModuleUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutContentNestedInput
    thumbnail?: ImageUpdateOneWithoutContentsNestedInput
    modules?: ModuleUpdateManyWithoutContentNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    modules?: ModuleUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
  }

  export type ContentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutModulesInput
    content: ContentCreateNestedOneWithoutModulesInput
    classes?: ClassCreateNestedManyWithoutModuleInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutModulesNestedInput
    content?: ContentUpdateOneRequiredWithoutModulesNestedInput
    classes?: ClassUpdateManyWithoutModuleNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
  }

  export type ModuleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutClassesInput
    module: ModuleCreateNestedOneWithoutClassesInput
    video?: VideoCreateNestedOneWithoutClassesInput
  }

  export type ClassUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    moduleId: string
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type ClassUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutClassesNestedInput
    module?: ModuleUpdateOneRequiredWithoutClassesNestedInput
    video?: VideoUpdateOneWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    moduleId: string
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type ClassUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UserProfileListRelationFilter = {
    every?: UserProfileWhereInput
    some?: UserProfileWhereInput
    none?: UserProfileWhereInput
  }

  export type LabProfileListRelationFilter = {
    every?: LabProfileWhereInput
    some?: LabProfileWhereInput
    none?: LabProfileWhereInput
  }

  export type ContentListRelationFilter = {
    every?: ContentWhereInput
    some?: ContentWhereInput
    none?: ContentWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VideoCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    durationMillis?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    durationMillis?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    durationMillis?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    storageRef?: SortOrder
    displayName?: SortOrder
    durationMillis?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    durationMillis?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserLabJoinListRelationFilter = {
    every?: UserLabJoinWhereInput
    some?: UserLabJoinWhereInput
    none?: UserLabJoinWhereInput
  }

  export type LabListRelationFilter = {
    every?: LabWhereInput
    some?: LabWhereInput
    none?: LabWhereInput
  }

  export type UserLabJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ImageNullableScalarRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type UserProfileCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LabProfileNullableScalarRelationFilter = {
    is?: LabProfileWhereInput | null
    isNot?: LabProfileWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type PrivilegeListRelationFilter = {
    every?: PrivilegeWhereInput
    some?: PrivilegeWhereInput
    none?: PrivilegeWhereInput
  }

  export type LabPermissionListRelationFilter = {
    every?: LabPermissionWhereInput
    some?: LabPermissionWhereInput
    none?: LabPermissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivilegeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabCountOrderByAggregateInput = {
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type LabMaxOrderByAggregateInput = {
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type LabMinOrderByAggregateInput = {
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LabScalarRelationFilter = {
    is?: LabWhereInput
    isNot?: LabWhereInput
  }

  export type LabProfileCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
    slug?: SortOrder
  }

  export type LabProfileMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
    slug?: SortOrder
  }

  export type LabProfileMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    bio?: SortOrder
    instagram?: SortOrder
    profilePhotoId?: SortOrder
    slug?: SortOrder
  }

  export type UserLabRoleListRelationFilter = {
    every?: UserLabRoleWhereInput
    some?: UserLabRoleWhereInput
    none?: UserLabRoleWhereInput
  }

  export type UserLabRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLabJoinUserLabJoinIdCompoundUniqueInput = {
    userId: string
    labId: string
  }

  export type UserLabJoinCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
  }

  export type UserLabJoinMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
  }

  export type UserLabJoinMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
  }

  export type RolePrivilegeJoinListRelationFilter = {
    every?: RolePrivilegeJoinWhereInput
    some?: RolePrivilegeJoinWhereInput
    none?: RolePrivilegeJoinWhereInput
  }

  export type RolePrivilegeJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleLabIdIdCompoundUniqueInput = {
    labId: string
    id: string
  }

  export type RoleNameLabIdCompoundUniqueInput = {
    name: string
    labId: string
  }

  export type RoleCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
    priority?: SortOrder
    isTeamRole?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
    priority?: SortOrder
    isTeamRole?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
    priority?: SortOrder
    isTeamRole?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserLabJoinScalarRelationFilter = {
    is?: UserLabJoinWhereInput
    isNot?: UserLabJoinWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserLabRoleUserLabRoleIdCompoundUniqueInput = {
    userId: string
    labId: string
    roleId: string
  }

  export type UserLabRoleCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    roleId?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserLabRoleMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    roleId?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserLabRoleMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    labId?: SortOrder
    roleId?: SortOrder
    expiresAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PrivilegeNameLabIdCompoundUniqueInput = {
    name: string
    labId: string
  }

  export type PrivilegeCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    longDescription?: SortOrder
    shortDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
  }

  export type PrivilegeMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    longDescription?: SortOrder
    shortDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
  }

  export type PrivilegeMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    longDescription?: SortOrder
    shortDescription?: SortOrder
    labId?: SortOrder
    public?: SortOrder
  }

  export type LabPermissionNameLabIdCompoundUniqueInput = {
    name: string
    labId: string
  }

  export type LabPermissionCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    labId?: SortOrder
    type?: SortOrder
  }

  export type LabPermissionMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    labId?: SortOrder
    type?: SortOrder
  }

  export type LabPermissionMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    labId?: SortOrder
    type?: SortOrder
  }

  export type PrivilegeScalarRelationFilter = {
    is?: PrivilegeWhereInput
    isNot?: PrivilegeWhereInput
  }

  export type RolePrivilegeJoinRolePrivilegeJoinIdCompoundUniqueInput = {
    roleId: string
    privilegeId: string
  }

  export type RolePrivilegeJoinCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    privilegeId?: SortOrder
    order?: SortOrder
  }

  export type RolePrivilegeJoinAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RolePrivilegeJoinMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    privilegeId?: SortOrder
    order?: SortOrder
  }

  export type RolePrivilegeJoinMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    privilegeId?: SortOrder
    order?: SortOrder
  }

  export type RolePrivilegeJoinSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type VideoNullableScalarRelationFilter = {
    is?: VideoWhereInput | null
    isNot?: VideoWhereInput | null
  }

  export type ContentLabIdOrderCompoundUniqueInput = {
    labId: string
    order: number
  }

  export type ContentCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    published?: SortOrder
    previewVideoId?: SortOrder
    order?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    published?: SortOrder
    previewVideoId?: SortOrder
    order?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    labId?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    published?: SortOrder
    previewVideoId?: SortOrder
    order?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type ModuleOrderCategoryContentIdCompoundUniqueInput = {
    order: number
    category: string
    contentId: string
  }

  export type ModuleCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    contentId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    category?: SortOrder
    previewVideoId?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    contentId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    category?: SortOrder
    previewVideoId?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    contentId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    category?: SortOrder
    previewVideoId?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ClassOrderCategoryModuleIdCompoundUniqueInput = {
    order: number
    category: string
    moduleId: string
  }

  export type ClassCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    thumbnailId?: SortOrder
    moduleId?: SortOrder
    order?: SortOrder
    published?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type UserProfileCreateNestedManyWithoutProfilePhotoInput = {
    create?: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput> | UserProfileCreateWithoutProfilePhotoInput[] | UserProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutProfilePhotoInput | UserProfileCreateOrConnectWithoutProfilePhotoInput[]
    createMany?: UserProfileCreateManyProfilePhotoInputEnvelope
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type LabProfileCreateNestedManyWithoutProfilePhotoInput = {
    create?: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput> | LabProfileCreateWithoutProfilePhotoInput[] | LabProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: LabProfileCreateOrConnectWithoutProfilePhotoInput | LabProfileCreateOrConnectWithoutProfilePhotoInput[]
    createMany?: LabProfileCreateManyProfilePhotoInputEnvelope
    connect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput> | ContentCreateWithoutThumbnailInput[] | ContentUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutThumbnailInput | ContentCreateOrConnectWithoutThumbnailInput[]
    createMany?: ContentCreateManyThumbnailInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput> | ModuleCreateWithoutThumbnailInput[] | ModuleUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutThumbnailInput | ModuleCreateOrConnectWithoutThumbnailInput[]
    createMany?: ModuleCreateManyThumbnailInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput> | ClassCreateWithoutThumbnailInput[] | ClassUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutThumbnailInput | ClassCreateOrConnectWithoutThumbnailInput[]
    createMany?: ClassCreateManyThumbnailInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput = {
    create?: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput> | UserProfileCreateWithoutProfilePhotoInput[] | UserProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutProfilePhotoInput | UserProfileCreateOrConnectWithoutProfilePhotoInput[]
    createMany?: UserProfileCreateManyProfilePhotoInputEnvelope
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput = {
    create?: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput> | LabProfileCreateWithoutProfilePhotoInput[] | LabProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: LabProfileCreateOrConnectWithoutProfilePhotoInput | LabProfileCreateOrConnectWithoutProfilePhotoInput[]
    createMany?: LabProfileCreateManyProfilePhotoInputEnvelope
    connect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput> | ContentCreateWithoutThumbnailInput[] | ContentUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutThumbnailInput | ContentCreateOrConnectWithoutThumbnailInput[]
    createMany?: ContentCreateManyThumbnailInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput> | ModuleCreateWithoutThumbnailInput[] | ModuleUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutThumbnailInput | ModuleCreateOrConnectWithoutThumbnailInput[]
    createMany?: ModuleCreateManyThumbnailInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput> | ClassCreateWithoutThumbnailInput[] | ClassUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutThumbnailInput | ClassCreateOrConnectWithoutThumbnailInput[]
    createMany?: ClassCreateManyThumbnailInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserProfileUpdateManyWithoutProfilePhotoNestedInput = {
    create?: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput> | UserProfileCreateWithoutProfilePhotoInput[] | UserProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutProfilePhotoInput | UserProfileCreateOrConnectWithoutProfilePhotoInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutProfilePhotoInput | UserProfileUpsertWithWhereUniqueWithoutProfilePhotoInput[]
    createMany?: UserProfileCreateManyProfilePhotoInputEnvelope
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutProfilePhotoInput | UserProfileUpdateWithWhereUniqueWithoutProfilePhotoInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutProfilePhotoInput | UserProfileUpdateManyWithWhereWithoutProfilePhotoInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type LabProfileUpdateManyWithoutProfilePhotoNestedInput = {
    create?: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput> | LabProfileCreateWithoutProfilePhotoInput[] | LabProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: LabProfileCreateOrConnectWithoutProfilePhotoInput | LabProfileCreateOrConnectWithoutProfilePhotoInput[]
    upsert?: LabProfileUpsertWithWhereUniqueWithoutProfilePhotoInput | LabProfileUpsertWithWhereUniqueWithoutProfilePhotoInput[]
    createMany?: LabProfileCreateManyProfilePhotoInputEnvelope
    set?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    disconnect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    delete?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    connect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    update?: LabProfileUpdateWithWhereUniqueWithoutProfilePhotoInput | LabProfileUpdateWithWhereUniqueWithoutProfilePhotoInput[]
    updateMany?: LabProfileUpdateManyWithWhereWithoutProfilePhotoInput | LabProfileUpdateManyWithWhereWithoutProfilePhotoInput[]
    deleteMany?: LabProfileScalarWhereInput | LabProfileScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput> | ContentCreateWithoutThumbnailInput[] | ContentUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutThumbnailInput | ContentCreateOrConnectWithoutThumbnailInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutThumbnailInput | ContentUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ContentCreateManyThumbnailInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutThumbnailInput | ContentUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutThumbnailInput | ContentUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput> | ModuleCreateWithoutThumbnailInput[] | ModuleUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutThumbnailInput | ModuleCreateOrConnectWithoutThumbnailInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutThumbnailInput | ModuleUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ModuleCreateManyThumbnailInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutThumbnailInput | ModuleUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutThumbnailInput | ModuleUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput> | ClassCreateWithoutThumbnailInput[] | ClassUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutThumbnailInput | ClassCreateOrConnectWithoutThumbnailInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutThumbnailInput | ClassUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ClassCreateManyThumbnailInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutThumbnailInput | ClassUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutThumbnailInput | ClassUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput = {
    create?: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput> | UserProfileCreateWithoutProfilePhotoInput[] | UserProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutProfilePhotoInput | UserProfileCreateOrConnectWithoutProfilePhotoInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutProfilePhotoInput | UserProfileUpsertWithWhereUniqueWithoutProfilePhotoInput[]
    createMany?: UserProfileCreateManyProfilePhotoInputEnvelope
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutProfilePhotoInput | UserProfileUpdateWithWhereUniqueWithoutProfilePhotoInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutProfilePhotoInput | UserProfileUpdateManyWithWhereWithoutProfilePhotoInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput = {
    create?: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput> | LabProfileCreateWithoutProfilePhotoInput[] | LabProfileUncheckedCreateWithoutProfilePhotoInput[]
    connectOrCreate?: LabProfileCreateOrConnectWithoutProfilePhotoInput | LabProfileCreateOrConnectWithoutProfilePhotoInput[]
    upsert?: LabProfileUpsertWithWhereUniqueWithoutProfilePhotoInput | LabProfileUpsertWithWhereUniqueWithoutProfilePhotoInput[]
    createMany?: LabProfileCreateManyProfilePhotoInputEnvelope
    set?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    disconnect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    delete?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    connect?: LabProfileWhereUniqueInput | LabProfileWhereUniqueInput[]
    update?: LabProfileUpdateWithWhereUniqueWithoutProfilePhotoInput | LabProfileUpdateWithWhereUniqueWithoutProfilePhotoInput[]
    updateMany?: LabProfileUpdateManyWithWhereWithoutProfilePhotoInput | LabProfileUpdateManyWithWhereWithoutProfilePhotoInput[]
    deleteMany?: LabProfileScalarWhereInput | LabProfileScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput> | ContentCreateWithoutThumbnailInput[] | ContentUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutThumbnailInput | ContentCreateOrConnectWithoutThumbnailInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutThumbnailInput | ContentUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ContentCreateManyThumbnailInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutThumbnailInput | ContentUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutThumbnailInput | ContentUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput> | ModuleCreateWithoutThumbnailInput[] | ModuleUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutThumbnailInput | ModuleCreateOrConnectWithoutThumbnailInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutThumbnailInput | ModuleUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ModuleCreateManyThumbnailInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutThumbnailInput | ModuleUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutThumbnailInput | ModuleUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput> | ClassCreateWithoutThumbnailInput[] | ClassUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutThumbnailInput | ClassCreateOrConnectWithoutThumbnailInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutThumbnailInput | ClassUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ClassCreateManyThumbnailInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutThumbnailInput | ClassUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutThumbnailInput | ClassUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ContentCreateNestedManyWithoutPreviewVideoInput = {
    create?: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput> | ContentCreateWithoutPreviewVideoInput[] | ContentUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutPreviewVideoInput | ContentCreateOrConnectWithoutPreviewVideoInput[]
    createMany?: ContentCreateManyPreviewVideoInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutPreviewVideoInput = {
    create?: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput> | ModuleCreateWithoutPreviewVideoInput[] | ModuleUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPreviewVideoInput | ModuleCreateOrConnectWithoutPreviewVideoInput[]
    createMany?: ModuleCreateManyPreviewVideoInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutVideoInput = {
    create?: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput> | ClassCreateWithoutVideoInput[] | ClassUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutVideoInput | ClassCreateOrConnectWithoutVideoInput[]
    createMany?: ClassCreateManyVideoInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutPreviewVideoInput = {
    create?: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput> | ContentCreateWithoutPreviewVideoInput[] | ContentUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutPreviewVideoInput | ContentCreateOrConnectWithoutPreviewVideoInput[]
    createMany?: ContentCreateManyPreviewVideoInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutPreviewVideoInput = {
    create?: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput> | ModuleCreateWithoutPreviewVideoInput[] | ModuleUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPreviewVideoInput | ModuleCreateOrConnectWithoutPreviewVideoInput[]
    createMany?: ModuleCreateManyPreviewVideoInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput> | ClassCreateWithoutVideoInput[] | ClassUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutVideoInput | ClassCreateOrConnectWithoutVideoInput[]
    createMany?: ClassCreateManyVideoInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContentUpdateManyWithoutPreviewVideoNestedInput = {
    create?: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput> | ContentCreateWithoutPreviewVideoInput[] | ContentUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutPreviewVideoInput | ContentCreateOrConnectWithoutPreviewVideoInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutPreviewVideoInput | ContentUpsertWithWhereUniqueWithoutPreviewVideoInput[]
    createMany?: ContentCreateManyPreviewVideoInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutPreviewVideoInput | ContentUpdateWithWhereUniqueWithoutPreviewVideoInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutPreviewVideoInput | ContentUpdateManyWithWhereWithoutPreviewVideoInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutPreviewVideoNestedInput = {
    create?: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput> | ModuleCreateWithoutPreviewVideoInput[] | ModuleUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPreviewVideoInput | ModuleCreateOrConnectWithoutPreviewVideoInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutPreviewVideoInput | ModuleUpsertWithWhereUniqueWithoutPreviewVideoInput[]
    createMany?: ModuleCreateManyPreviewVideoInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutPreviewVideoInput | ModuleUpdateWithWhereUniqueWithoutPreviewVideoInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutPreviewVideoInput | ModuleUpdateManyWithWhereWithoutPreviewVideoInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput> | ClassCreateWithoutVideoInput[] | ClassUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutVideoInput | ClassCreateOrConnectWithoutVideoInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutVideoInput | ClassUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ClassCreateManyVideoInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutVideoInput | ClassUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutVideoInput | ClassUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutPreviewVideoNestedInput = {
    create?: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput> | ContentCreateWithoutPreviewVideoInput[] | ContentUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutPreviewVideoInput | ContentCreateOrConnectWithoutPreviewVideoInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutPreviewVideoInput | ContentUpsertWithWhereUniqueWithoutPreviewVideoInput[]
    createMany?: ContentCreateManyPreviewVideoInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutPreviewVideoInput | ContentUpdateWithWhereUniqueWithoutPreviewVideoInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutPreviewVideoInput | ContentUpdateManyWithWhereWithoutPreviewVideoInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutPreviewVideoNestedInput = {
    create?: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput> | ModuleCreateWithoutPreviewVideoInput[] | ModuleUncheckedCreateWithoutPreviewVideoInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPreviewVideoInput | ModuleCreateOrConnectWithoutPreviewVideoInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutPreviewVideoInput | ModuleUpsertWithWhereUniqueWithoutPreviewVideoInput[]
    createMany?: ModuleCreateManyPreviewVideoInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutPreviewVideoInput | ModuleUpdateWithWhereUniqueWithoutPreviewVideoInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutPreviewVideoInput | ModuleUpdateManyWithWhereWithoutPreviewVideoInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput> | ClassCreateWithoutVideoInput[] | ClassUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutVideoInput | ClassCreateOrConnectWithoutVideoInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutVideoInput | ClassUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ClassCreateManyVideoInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutVideoInput | ClassUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutVideoInput | ClassUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserLabJoinCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput> | UserLabJoinCreateWithoutUserInput[] | UserLabJoinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserInput | UserLabJoinCreateOrConnectWithoutUserInput[]
    createMany?: UserLabJoinCreateManyUserInputEnvelope
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
  }

  export type LabCreateNestedManyWithoutOwnersInput = {
    create?: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput> | LabCreateWithoutOwnersInput[] | LabUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: LabCreateOrConnectWithoutOwnersInput | LabCreateOrConnectWithoutOwnersInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserLabJoinUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput> | UserLabJoinCreateWithoutUserInput[] | UserLabJoinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserInput | UserLabJoinCreateOrConnectWithoutUserInput[]
    createMany?: UserLabJoinCreateManyUserInputEnvelope
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
  }

  export type LabUncheckedCreateNestedManyWithoutOwnersInput = {
    create?: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput> | LabCreateWithoutOwnersInput[] | LabUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: LabCreateOrConnectWithoutOwnersInput | LabCreateOrConnectWithoutOwnersInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserLabJoinUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput> | UserLabJoinCreateWithoutUserInput[] | UserLabJoinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserInput | UserLabJoinCreateOrConnectWithoutUserInput[]
    upsert?: UserLabJoinUpsertWithWhereUniqueWithoutUserInput | UserLabJoinUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLabJoinCreateManyUserInputEnvelope
    set?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    disconnect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    delete?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    update?: UserLabJoinUpdateWithWhereUniqueWithoutUserInput | UserLabJoinUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLabJoinUpdateManyWithWhereWithoutUserInput | UserLabJoinUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
  }

  export type LabUpdateManyWithoutOwnersNestedInput = {
    create?: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput> | LabCreateWithoutOwnersInput[] | LabUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: LabCreateOrConnectWithoutOwnersInput | LabCreateOrConnectWithoutOwnersInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutOwnersInput | LabUpsertWithWhereUniqueWithoutOwnersInput[]
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutOwnersInput | LabUpdateWithWhereUniqueWithoutOwnersInput[]
    updateMany?: LabUpdateManyWithWhereWithoutOwnersInput | LabUpdateManyWithWhereWithoutOwnersInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserLabJoinUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput> | UserLabJoinCreateWithoutUserInput[] | UserLabJoinUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserInput | UserLabJoinCreateOrConnectWithoutUserInput[]
    upsert?: UserLabJoinUpsertWithWhereUniqueWithoutUserInput | UserLabJoinUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLabJoinCreateManyUserInputEnvelope
    set?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    disconnect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    delete?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    update?: UserLabJoinUpdateWithWhereUniqueWithoutUserInput | UserLabJoinUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLabJoinUpdateManyWithWhereWithoutUserInput | UserLabJoinUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
  }

  export type LabUncheckedUpdateManyWithoutOwnersNestedInput = {
    create?: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput> | LabCreateWithoutOwnersInput[] | LabUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: LabCreateOrConnectWithoutOwnersInput | LabCreateOrConnectWithoutOwnersInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutOwnersInput | LabUpsertWithWhereUniqueWithoutOwnersInput[]
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutOwnersInput | LabUpdateWithWhereUniqueWithoutOwnersInput[]
    updateMany?: LabUpdateManyWithWhereWithoutOwnersInput | LabUpdateManyWithWhereWithoutOwnersInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ImageCreateNestedOneWithoutUserProfilesInput = {
    create?: XOR<ImageCreateWithoutUserProfilesInput, ImageUncheckedCreateWithoutUserProfilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserProfilesInput
    connect?: ImageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type ImageUpdateOneWithoutUserProfilesNestedInput = {
    create?: XOR<ImageCreateWithoutUserProfilesInput, ImageUncheckedCreateWithoutUserProfilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserProfilesInput
    upsert?: ImageUpsertWithoutUserProfilesInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutUserProfilesInput, ImageUpdateWithoutUserProfilesInput>, ImageUncheckedUpdateWithoutUserProfilesInput>
  }

  export type LabProfileCreateNestedOneWithoutLabInput = {
    create?: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
    connectOrCreate?: LabProfileCreateOrConnectWithoutLabInput
    connect?: LabProfileWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutOwnedLabsInput = {
    create?: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput> | UserCreateWithoutOwnedLabsInput[] | UserUncheckedCreateWithoutOwnedLabsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLabsInput | UserCreateOrConnectWithoutOwnedLabsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserLabJoinCreateNestedManyWithoutLabInput = {
    create?: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput> | UserLabJoinCreateWithoutLabInput[] | UserLabJoinUncheckedCreateWithoutLabInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutLabInput | UserLabJoinCreateOrConnectWithoutLabInput[]
    createMany?: UserLabJoinCreateManyLabInputEnvelope
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutLabInput = {
    create?: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput> | RoleCreateWithoutLabInput[] | RoleUncheckedCreateWithoutLabInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLabInput | RoleCreateOrConnectWithoutLabInput[]
    createMany?: RoleCreateManyLabInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type PrivilegeCreateNestedManyWithoutLabInput = {
    create?: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput> | PrivilegeCreateWithoutLabInput[] | PrivilegeUncheckedCreateWithoutLabInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabInput | PrivilegeCreateOrConnectWithoutLabInput[]
    createMany?: PrivilegeCreateManyLabInputEnvelope
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutLabInput = {
    create?: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput> | ContentCreateWithoutLabInput[] | ContentUncheckedCreateWithoutLabInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutLabInput | ContentCreateOrConnectWithoutLabInput[]
    createMany?: ContentCreateManyLabInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type LabPermissionCreateNestedManyWithoutLabInput = {
    create?: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput> | LabPermissionCreateWithoutLabInput[] | LabPermissionUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutLabInput | LabPermissionCreateOrConnectWithoutLabInput[]
    createMany?: LabPermissionCreateManyLabInputEnvelope
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
  }

  export type LabProfileUncheckedCreateNestedOneWithoutLabInput = {
    create?: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
    connectOrCreate?: LabProfileCreateOrConnectWithoutLabInput
    connect?: LabProfileWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutOwnedLabsInput = {
    create?: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput> | UserCreateWithoutOwnedLabsInput[] | UserUncheckedCreateWithoutOwnedLabsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLabsInput | UserCreateOrConnectWithoutOwnedLabsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserLabJoinUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput> | UserLabJoinCreateWithoutLabInput[] | UserLabJoinUncheckedCreateWithoutLabInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutLabInput | UserLabJoinCreateOrConnectWithoutLabInput[]
    createMany?: UserLabJoinCreateManyLabInputEnvelope
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput> | RoleCreateWithoutLabInput[] | RoleUncheckedCreateWithoutLabInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLabInput | RoleCreateOrConnectWithoutLabInput[]
    createMany?: RoleCreateManyLabInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type PrivilegeUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput> | PrivilegeCreateWithoutLabInput[] | PrivilegeUncheckedCreateWithoutLabInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabInput | PrivilegeCreateOrConnectWithoutLabInput[]
    createMany?: PrivilegeCreateManyLabInputEnvelope
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput> | ContentCreateWithoutLabInput[] | ContentUncheckedCreateWithoutLabInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutLabInput | ContentCreateOrConnectWithoutLabInput[]
    createMany?: ContentCreateManyLabInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type LabPermissionUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput> | LabPermissionCreateWithoutLabInput[] | LabPermissionUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutLabInput | LabPermissionCreateOrConnectWithoutLabInput[]
    createMany?: LabPermissionCreateManyLabInputEnvelope
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LabProfileUpdateOneWithoutLabNestedInput = {
    create?: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
    connectOrCreate?: LabProfileCreateOrConnectWithoutLabInput
    upsert?: LabProfileUpsertWithoutLabInput
    disconnect?: LabProfileWhereInput | boolean
    delete?: LabProfileWhereInput | boolean
    connect?: LabProfileWhereUniqueInput
    update?: XOR<XOR<LabProfileUpdateToOneWithWhereWithoutLabInput, LabProfileUpdateWithoutLabInput>, LabProfileUncheckedUpdateWithoutLabInput>
  }

  export type UserUpdateManyWithoutOwnedLabsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput> | UserCreateWithoutOwnedLabsInput[] | UserUncheckedCreateWithoutOwnedLabsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLabsInput | UserCreateOrConnectWithoutOwnedLabsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOwnedLabsInput | UserUpsertWithWhereUniqueWithoutOwnedLabsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOwnedLabsInput | UserUpdateWithWhereUniqueWithoutOwnedLabsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOwnedLabsInput | UserUpdateManyWithWhereWithoutOwnedLabsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserLabJoinUpdateManyWithoutLabNestedInput = {
    create?: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput> | UserLabJoinCreateWithoutLabInput[] | UserLabJoinUncheckedCreateWithoutLabInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutLabInput | UserLabJoinCreateOrConnectWithoutLabInput[]
    upsert?: UserLabJoinUpsertWithWhereUniqueWithoutLabInput | UserLabJoinUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: UserLabJoinCreateManyLabInputEnvelope
    set?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    disconnect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    delete?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    update?: UserLabJoinUpdateWithWhereUniqueWithoutLabInput | UserLabJoinUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: UserLabJoinUpdateManyWithWhereWithoutLabInput | UserLabJoinUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutLabNestedInput = {
    create?: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput> | RoleCreateWithoutLabInput[] | RoleUncheckedCreateWithoutLabInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLabInput | RoleCreateOrConnectWithoutLabInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutLabInput | RoleUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: RoleCreateManyLabInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutLabInput | RoleUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutLabInput | RoleUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type PrivilegeUpdateManyWithoutLabNestedInput = {
    create?: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput> | PrivilegeCreateWithoutLabInput[] | PrivilegeUncheckedCreateWithoutLabInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabInput | PrivilegeCreateOrConnectWithoutLabInput[]
    upsert?: PrivilegeUpsertWithWhereUniqueWithoutLabInput | PrivilegeUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: PrivilegeCreateManyLabInputEnvelope
    set?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    disconnect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    delete?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    update?: PrivilegeUpdateWithWhereUniqueWithoutLabInput | PrivilegeUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: PrivilegeUpdateManyWithWhereWithoutLabInput | PrivilegeUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutLabNestedInput = {
    create?: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput> | ContentCreateWithoutLabInput[] | ContentUncheckedCreateWithoutLabInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutLabInput | ContentCreateOrConnectWithoutLabInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutLabInput | ContentUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: ContentCreateManyLabInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutLabInput | ContentUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutLabInput | ContentUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type LabPermissionUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput> | LabPermissionCreateWithoutLabInput[] | LabPermissionUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutLabInput | LabPermissionCreateOrConnectWithoutLabInput[]
    upsert?: LabPermissionUpsertWithWhereUniqueWithoutLabInput | LabPermissionUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabPermissionCreateManyLabInputEnvelope
    set?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    disconnect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    delete?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    update?: LabPermissionUpdateWithWhereUniqueWithoutLabInput | LabPermissionUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabPermissionUpdateManyWithWhereWithoutLabInput | LabPermissionUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
  }

  export type LabProfileUncheckedUpdateOneWithoutLabNestedInput = {
    create?: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
    connectOrCreate?: LabProfileCreateOrConnectWithoutLabInput
    upsert?: LabProfileUpsertWithoutLabInput
    disconnect?: LabProfileWhereInput | boolean
    delete?: LabProfileWhereInput | boolean
    connect?: LabProfileWhereUniqueInput
    update?: XOR<XOR<LabProfileUpdateToOneWithWhereWithoutLabInput, LabProfileUpdateWithoutLabInput>, LabProfileUncheckedUpdateWithoutLabInput>
  }

  export type UserUncheckedUpdateManyWithoutOwnedLabsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput> | UserCreateWithoutOwnedLabsInput[] | UserUncheckedCreateWithoutOwnedLabsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLabsInput | UserCreateOrConnectWithoutOwnedLabsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOwnedLabsInput | UserUpsertWithWhereUniqueWithoutOwnedLabsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOwnedLabsInput | UserUpdateWithWhereUniqueWithoutOwnedLabsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOwnedLabsInput | UserUpdateManyWithWhereWithoutOwnedLabsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserLabJoinUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput> | UserLabJoinCreateWithoutLabInput[] | UserLabJoinUncheckedCreateWithoutLabInput[]
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutLabInput | UserLabJoinCreateOrConnectWithoutLabInput[]
    upsert?: UserLabJoinUpsertWithWhereUniqueWithoutLabInput | UserLabJoinUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: UserLabJoinCreateManyLabInputEnvelope
    set?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    disconnect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    delete?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    connect?: UserLabJoinWhereUniqueInput | UserLabJoinWhereUniqueInput[]
    update?: UserLabJoinUpdateWithWhereUniqueWithoutLabInput | UserLabJoinUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: UserLabJoinUpdateManyWithWhereWithoutLabInput | UserLabJoinUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput> | RoleCreateWithoutLabInput[] | RoleUncheckedCreateWithoutLabInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutLabInput | RoleCreateOrConnectWithoutLabInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutLabInput | RoleUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: RoleCreateManyLabInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutLabInput | RoleUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutLabInput | RoleUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type PrivilegeUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput> | PrivilegeCreateWithoutLabInput[] | PrivilegeUncheckedCreateWithoutLabInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabInput | PrivilegeCreateOrConnectWithoutLabInput[]
    upsert?: PrivilegeUpsertWithWhereUniqueWithoutLabInput | PrivilegeUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: PrivilegeCreateManyLabInputEnvelope
    set?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    disconnect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    delete?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    update?: PrivilegeUpdateWithWhereUniqueWithoutLabInput | PrivilegeUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: PrivilegeUpdateManyWithWhereWithoutLabInput | PrivilegeUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput> | ContentCreateWithoutLabInput[] | ContentUncheckedCreateWithoutLabInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutLabInput | ContentCreateOrConnectWithoutLabInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutLabInput | ContentUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: ContentCreateManyLabInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutLabInput | ContentUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutLabInput | ContentUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type LabPermissionUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput> | LabPermissionCreateWithoutLabInput[] | LabPermissionUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutLabInput | LabPermissionCreateOrConnectWithoutLabInput[]
    upsert?: LabPermissionUpsertWithWhereUniqueWithoutLabInput | LabPermissionUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabPermissionCreateManyLabInputEnvelope
    set?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    disconnect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    delete?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    update?: LabPermissionUpdateWithWhereUniqueWithoutLabInput | LabPermissionUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabPermissionUpdateManyWithWhereWithoutLabInput | LabPermissionUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
  }

  export type LabCreateNestedOneWithoutProfileInput = {
    create?: XOR<LabCreateWithoutProfileInput, LabUncheckedCreateWithoutProfileInput>
    connectOrCreate?: LabCreateOrConnectWithoutProfileInput
    connect?: LabWhereUniqueInput
  }

  export type ImageCreateNestedOneWithoutLabProfilesInput = {
    create?: XOR<ImageCreateWithoutLabProfilesInput, ImageUncheckedCreateWithoutLabProfilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutLabProfilesInput
    connect?: ImageWhereUniqueInput
  }

  export type LabUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<LabCreateWithoutProfileInput, LabUncheckedCreateWithoutProfileInput>
    connectOrCreate?: LabCreateOrConnectWithoutProfileInput
    upsert?: LabUpsertWithoutProfileInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutProfileInput, LabUpdateWithoutProfileInput>, LabUncheckedUpdateWithoutProfileInput>
  }

  export type ImageUpdateOneWithoutLabProfilesNestedInput = {
    create?: XOR<ImageCreateWithoutLabProfilesInput, ImageUncheckedCreateWithoutLabProfilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutLabProfilesInput
    upsert?: ImageUpsertWithoutLabProfilesInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutLabProfilesInput, ImageUpdateWithoutLabProfilesInput>, ImageUncheckedUpdateWithoutLabProfilesInput>
  }

  export type UserCreateNestedOneWithoutLabsInput = {
    create?: XOR<UserCreateWithoutLabsInput, UserUncheckedCreateWithoutLabsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabsInput
    connect?: UserWhereUniqueInput
  }

  export type LabCreateNestedOneWithoutCommunityInput = {
    create?: XOR<LabCreateWithoutCommunityInput, LabUncheckedCreateWithoutCommunityInput>
    connectOrCreate?: LabCreateOrConnectWithoutCommunityInput
    connect?: LabWhereUniqueInput
  }

  export type UserLabRoleCreateNestedManyWithoutUserLabJoinInput = {
    create?: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput> | UserLabRoleCreateWithoutUserLabJoinInput[] | UserLabRoleUncheckedCreateWithoutUserLabJoinInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutUserLabJoinInput | UserLabRoleCreateOrConnectWithoutUserLabJoinInput[]
    createMany?: UserLabRoleCreateManyUserLabJoinInputEnvelope
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
  }

  export type UserLabRoleUncheckedCreateNestedManyWithoutUserLabJoinInput = {
    create?: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput> | UserLabRoleCreateWithoutUserLabJoinInput[] | UserLabRoleUncheckedCreateWithoutUserLabJoinInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutUserLabJoinInput | UserLabRoleCreateOrConnectWithoutUserLabJoinInput[]
    createMany?: UserLabRoleCreateManyUserLabJoinInputEnvelope
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLabsNestedInput = {
    create?: XOR<UserCreateWithoutLabsInput, UserUncheckedCreateWithoutLabsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabsInput
    upsert?: UserUpsertWithoutLabsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabsInput, UserUpdateWithoutLabsInput>, UserUncheckedUpdateWithoutLabsInput>
  }

  export type LabUpdateOneRequiredWithoutCommunityNestedInput = {
    create?: XOR<LabCreateWithoutCommunityInput, LabUncheckedCreateWithoutCommunityInput>
    connectOrCreate?: LabCreateOrConnectWithoutCommunityInput
    upsert?: LabUpsertWithoutCommunityInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutCommunityInput, LabUpdateWithoutCommunityInput>, LabUncheckedUpdateWithoutCommunityInput>
  }

  export type UserLabRoleUpdateManyWithoutUserLabJoinNestedInput = {
    create?: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput> | UserLabRoleCreateWithoutUserLabJoinInput[] | UserLabRoleUncheckedCreateWithoutUserLabJoinInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutUserLabJoinInput | UserLabRoleCreateOrConnectWithoutUserLabJoinInput[]
    upsert?: UserLabRoleUpsertWithWhereUniqueWithoutUserLabJoinInput | UserLabRoleUpsertWithWhereUniqueWithoutUserLabJoinInput[]
    createMany?: UserLabRoleCreateManyUserLabJoinInputEnvelope
    set?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    disconnect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    delete?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    update?: UserLabRoleUpdateWithWhereUniqueWithoutUserLabJoinInput | UserLabRoleUpdateWithWhereUniqueWithoutUserLabJoinInput[]
    updateMany?: UserLabRoleUpdateManyWithWhereWithoutUserLabJoinInput | UserLabRoleUpdateManyWithWhereWithoutUserLabJoinInput[]
    deleteMany?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
  }

  export type UserLabRoleUncheckedUpdateManyWithoutUserLabJoinNestedInput = {
    create?: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput> | UserLabRoleCreateWithoutUserLabJoinInput[] | UserLabRoleUncheckedCreateWithoutUserLabJoinInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutUserLabJoinInput | UserLabRoleCreateOrConnectWithoutUserLabJoinInput[]
    upsert?: UserLabRoleUpsertWithWhereUniqueWithoutUserLabJoinInput | UserLabRoleUpsertWithWhereUniqueWithoutUserLabJoinInput[]
    createMany?: UserLabRoleCreateManyUserLabJoinInputEnvelope
    set?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    disconnect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    delete?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    update?: UserLabRoleUpdateWithWhereUniqueWithoutUserLabJoinInput | UserLabRoleUpdateWithWhereUniqueWithoutUserLabJoinInput[]
    updateMany?: UserLabRoleUpdateManyWithWhereWithoutUserLabJoinInput | UserLabRoleUpdateManyWithWhereWithoutUserLabJoinInput[]
    deleteMany?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
  }

  export type LabCreateNestedOneWithoutRolesInput = {
    create?: XOR<LabCreateWithoutRolesInput, LabUncheckedCreateWithoutRolesInput>
    connectOrCreate?: LabCreateOrConnectWithoutRolesInput
    connect?: LabWhereUniqueInput
  }

  export type UserLabRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput> | UserLabRoleCreateWithoutRoleInput[] | UserLabRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutRoleInput | UserLabRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserLabRoleCreateManyRoleInputEnvelope
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
  }

  export type RolePrivilegeJoinCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput> | RolePrivilegeJoinCreateWithoutRoleInput[] | RolePrivilegeJoinUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutRoleInput | RolePrivilegeJoinCreateOrConnectWithoutRoleInput[]
    createMany?: RolePrivilegeJoinCreateManyRoleInputEnvelope
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
  }

  export type UserLabRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput> | UserLabRoleCreateWithoutRoleInput[] | UserLabRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutRoleInput | UserLabRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserLabRoleCreateManyRoleInputEnvelope
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
  }

  export type RolePrivilegeJoinUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput> | RolePrivilegeJoinCreateWithoutRoleInput[] | RolePrivilegeJoinUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutRoleInput | RolePrivilegeJoinCreateOrConnectWithoutRoleInput[]
    createMany?: RolePrivilegeJoinCreateManyRoleInputEnvelope
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
  }

  export type LabUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<LabCreateWithoutRolesInput, LabUncheckedCreateWithoutRolesInput>
    connectOrCreate?: LabCreateOrConnectWithoutRolesInput
    upsert?: LabUpsertWithoutRolesInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutRolesInput, LabUpdateWithoutRolesInput>, LabUncheckedUpdateWithoutRolesInput>
  }

  export type UserLabRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput> | UserLabRoleCreateWithoutRoleInput[] | UserLabRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutRoleInput | UserLabRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserLabRoleUpsertWithWhereUniqueWithoutRoleInput | UserLabRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserLabRoleCreateManyRoleInputEnvelope
    set?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    disconnect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    delete?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    update?: UserLabRoleUpdateWithWhereUniqueWithoutRoleInput | UserLabRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserLabRoleUpdateManyWithWhereWithoutRoleInput | UserLabRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
  }

  export type RolePrivilegeJoinUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput> | RolePrivilegeJoinCreateWithoutRoleInput[] | RolePrivilegeJoinUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutRoleInput | RolePrivilegeJoinCreateOrConnectWithoutRoleInput[]
    upsert?: RolePrivilegeJoinUpsertWithWhereUniqueWithoutRoleInput | RolePrivilegeJoinUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePrivilegeJoinCreateManyRoleInputEnvelope
    set?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    disconnect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    delete?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    update?: RolePrivilegeJoinUpdateWithWhereUniqueWithoutRoleInput | RolePrivilegeJoinUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePrivilegeJoinUpdateManyWithWhereWithoutRoleInput | RolePrivilegeJoinUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
  }

  export type UserLabRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput> | UserLabRoleCreateWithoutRoleInput[] | UserLabRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserLabRoleCreateOrConnectWithoutRoleInput | UserLabRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserLabRoleUpsertWithWhereUniqueWithoutRoleInput | UserLabRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserLabRoleCreateManyRoleInputEnvelope
    set?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    disconnect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    delete?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    connect?: UserLabRoleWhereUniqueInput | UserLabRoleWhereUniqueInput[]
    update?: UserLabRoleUpdateWithWhereUniqueWithoutRoleInput | UserLabRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserLabRoleUpdateManyWithWhereWithoutRoleInput | UserLabRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
  }

  export type RolePrivilegeJoinUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput> | RolePrivilegeJoinCreateWithoutRoleInput[] | RolePrivilegeJoinUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutRoleInput | RolePrivilegeJoinCreateOrConnectWithoutRoleInput[]
    upsert?: RolePrivilegeJoinUpsertWithWhereUniqueWithoutRoleInput | RolePrivilegeJoinUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePrivilegeJoinCreateManyRoleInputEnvelope
    set?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    disconnect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    delete?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    update?: RolePrivilegeJoinUpdateWithWhereUniqueWithoutRoleInput | RolePrivilegeJoinUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePrivilegeJoinUpdateManyWithWhereWithoutRoleInput | RolePrivilegeJoinUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
  }

  export type UserLabJoinCreateNestedOneWithoutUserLabRolesInput = {
    create?: XOR<UserLabJoinCreateWithoutUserLabRolesInput, UserLabJoinUncheckedCreateWithoutUserLabRolesInput>
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserLabRolesInput
    connect?: UserLabJoinWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserLabRolesInput = {
    create?: XOR<RoleCreateWithoutUserLabRolesInput, RoleUncheckedCreateWithoutUserLabRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserLabRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserLabJoinUpdateOneRequiredWithoutUserLabRolesNestedInput = {
    create?: XOR<UserLabJoinCreateWithoutUserLabRolesInput, UserLabJoinUncheckedCreateWithoutUserLabRolesInput>
    connectOrCreate?: UserLabJoinCreateOrConnectWithoutUserLabRolesInput
    upsert?: UserLabJoinUpsertWithoutUserLabRolesInput
    connect?: UserLabJoinWhereUniqueInput
    update?: XOR<XOR<UserLabJoinUpdateToOneWithWhereWithoutUserLabRolesInput, UserLabJoinUpdateWithoutUserLabRolesInput>, UserLabJoinUncheckedUpdateWithoutUserLabRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserLabRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserLabRolesInput, RoleUncheckedCreateWithoutUserLabRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserLabRolesInput
    upsert?: RoleUpsertWithoutUserLabRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserLabRolesInput, RoleUpdateWithoutUserLabRolesInput>, RoleUncheckedUpdateWithoutUserLabRolesInput>
  }

  export type LabCreateNestedOneWithoutPrivilegesInput = {
    create?: XOR<LabCreateWithoutPrivilegesInput, LabUncheckedCreateWithoutPrivilegesInput>
    connectOrCreate?: LabCreateOrConnectWithoutPrivilegesInput
    connect?: LabWhereUniqueInput
  }

  export type RolePrivilegeJoinCreateNestedManyWithoutPrivilegeInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput> | RolePrivilegeJoinCreateWithoutPrivilegeInput[] | RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput | RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput[]
    createMany?: RolePrivilegeJoinCreateManyPrivilegeInputEnvelope
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
  }

  export type LabPermissionCreateNestedManyWithoutPrivilegesInput = {
    create?: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput> | LabPermissionCreateWithoutPrivilegesInput[] | LabPermissionUncheckedCreateWithoutPrivilegesInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutPrivilegesInput | LabPermissionCreateOrConnectWithoutPrivilegesInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
  }

  export type RolePrivilegeJoinUncheckedCreateNestedManyWithoutPrivilegeInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput> | RolePrivilegeJoinCreateWithoutPrivilegeInput[] | RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput | RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput[]
    createMany?: RolePrivilegeJoinCreateManyPrivilegeInputEnvelope
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
  }

  export type LabPermissionUncheckedCreateNestedManyWithoutPrivilegesInput = {
    create?: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput> | LabPermissionCreateWithoutPrivilegesInput[] | LabPermissionUncheckedCreateWithoutPrivilegesInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutPrivilegesInput | LabPermissionCreateOrConnectWithoutPrivilegesInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
  }

  export type LabUpdateOneRequiredWithoutPrivilegesNestedInput = {
    create?: XOR<LabCreateWithoutPrivilegesInput, LabUncheckedCreateWithoutPrivilegesInput>
    connectOrCreate?: LabCreateOrConnectWithoutPrivilegesInput
    upsert?: LabUpsertWithoutPrivilegesInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutPrivilegesInput, LabUpdateWithoutPrivilegesInput>, LabUncheckedUpdateWithoutPrivilegesInput>
  }

  export type RolePrivilegeJoinUpdateManyWithoutPrivilegeNestedInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput> | RolePrivilegeJoinCreateWithoutPrivilegeInput[] | RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput | RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput[]
    upsert?: RolePrivilegeJoinUpsertWithWhereUniqueWithoutPrivilegeInput | RolePrivilegeJoinUpsertWithWhereUniqueWithoutPrivilegeInput[]
    createMany?: RolePrivilegeJoinCreateManyPrivilegeInputEnvelope
    set?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    disconnect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    delete?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    update?: RolePrivilegeJoinUpdateWithWhereUniqueWithoutPrivilegeInput | RolePrivilegeJoinUpdateWithWhereUniqueWithoutPrivilegeInput[]
    updateMany?: RolePrivilegeJoinUpdateManyWithWhereWithoutPrivilegeInput | RolePrivilegeJoinUpdateManyWithWhereWithoutPrivilegeInput[]
    deleteMany?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
  }

  export type LabPermissionUpdateManyWithoutPrivilegesNestedInput = {
    create?: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput> | LabPermissionCreateWithoutPrivilegesInput[] | LabPermissionUncheckedCreateWithoutPrivilegesInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutPrivilegesInput | LabPermissionCreateOrConnectWithoutPrivilegesInput[]
    upsert?: LabPermissionUpsertWithWhereUniqueWithoutPrivilegesInput | LabPermissionUpsertWithWhereUniqueWithoutPrivilegesInput[]
    set?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    disconnect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    delete?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    update?: LabPermissionUpdateWithWhereUniqueWithoutPrivilegesInput | LabPermissionUpdateWithWhereUniqueWithoutPrivilegesInput[]
    updateMany?: LabPermissionUpdateManyWithWhereWithoutPrivilegesInput | LabPermissionUpdateManyWithWhereWithoutPrivilegesInput[]
    deleteMany?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
  }

  export type RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeNestedInput = {
    create?: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput> | RolePrivilegeJoinCreateWithoutPrivilegeInput[] | RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput | RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput[]
    upsert?: RolePrivilegeJoinUpsertWithWhereUniqueWithoutPrivilegeInput | RolePrivilegeJoinUpsertWithWhereUniqueWithoutPrivilegeInput[]
    createMany?: RolePrivilegeJoinCreateManyPrivilegeInputEnvelope
    set?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    disconnect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    delete?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    connect?: RolePrivilegeJoinWhereUniqueInput | RolePrivilegeJoinWhereUniqueInput[]
    update?: RolePrivilegeJoinUpdateWithWhereUniqueWithoutPrivilegeInput | RolePrivilegeJoinUpdateWithWhereUniqueWithoutPrivilegeInput[]
    updateMany?: RolePrivilegeJoinUpdateManyWithWhereWithoutPrivilegeInput | RolePrivilegeJoinUpdateManyWithWhereWithoutPrivilegeInput[]
    deleteMany?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
  }

  export type LabPermissionUncheckedUpdateManyWithoutPrivilegesNestedInput = {
    create?: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput> | LabPermissionCreateWithoutPrivilegesInput[] | LabPermissionUncheckedCreateWithoutPrivilegesInput[]
    connectOrCreate?: LabPermissionCreateOrConnectWithoutPrivilegesInput | LabPermissionCreateOrConnectWithoutPrivilegesInput[]
    upsert?: LabPermissionUpsertWithWhereUniqueWithoutPrivilegesInput | LabPermissionUpsertWithWhereUniqueWithoutPrivilegesInput[]
    set?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    disconnect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    delete?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    connect?: LabPermissionWhereUniqueInput | LabPermissionWhereUniqueInput[]
    update?: LabPermissionUpdateWithWhereUniqueWithoutPrivilegesInput | LabPermissionUpdateWithWhereUniqueWithoutPrivilegesInput[]
    updateMany?: LabPermissionUpdateManyWithWhereWithoutPrivilegesInput | LabPermissionUpdateManyWithWhereWithoutPrivilegesInput[]
    deleteMany?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
  }

  export type LabCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<LabCreateWithoutPermissionsInput, LabUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: LabCreateOrConnectWithoutPermissionsInput
    connect?: LabWhereUniqueInput
  }

  export type PrivilegeCreateNestedManyWithoutLabPermissionsInput = {
    create?: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput> | PrivilegeCreateWithoutLabPermissionsInput[] | PrivilegeUncheckedCreateWithoutLabPermissionsInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabPermissionsInput | PrivilegeCreateOrConnectWithoutLabPermissionsInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
  }

  export type PrivilegeUncheckedCreateNestedManyWithoutLabPermissionsInput = {
    create?: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput> | PrivilegeCreateWithoutLabPermissionsInput[] | PrivilegeUncheckedCreateWithoutLabPermissionsInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabPermissionsInput | PrivilegeCreateOrConnectWithoutLabPermissionsInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
  }

  export type LabUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<LabCreateWithoutPermissionsInput, LabUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: LabCreateOrConnectWithoutPermissionsInput
    upsert?: LabUpsertWithoutPermissionsInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutPermissionsInput, LabUpdateWithoutPermissionsInput>, LabUncheckedUpdateWithoutPermissionsInput>
  }

  export type PrivilegeUpdateManyWithoutLabPermissionsNestedInput = {
    create?: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput> | PrivilegeCreateWithoutLabPermissionsInput[] | PrivilegeUncheckedCreateWithoutLabPermissionsInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabPermissionsInput | PrivilegeCreateOrConnectWithoutLabPermissionsInput[]
    upsert?: PrivilegeUpsertWithWhereUniqueWithoutLabPermissionsInput | PrivilegeUpsertWithWhereUniqueWithoutLabPermissionsInput[]
    set?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    disconnect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    delete?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    update?: PrivilegeUpdateWithWhereUniqueWithoutLabPermissionsInput | PrivilegeUpdateWithWhereUniqueWithoutLabPermissionsInput[]
    updateMany?: PrivilegeUpdateManyWithWhereWithoutLabPermissionsInput | PrivilegeUpdateManyWithWhereWithoutLabPermissionsInput[]
    deleteMany?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
  }

  export type PrivilegeUncheckedUpdateManyWithoutLabPermissionsNestedInput = {
    create?: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput> | PrivilegeCreateWithoutLabPermissionsInput[] | PrivilegeUncheckedCreateWithoutLabPermissionsInput[]
    connectOrCreate?: PrivilegeCreateOrConnectWithoutLabPermissionsInput | PrivilegeCreateOrConnectWithoutLabPermissionsInput[]
    upsert?: PrivilegeUpsertWithWhereUniqueWithoutLabPermissionsInput | PrivilegeUpsertWithWhereUniqueWithoutLabPermissionsInput[]
    set?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    disconnect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    delete?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    connect?: PrivilegeWhereUniqueInput | PrivilegeWhereUniqueInput[]
    update?: PrivilegeUpdateWithWhereUniqueWithoutLabPermissionsInput | PrivilegeUpdateWithWhereUniqueWithoutLabPermissionsInput[]
    updateMany?: PrivilegeUpdateManyWithWhereWithoutLabPermissionsInput | PrivilegeUpdateManyWithWhereWithoutLabPermissionsInput[]
    deleteMany?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPrivilegesInput = {
    create?: XOR<RoleCreateWithoutPrivilegesInput, RoleUncheckedCreateWithoutPrivilegesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPrivilegesInput
    connect?: RoleWhereUniqueInput
  }

  export type PrivilegeCreateNestedOneWithoutRolesInput = {
    create?: XOR<PrivilegeCreateWithoutRolesInput, PrivilegeUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PrivilegeCreateOrConnectWithoutRolesInput
    connect?: PrivilegeWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPrivilegesNestedInput = {
    create?: XOR<RoleCreateWithoutPrivilegesInput, RoleUncheckedCreateWithoutPrivilegesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPrivilegesInput
    upsert?: RoleUpsertWithoutPrivilegesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPrivilegesInput, RoleUpdateWithoutPrivilegesInput>, RoleUncheckedUpdateWithoutPrivilegesInput>
  }

  export type PrivilegeUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PrivilegeCreateWithoutRolesInput, PrivilegeUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PrivilegeCreateOrConnectWithoutRolesInput
    upsert?: PrivilegeUpsertWithoutRolesInput
    connect?: PrivilegeWhereUniqueInput
    update?: XOR<XOR<PrivilegeUpdateToOneWithWhereWithoutRolesInput, PrivilegeUpdateWithoutRolesInput>, PrivilegeUncheckedUpdateWithoutRolesInput>
  }

  export type LabCreateNestedOneWithoutContentInput = {
    create?: XOR<LabCreateWithoutContentInput, LabUncheckedCreateWithoutContentInput>
    connectOrCreate?: LabCreateOrConnectWithoutContentInput
    connect?: LabWhereUniqueInput
  }

  export type ImageCreateNestedOneWithoutContentsInput = {
    create?: XOR<ImageCreateWithoutContentsInput, ImageUncheckedCreateWithoutContentsInput>
    connectOrCreate?: ImageCreateOrConnectWithoutContentsInput
    connect?: ImageWhereUniqueInput
  }

  export type ModuleCreateNestedManyWithoutContentInput = {
    create?: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput> | ModuleCreateWithoutContentInput[] | ModuleUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutContentInput | ModuleCreateOrConnectWithoutContentInput[]
    createMany?: ModuleCreateManyContentInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type VideoCreateNestedOneWithoutPreviewForContentInput = {
    create?: XOR<VideoCreateWithoutPreviewForContentInput, VideoUncheckedCreateWithoutPreviewForContentInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPreviewForContentInput
    connect?: VideoWhereUniqueInput
  }

  export type ModuleUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput> | ModuleCreateWithoutContentInput[] | ModuleUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutContentInput | ModuleCreateOrConnectWithoutContentInput[]
    createMany?: ModuleCreateManyContentInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type LabUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<LabCreateWithoutContentInput, LabUncheckedCreateWithoutContentInput>
    connectOrCreate?: LabCreateOrConnectWithoutContentInput
    upsert?: LabUpsertWithoutContentInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutContentInput, LabUpdateWithoutContentInput>, LabUncheckedUpdateWithoutContentInput>
  }

  export type ImageUpdateOneWithoutContentsNestedInput = {
    create?: XOR<ImageCreateWithoutContentsInput, ImageUncheckedCreateWithoutContentsInput>
    connectOrCreate?: ImageCreateOrConnectWithoutContentsInput
    upsert?: ImageUpsertWithoutContentsInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutContentsInput, ImageUpdateWithoutContentsInput>, ImageUncheckedUpdateWithoutContentsInput>
  }

  export type ModuleUpdateManyWithoutContentNestedInput = {
    create?: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput> | ModuleCreateWithoutContentInput[] | ModuleUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutContentInput | ModuleCreateOrConnectWithoutContentInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutContentInput | ModuleUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ModuleCreateManyContentInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutContentInput | ModuleUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutContentInput | ModuleUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type VideoUpdateOneWithoutPreviewForContentNestedInput = {
    create?: XOR<VideoCreateWithoutPreviewForContentInput, VideoUncheckedCreateWithoutPreviewForContentInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPreviewForContentInput
    upsert?: VideoUpsertWithoutPreviewForContentInput
    disconnect?: VideoWhereInput | boolean
    delete?: VideoWhereInput | boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutPreviewForContentInput, VideoUpdateWithoutPreviewForContentInput>, VideoUncheckedUpdateWithoutPreviewForContentInput>
  }

  export type ModuleUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput> | ModuleCreateWithoutContentInput[] | ModuleUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutContentInput | ModuleCreateOrConnectWithoutContentInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutContentInput | ModuleUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ModuleCreateManyContentInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutContentInput | ModuleUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutContentInput | ModuleUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ImageCreateNestedOneWithoutModulesInput = {
    create?: XOR<ImageCreateWithoutModulesInput, ImageUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutModulesInput
    connect?: ImageWhereUniqueInput
  }

  export type ContentCreateNestedOneWithoutModulesInput = {
    create?: XOR<ContentCreateWithoutModulesInput, ContentUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutModulesInput
    connect?: ContentWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutModuleInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type VideoCreateNestedOneWithoutPreviewForModuleInput = {
    create?: XOR<VideoCreateWithoutPreviewForModuleInput, VideoUncheckedCreateWithoutPreviewForModuleInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPreviewForModuleInput
    connect?: VideoWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ImageUpdateOneWithoutModulesNestedInput = {
    create?: XOR<ImageCreateWithoutModulesInput, ImageUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutModulesInput
    upsert?: ImageUpsertWithoutModulesInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutModulesInput, ImageUpdateWithoutModulesInput>, ImageUncheckedUpdateWithoutModulesInput>
  }

  export type ContentUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ContentCreateWithoutModulesInput, ContentUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutModulesInput
    upsert?: ContentUpsertWithoutModulesInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutModulesInput, ContentUpdateWithoutModulesInput>, ContentUncheckedUpdateWithoutModulesInput>
  }

  export type ClassUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutModuleInput | ClassUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutModuleInput | ClassUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutModuleInput | ClassUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type VideoUpdateOneWithoutPreviewForModuleNestedInput = {
    create?: XOR<VideoCreateWithoutPreviewForModuleInput, VideoUncheckedCreateWithoutPreviewForModuleInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPreviewForModuleInput
    upsert?: VideoUpsertWithoutPreviewForModuleInput
    disconnect?: VideoWhereInput | boolean
    delete?: VideoWhereInput | boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutPreviewForModuleInput, VideoUpdateWithoutPreviewForModuleInput>, VideoUncheckedUpdateWithoutPreviewForModuleInput>
  }

  export type ClassUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput> | ClassCreateWithoutModuleInput[] | ClassUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutModuleInput | ClassCreateOrConnectWithoutModuleInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutModuleInput | ClassUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ClassCreateManyModuleInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutModuleInput | ClassUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutModuleInput | ClassUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ImageCreateNestedOneWithoutClassesInput = {
    create?: XOR<ImageCreateWithoutClassesInput, ImageUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutClassesInput
    connect?: ImageWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutClassesInput = {
    create?: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClassesInput
    connect?: ModuleWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutClassesInput = {
    create?: XOR<VideoCreateWithoutClassesInput, VideoUncheckedCreateWithoutClassesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutClassesInput
    connect?: VideoWhereUniqueInput
  }

  export type ImageUpdateOneWithoutClassesNestedInput = {
    create?: XOR<ImageCreateWithoutClassesInput, ImageUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutClassesInput
    upsert?: ImageUpsertWithoutClassesInput
    disconnect?: ImageWhereInput | boolean
    delete?: ImageWhereInput | boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<XOR<ImageUpdateToOneWithWhereWithoutClassesInput, ImageUpdateWithoutClassesInput>, ImageUncheckedUpdateWithoutClassesInput>
  }

  export type ModuleUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClassesInput
    upsert?: ModuleUpsertWithoutClassesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutClassesInput, ModuleUpdateWithoutClassesInput>, ModuleUncheckedUpdateWithoutClassesInput>
  }

  export type VideoUpdateOneWithoutClassesNestedInput = {
    create?: XOR<VideoCreateWithoutClassesInput, VideoUncheckedCreateWithoutClassesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutClassesInput
    upsert?: VideoUpsertWithoutClassesInput
    disconnect?: VideoWhereInput | boolean
    delete?: VideoWhereInput | boolean
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutClassesInput, VideoUpdateWithoutClassesInput>, VideoUncheckedUpdateWithoutClassesInput>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserProfileCreateWithoutProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    userId: string
    bio?: string | null
    instagram?: string | null
  }

  export type UserProfileCreateOrConnectWithoutProfilePhotoInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput>
  }

  export type UserProfileCreateManyProfilePhotoInputEnvelope = {
    data: UserProfileCreateManyProfilePhotoInput | UserProfileCreateManyProfilePhotoInput[]
  }

  export type LabProfileCreateWithoutProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    slug?: string | null
    lab: LabCreateNestedOneWithoutProfileInput
  }

  export type LabProfileUncheckedCreateWithoutProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    bio?: string | null
    instagram?: string | null
    slug?: string | null
  }

  export type LabProfileCreateOrConnectWithoutProfilePhotoInput = {
    where: LabProfileWhereUniqueInput
    create: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput>
  }

  export type LabProfileCreateManyProfilePhotoInputEnvelope = {
    data: LabProfileCreateManyProfilePhotoInput | LabProfileCreateManyProfilePhotoInput[]
  }

  export type ContentCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    order: number
    lab: LabCreateNestedOneWithoutContentInput
    modules?: ModuleCreateNestedManyWithoutContentInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForContentInput
  }

  export type ContentUncheckedCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
    modules?: ModuleUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutThumbnailInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput>
  }

  export type ContentCreateManyThumbnailInputEnvelope = {
    data: ContentCreateManyThumbnailInput | ContentCreateManyThumbnailInput[]
  }

  export type ModuleCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    content: ContentCreateNestedOneWithoutModulesInput
    classes?: ClassCreateNestedManyWithoutModuleInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForModuleInput
  }

  export type ModuleUncheckedCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutThumbnailInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput>
  }

  export type ModuleCreateManyThumbnailInputEnvelope = {
    data: ModuleCreateManyThumbnailInput | ModuleCreateManyThumbnailInput[]
  }

  export type ClassCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    module: ModuleCreateNestedOneWithoutClassesInput
    video?: VideoCreateNestedOneWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    moduleId: string
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type ClassCreateOrConnectWithoutThumbnailInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput>
  }

  export type ClassCreateManyThumbnailInputEnvelope = {
    data: ClassCreateManyThumbnailInput | ClassCreateManyThumbnailInput[]
  }

  export type UserProfileUpsertWithWhereUniqueWithoutProfilePhotoInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutProfilePhotoInput, UserProfileUncheckedUpdateWithoutProfilePhotoInput>
    create: XOR<UserProfileCreateWithoutProfilePhotoInput, UserProfileUncheckedCreateWithoutProfilePhotoInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutProfilePhotoInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutProfilePhotoInput, UserProfileUncheckedUpdateWithoutProfilePhotoInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutProfilePhotoInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutProfilePhotoInput>
  }

  export type UserProfileScalarWhereInput = {
    AND?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    OR?: UserProfileScalarWhereInput[]
    NOT?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    bio?: StringNullableFilter<"UserProfile"> | string | null
    instagram?: StringNullableFilter<"UserProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"UserProfile"> | string | null
  }

  export type LabProfileUpsertWithWhereUniqueWithoutProfilePhotoInput = {
    where: LabProfileWhereUniqueInput
    update: XOR<LabProfileUpdateWithoutProfilePhotoInput, LabProfileUncheckedUpdateWithoutProfilePhotoInput>
    create: XOR<LabProfileCreateWithoutProfilePhotoInput, LabProfileUncheckedCreateWithoutProfilePhotoInput>
  }

  export type LabProfileUpdateWithWhereUniqueWithoutProfilePhotoInput = {
    where: LabProfileWhereUniqueInput
    data: XOR<LabProfileUpdateWithoutProfilePhotoInput, LabProfileUncheckedUpdateWithoutProfilePhotoInput>
  }

  export type LabProfileUpdateManyWithWhereWithoutProfilePhotoInput = {
    where: LabProfileScalarWhereInput
    data: XOR<LabProfileUpdateManyMutationInput, LabProfileUncheckedUpdateManyWithoutProfilePhotoInput>
  }

  export type LabProfileScalarWhereInput = {
    AND?: LabProfileScalarWhereInput | LabProfileScalarWhereInput[]
    OR?: LabProfileScalarWhereInput[]
    NOT?: LabProfileScalarWhereInput | LabProfileScalarWhereInput[]
    createdAt?: DateTimeFilter<"LabProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LabProfile"> | Date | string
    id?: StringFilter<"LabProfile"> | string
    labId?: StringFilter<"LabProfile"> | string
    bio?: StringNullableFilter<"LabProfile"> | string | null
    instagram?: StringNullableFilter<"LabProfile"> | string | null
    profilePhotoId?: StringNullableFilter<"LabProfile"> | string | null
    slug?: StringNullableFilter<"LabProfile"> | string | null
  }

  export type ContentUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutThumbnailInput, ContentUncheckedUpdateWithoutThumbnailInput>
    create: XOR<ContentCreateWithoutThumbnailInput, ContentUncheckedCreateWithoutThumbnailInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutThumbnailInput, ContentUncheckedUpdateWithoutThumbnailInput>
  }

  export type ContentUpdateManyWithWhereWithoutThumbnailInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type ContentScalarWhereInput = {
    AND?: ContentScalarWhereInput | ContentScalarWhereInput[]
    OR?: ContentScalarWhereInput[]
    NOT?: ContentScalarWhereInput | ContentScalarWhereInput[]
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    id?: StringFilter<"Content"> | string
    labId?: StringFilter<"Content"> | string
    name?: StringFilter<"Content"> | string
    shortDescription?: StringNullableFilter<"Content"> | string | null
    longDescription?: StringNullableFilter<"Content"> | string | null
    thumbnailId?: StringNullableFilter<"Content"> | string | null
    published?: BoolFilter<"Content"> | boolean
    previewVideoId?: StringNullableFilter<"Content"> | string | null
    order?: IntFilter<"Content"> | number
  }

  export type ModuleUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutThumbnailInput, ModuleUncheckedUpdateWithoutThumbnailInput>
    create: XOR<ModuleCreateWithoutThumbnailInput, ModuleUncheckedCreateWithoutThumbnailInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutThumbnailInput, ModuleUncheckedUpdateWithoutThumbnailInput>
  }

  export type ModuleUpdateManyWithWhereWithoutThumbnailInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    shortDescription?: StringNullableFilter<"Module"> | string | null
    longDescription?: StringNullableFilter<"Module"> | string | null
    thumbnailId?: StringNullableFilter<"Module"> | string | null
    contentId?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    published?: BoolFilter<"Module"> | boolean
    category?: StringNullableFilter<"Module"> | string | null
    previewVideoId?: StringNullableFilter<"Module"> | string | null
  }

  export type ClassUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutThumbnailInput, ClassUncheckedUpdateWithoutThumbnailInput>
    create: XOR<ClassCreateWithoutThumbnailInput, ClassUncheckedCreateWithoutThumbnailInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutThumbnailInput, ClassUncheckedUpdateWithoutThumbnailInput>
  }

  export type ClassUpdateManyWithWhereWithoutThumbnailInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    shortDescription?: StringNullableFilter<"Class"> | string | null
    longDescription?: StringNullableFilter<"Class"> | string | null
    thumbnailId?: StringNullableFilter<"Class"> | string | null
    moduleId?: StringFilter<"Class"> | string
    order?: IntFilter<"Class"> | number
    published?: BoolFilter<"Class"> | boolean
    videoId?: StringNullableFilter<"Class"> | string | null
    category?: StringNullableFilter<"Class"> | string | null
  }

  export type ContentCreateWithoutPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    order: number
    lab: LabCreateNestedOneWithoutContentInput
    thumbnail?: ImageCreateNestedOneWithoutContentsInput
    modules?: ModuleCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    order: number
    modules?: ModuleUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutPreviewVideoInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput>
  }

  export type ContentCreateManyPreviewVideoInputEnvelope = {
    data: ContentCreateManyPreviewVideoInput | ContentCreateManyPreviewVideoInput[]
  }

  export type ModuleCreateWithoutPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutModulesInput
    content: ContentCreateNestedOneWithoutModulesInput
    classes?: ClassCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutPreviewVideoInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput>
  }

  export type ModuleCreateManyPreviewVideoInputEnvelope = {
    data: ModuleCreateManyPreviewVideoInput | ModuleCreateManyPreviewVideoInput[]
  }

  export type ClassCreateWithoutVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutClassesInput
    module: ModuleCreateNestedOneWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    moduleId: string
    order: number
    published: boolean
    category?: string | null
  }

  export type ClassCreateOrConnectWithoutVideoInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput>
  }

  export type ClassCreateManyVideoInputEnvelope = {
    data: ClassCreateManyVideoInput | ClassCreateManyVideoInput[]
  }

  export type ContentUpsertWithWhereUniqueWithoutPreviewVideoInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutPreviewVideoInput, ContentUncheckedUpdateWithoutPreviewVideoInput>
    create: XOR<ContentCreateWithoutPreviewVideoInput, ContentUncheckedCreateWithoutPreviewVideoInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutPreviewVideoInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutPreviewVideoInput, ContentUncheckedUpdateWithoutPreviewVideoInput>
  }

  export type ContentUpdateManyWithWhereWithoutPreviewVideoInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutPreviewVideoInput>
  }

  export type ModuleUpsertWithWhereUniqueWithoutPreviewVideoInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutPreviewVideoInput, ModuleUncheckedUpdateWithoutPreviewVideoInput>
    create: XOR<ModuleCreateWithoutPreviewVideoInput, ModuleUncheckedCreateWithoutPreviewVideoInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutPreviewVideoInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutPreviewVideoInput, ModuleUncheckedUpdateWithoutPreviewVideoInput>
  }

  export type ModuleUpdateManyWithWhereWithoutPreviewVideoInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutPreviewVideoInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutVideoInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutVideoInput, ClassUncheckedUpdateWithoutVideoInput>
    create: XOR<ClassCreateWithoutVideoInput, ClassUncheckedCreateWithoutVideoInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutVideoInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutVideoInput, ClassUncheckedUpdateWithoutVideoInput>
  }

  export type ClassUpdateManyWithWhereWithoutVideoInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutVideoInput>
  }

  export type UserProfileCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    profilePhoto?: ImageCreateNestedOneWithoutUserProfilesInput
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserLabJoinCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    lab: LabCreateNestedOneWithoutCommunityInput
    userLabRoles?: UserLabRoleCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    labId: string
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinCreateOrConnectWithoutUserInput = {
    where: UserLabJoinWhereUniqueInput
    create: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput>
  }

  export type UserLabJoinCreateManyUserInputEnvelope = {
    data: UserLabJoinCreateManyUserInput | UserLabJoinCreateManyUserInput[]
  }

  export type LabCreateWithoutOwnersInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutOwnersInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutOwnersInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput>
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: ImageUpdateOneWithoutUserProfilesNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLabJoinUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLabJoinWhereUniqueInput
    update: XOR<UserLabJoinUpdateWithoutUserInput, UserLabJoinUncheckedUpdateWithoutUserInput>
    create: XOR<UserLabJoinCreateWithoutUserInput, UserLabJoinUncheckedCreateWithoutUserInput>
  }

  export type UserLabJoinUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLabJoinWhereUniqueInput
    data: XOR<UserLabJoinUpdateWithoutUserInput, UserLabJoinUncheckedUpdateWithoutUserInput>
  }

  export type UserLabJoinUpdateManyWithWhereWithoutUserInput = {
    where: UserLabJoinScalarWhereInput
    data: XOR<UserLabJoinUpdateManyMutationInput, UserLabJoinUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLabJoinScalarWhereInput = {
    AND?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
    OR?: UserLabJoinScalarWhereInput[]
    NOT?: UserLabJoinScalarWhereInput | UserLabJoinScalarWhereInput[]
    createdAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabJoin"> | Date | string
    userId?: StringFilter<"UserLabJoin"> | string
    labId?: StringFilter<"UserLabJoin"> | string
  }

  export type LabUpsertWithWhereUniqueWithoutOwnersInput = {
    where: LabWhereUniqueInput
    update: XOR<LabUpdateWithoutOwnersInput, LabUncheckedUpdateWithoutOwnersInput>
    create: XOR<LabCreateWithoutOwnersInput, LabUncheckedCreateWithoutOwnersInput>
  }

  export type LabUpdateWithWhereUniqueWithoutOwnersInput = {
    where: LabWhereUniqueInput
    data: XOR<LabUpdateWithoutOwnersInput, LabUncheckedUpdateWithoutOwnersInput>
  }

  export type LabUpdateManyWithWhereWithoutOwnersInput = {
    where: LabScalarWhereInput
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyWithoutOwnersInput>
  }

  export type LabScalarWhereInput = {
    AND?: LabScalarWhereInput | LabScalarWhereInput[]
    OR?: LabScalarWhereInput[]
    NOT?: LabScalarWhereInput | LabScalarWhereInput[]
    published?: BoolFilter<"Lab"> | boolean
    createdAt?: DateTimeFilter<"Lab"> | Date | string
    updatedAt?: DateTimeFilter<"Lab"> | Date | string
    id?: StringFilter<"Lab"> | string
    name?: StringFilter<"Lab"> | string
  }

  export type UserCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    labs?: UserLabJoinCreateNestedManyWithoutUserInput
    ownedLabs?: LabCreateNestedManyWithoutOwnersInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    labs?: UserLabJoinUncheckedCreateNestedManyWithoutUserInput
    ownedLabs?: LabUncheckedCreateNestedManyWithoutOwnersInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type ImageCreateWithoutUserProfilesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    labProfiles?: LabProfileCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentCreateNestedManyWithoutThumbnailInput
    modules?: ModuleCreateNestedManyWithoutThumbnailInput
    classes?: ClassCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateWithoutUserProfilesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    labProfiles?: LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentUncheckedCreateNestedManyWithoutThumbnailInput
    modules?: ModuleUncheckedCreateNestedManyWithoutThumbnailInput
    classes?: ClassUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageCreateOrConnectWithoutUserProfilesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUserProfilesInput, ImageUncheckedCreateWithoutUserProfilesInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    labs?: UserLabJoinUpdateManyWithoutUserNestedInput
    ownedLabs?: LabUpdateManyWithoutOwnersNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    labs?: UserLabJoinUncheckedUpdateManyWithoutUserNestedInput
    ownedLabs?: LabUncheckedUpdateManyWithoutOwnersNestedInput
  }

  export type ImageUpsertWithoutUserProfilesInput = {
    update: XOR<ImageUpdateWithoutUserProfilesInput, ImageUncheckedUpdateWithoutUserProfilesInput>
    create: XOR<ImageCreateWithoutUserProfilesInput, ImageUncheckedCreateWithoutUserProfilesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutUserProfilesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutUserProfilesInput, ImageUncheckedUpdateWithoutUserProfilesInput>
  }

  export type ImageUpdateWithoutUserProfilesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    labProfiles?: LabProfileUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateWithoutUserProfilesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    labProfiles?: LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUncheckedUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type LabProfileCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    slug?: string | null
    profilePhoto?: ImageCreateNestedOneWithoutLabProfilesInput
  }

  export type LabProfileUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    bio?: string | null
    instagram?: string | null
    profilePhotoId?: string | null
    slug?: string | null
  }

  export type LabProfileCreateOrConnectWithoutLabInput = {
    where: LabProfileWhereUniqueInput
    create: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
  }

  export type UserCreateWithoutOwnedLabsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    labs?: UserLabJoinCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedLabsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    labs?: UserLabJoinUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedLabsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput>
  }

  export type UserLabJoinCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLabsInput
    userLabRoles?: UserLabRoleCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutUserLabJoinInput
  }

  export type UserLabJoinCreateOrConnectWithoutLabInput = {
    where: UserLabJoinWhereUniqueInput
    create: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput>
  }

  export type UserLabJoinCreateManyLabInputEnvelope = {
    data: UserLabJoinCreateManyLabInput | UserLabJoinCreateManyLabInput[]
  }

  export type RoleCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    userLabRoles?: UserLabRoleCreateNestedManyWithoutRoleInput
    privileges?: RolePrivilegeJoinCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutRoleInput
    privileges?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutLabInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput>
  }

  export type RoleCreateManyLabInputEnvelope = {
    data: RoleCreateManyLabInput | RoleCreateManyLabInput[]
  }

  export type PrivilegeCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
    roles?: RolePrivilegeJoinCreateNestedManyWithoutPrivilegeInput
    labPermissions?: LabPermissionCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
    roles?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutPrivilegeInput
    labPermissions?: LabPermissionUncheckedCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeCreateOrConnectWithoutLabInput = {
    where: PrivilegeWhereUniqueInput
    create: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput>
  }

  export type PrivilegeCreateManyLabInputEnvelope = {
    data: PrivilegeCreateManyLabInput | PrivilegeCreateManyLabInput[]
  }

  export type ContentCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    order: number
    thumbnail?: ImageCreateNestedOneWithoutContentsInput
    modules?: ModuleCreateNestedManyWithoutContentInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForContentInput
  }

  export type ContentUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
    modules?: ModuleUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutLabInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput>
  }

  export type ContentCreateManyLabInputEnvelope = {
    data: ContentCreateManyLabInput | ContentCreateManyLabInput[]
  }

  export type LabPermissionCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    type: string
    privileges?: PrivilegeCreateNestedManyWithoutLabPermissionsInput
  }

  export type LabPermissionUncheckedCreateWithoutLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    type: string
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabPermissionsInput
  }

  export type LabPermissionCreateOrConnectWithoutLabInput = {
    where: LabPermissionWhereUniqueInput
    create: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput>
  }

  export type LabPermissionCreateManyLabInputEnvelope = {
    data: LabPermissionCreateManyLabInput | LabPermissionCreateManyLabInput[]
  }

  export type LabProfileUpsertWithoutLabInput = {
    update: XOR<LabProfileUpdateWithoutLabInput, LabProfileUncheckedUpdateWithoutLabInput>
    create: XOR<LabProfileCreateWithoutLabInput, LabProfileUncheckedCreateWithoutLabInput>
    where?: LabProfileWhereInput
  }

  export type LabProfileUpdateToOneWithWhereWithoutLabInput = {
    where?: LabProfileWhereInput
    data: XOR<LabProfileUpdateWithoutLabInput, LabProfileUncheckedUpdateWithoutLabInput>
  }

  export type LabProfileUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: ImageUpdateOneWithoutLabProfilesNestedInput
  }

  export type LabProfileUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutOwnedLabsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOwnedLabsInput, UserUncheckedUpdateWithoutOwnedLabsInput>
    create: XOR<UserCreateWithoutOwnedLabsInput, UserUncheckedCreateWithoutOwnedLabsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOwnedLabsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOwnedLabsInput, UserUncheckedUpdateWithoutOwnedLabsInput>
  }

  export type UserUpdateManyWithWhereWithoutOwnedLabsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOwnedLabsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
  }

  export type UserLabJoinUpsertWithWhereUniqueWithoutLabInput = {
    where: UserLabJoinWhereUniqueInput
    update: XOR<UserLabJoinUpdateWithoutLabInput, UserLabJoinUncheckedUpdateWithoutLabInput>
    create: XOR<UserLabJoinCreateWithoutLabInput, UserLabJoinUncheckedCreateWithoutLabInput>
  }

  export type UserLabJoinUpdateWithWhereUniqueWithoutLabInput = {
    where: UserLabJoinWhereUniqueInput
    data: XOR<UserLabJoinUpdateWithoutLabInput, UserLabJoinUncheckedUpdateWithoutLabInput>
  }

  export type UserLabJoinUpdateManyWithWhereWithoutLabInput = {
    where: UserLabJoinScalarWhereInput
    data: XOR<UserLabJoinUpdateManyMutationInput, UserLabJoinUncheckedUpdateManyWithoutLabInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutLabInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutLabInput, RoleUncheckedUpdateWithoutLabInput>
    create: XOR<RoleCreateWithoutLabInput, RoleUncheckedCreateWithoutLabInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutLabInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutLabInput, RoleUncheckedUpdateWithoutLabInput>
  }

  export type RoleUpdateManyWithWhereWithoutLabInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutLabInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    shortDescription?: StringNullableFilter<"Role"> | string | null
    longDescription?: StringNullableFilter<"Role"> | string | null
    labId?: StringFilter<"Role"> | string
    public?: BoolFilter<"Role"> | boolean
    priority?: IntFilter<"Role"> | number
    isTeamRole?: BoolFilter<"Role"> | boolean
  }

  export type PrivilegeUpsertWithWhereUniqueWithoutLabInput = {
    where: PrivilegeWhereUniqueInput
    update: XOR<PrivilegeUpdateWithoutLabInput, PrivilegeUncheckedUpdateWithoutLabInput>
    create: XOR<PrivilegeCreateWithoutLabInput, PrivilegeUncheckedCreateWithoutLabInput>
  }

  export type PrivilegeUpdateWithWhereUniqueWithoutLabInput = {
    where: PrivilegeWhereUniqueInput
    data: XOR<PrivilegeUpdateWithoutLabInput, PrivilegeUncheckedUpdateWithoutLabInput>
  }

  export type PrivilegeUpdateManyWithWhereWithoutLabInput = {
    where: PrivilegeScalarWhereInput
    data: XOR<PrivilegeUpdateManyMutationInput, PrivilegeUncheckedUpdateManyWithoutLabInput>
  }

  export type PrivilegeScalarWhereInput = {
    AND?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
    OR?: PrivilegeScalarWhereInput[]
    NOT?: PrivilegeScalarWhereInput | PrivilegeScalarWhereInput[]
    createdAt?: DateTimeFilter<"Privilege"> | Date | string
    updatedAt?: DateTimeFilter<"Privilege"> | Date | string
    id?: StringFilter<"Privilege"> | string
    name?: StringFilter<"Privilege"> | string
    longDescription?: StringNullableFilter<"Privilege"> | string | null
    shortDescription?: StringFilter<"Privilege"> | string
    labId?: StringFilter<"Privilege"> | string
    public?: BoolFilter<"Privilege"> | boolean
  }

  export type ContentUpsertWithWhereUniqueWithoutLabInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutLabInput, ContentUncheckedUpdateWithoutLabInput>
    create: XOR<ContentCreateWithoutLabInput, ContentUncheckedCreateWithoutLabInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutLabInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutLabInput, ContentUncheckedUpdateWithoutLabInput>
  }

  export type ContentUpdateManyWithWhereWithoutLabInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutLabInput>
  }

  export type LabPermissionUpsertWithWhereUniqueWithoutLabInput = {
    where: LabPermissionWhereUniqueInput
    update: XOR<LabPermissionUpdateWithoutLabInput, LabPermissionUncheckedUpdateWithoutLabInput>
    create: XOR<LabPermissionCreateWithoutLabInput, LabPermissionUncheckedCreateWithoutLabInput>
  }

  export type LabPermissionUpdateWithWhereUniqueWithoutLabInput = {
    where: LabPermissionWhereUniqueInput
    data: XOR<LabPermissionUpdateWithoutLabInput, LabPermissionUncheckedUpdateWithoutLabInput>
  }

  export type LabPermissionUpdateManyWithWhereWithoutLabInput = {
    where: LabPermissionScalarWhereInput
    data: XOR<LabPermissionUpdateManyMutationInput, LabPermissionUncheckedUpdateManyWithoutLabInput>
  }

  export type LabPermissionScalarWhereInput = {
    AND?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
    OR?: LabPermissionScalarWhereInput[]
    NOT?: LabPermissionScalarWhereInput | LabPermissionScalarWhereInput[]
    createdAt?: DateTimeFilter<"LabPermission"> | Date | string
    updatedAt?: DateTimeFilter<"LabPermission"> | Date | string
    id?: StringFilter<"LabPermission"> | string
    name?: StringFilter<"LabPermission"> | string
    labId?: StringFilter<"LabPermission"> | string
    type?: StringFilter<"LabPermission"> | string
  }

  export type LabCreateWithoutProfileInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutProfileInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutProfileInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutProfileInput, LabUncheckedCreateWithoutProfileInput>
  }

  export type ImageCreateWithoutLabProfilesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentCreateNestedManyWithoutThumbnailInput
    modules?: ModuleCreateNestedManyWithoutThumbnailInput
    classes?: ClassCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateWithoutLabProfilesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentUncheckedCreateNestedManyWithoutThumbnailInput
    modules?: ModuleUncheckedCreateNestedManyWithoutThumbnailInput
    classes?: ClassUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageCreateOrConnectWithoutLabProfilesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutLabProfilesInput, ImageUncheckedCreateWithoutLabProfilesInput>
  }

  export type LabUpsertWithoutProfileInput = {
    update: XOR<LabUpdateWithoutProfileInput, LabUncheckedUpdateWithoutProfileInput>
    create: XOR<LabCreateWithoutProfileInput, LabUncheckedCreateWithoutProfileInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutProfileInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutProfileInput, LabUncheckedUpdateWithoutProfileInput>
  }

  export type LabUpdateWithoutProfileInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutProfileInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type ImageUpsertWithoutLabProfilesInput = {
    update: XOR<ImageUpdateWithoutLabProfilesInput, ImageUncheckedUpdateWithoutLabProfilesInput>
    create: XOR<ImageCreateWithoutLabProfilesInput, ImageUncheckedCreateWithoutLabProfilesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutLabProfilesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutLabProfilesInput, ImageUncheckedUpdateWithoutLabProfilesInput>
  }

  export type ImageUpdateWithoutLabProfilesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateWithoutLabProfilesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUncheckedUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type UserCreateWithoutLabsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    ownedLabs?: LabCreateNestedManyWithoutOwnersInput
  }

  export type UserUncheckedCreateWithoutLabsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    email: string
    displayName?: string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    ownedLabs?: LabUncheckedCreateNestedManyWithoutOwnersInput
  }

  export type UserCreateOrConnectWithoutLabsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabsInput, UserUncheckedCreateWithoutLabsInput>
  }

  export type LabCreateWithoutCommunityInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutCommunityInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutCommunityInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutCommunityInput, LabUncheckedCreateWithoutCommunityInput>
  }

  export type UserLabRoleCreateWithoutUserLabJoinInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    role: RoleCreateNestedOneWithoutUserLabRolesInput
  }

  export type UserLabRoleUncheckedCreateWithoutUserLabJoinInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    expiresAt?: Date | string | null
  }

  export type UserLabRoleCreateOrConnectWithoutUserLabJoinInput = {
    where: UserLabRoleWhereUniqueInput
    create: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput>
  }

  export type UserLabRoleCreateManyUserLabJoinInputEnvelope = {
    data: UserLabRoleCreateManyUserLabJoinInput | UserLabRoleCreateManyUserLabJoinInput[]
  }

  export type UserUpsertWithoutLabsInput = {
    update: XOR<UserUpdateWithoutLabsInput, UserUncheckedUpdateWithoutLabsInput>
    create: XOR<UserCreateWithoutLabsInput, UserUncheckedCreateWithoutLabsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabsInput, UserUncheckedUpdateWithoutLabsInput>
  }

  export type UserUpdateWithoutLabsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    ownedLabs?: LabUpdateManyWithoutOwnersNestedInput
  }

  export type UserUncheckedUpdateWithoutLabsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    ownedLabs?: LabUncheckedUpdateManyWithoutOwnersNestedInput
  }

  export type LabUpsertWithoutCommunityInput = {
    update: XOR<LabUpdateWithoutCommunityInput, LabUncheckedUpdateWithoutCommunityInput>
    create: XOR<LabCreateWithoutCommunityInput, LabUncheckedCreateWithoutCommunityInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutCommunityInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutCommunityInput, LabUncheckedUpdateWithoutCommunityInput>
  }

  export type LabUpdateWithoutCommunityInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutCommunityInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type UserLabRoleUpsertWithWhereUniqueWithoutUserLabJoinInput = {
    where: UserLabRoleWhereUniqueInput
    update: XOR<UserLabRoleUpdateWithoutUserLabJoinInput, UserLabRoleUncheckedUpdateWithoutUserLabJoinInput>
    create: XOR<UserLabRoleCreateWithoutUserLabJoinInput, UserLabRoleUncheckedCreateWithoutUserLabJoinInput>
  }

  export type UserLabRoleUpdateWithWhereUniqueWithoutUserLabJoinInput = {
    where: UserLabRoleWhereUniqueInput
    data: XOR<UserLabRoleUpdateWithoutUserLabJoinInput, UserLabRoleUncheckedUpdateWithoutUserLabJoinInput>
  }

  export type UserLabRoleUpdateManyWithWhereWithoutUserLabJoinInput = {
    where: UserLabRoleScalarWhereInput
    data: XOR<UserLabRoleUpdateManyMutationInput, UserLabRoleUncheckedUpdateManyWithoutUserLabJoinInput>
  }

  export type UserLabRoleScalarWhereInput = {
    AND?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
    OR?: UserLabRoleScalarWhereInput[]
    NOT?: UserLabRoleScalarWhereInput | UserLabRoleScalarWhereInput[]
    createdAt?: DateTimeFilter<"UserLabRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserLabRole"> | Date | string
    userId?: StringFilter<"UserLabRole"> | string
    labId?: StringFilter<"UserLabRole"> | string
    roleId?: StringFilter<"UserLabRole"> | string
    expiresAt?: DateTimeNullableFilter<"UserLabRole"> | Date | string | null
  }

  export type LabCreateWithoutRolesInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutRolesInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutRolesInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutRolesInput, LabUncheckedCreateWithoutRolesInput>
  }

  export type UserLabRoleCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    userLabJoin: UserLabJoinCreateNestedOneWithoutUserLabRolesInput
  }

  export type UserLabRoleUncheckedCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    expiresAt?: Date | string | null
  }

  export type UserLabRoleCreateOrConnectWithoutRoleInput = {
    where: UserLabRoleWhereUniqueInput
    create: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserLabRoleCreateManyRoleInputEnvelope = {
    data: UserLabRoleCreateManyRoleInput | UserLabRoleCreateManyRoleInput[]
  }

  export type RolePrivilegeJoinCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    privilege: PrivilegeCreateNestedOneWithoutRolesInput
  }

  export type RolePrivilegeJoinUncheckedCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    privilegeId: string
    order?: number | null
  }

  export type RolePrivilegeJoinCreateOrConnectWithoutRoleInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    create: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput>
  }

  export type RolePrivilegeJoinCreateManyRoleInputEnvelope = {
    data: RolePrivilegeJoinCreateManyRoleInput | RolePrivilegeJoinCreateManyRoleInput[]
  }

  export type LabUpsertWithoutRolesInput = {
    update: XOR<LabUpdateWithoutRolesInput, LabUncheckedUpdateWithoutRolesInput>
    create: XOR<LabCreateWithoutRolesInput, LabUncheckedCreateWithoutRolesInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutRolesInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutRolesInput, LabUncheckedUpdateWithoutRolesInput>
  }

  export type LabUpdateWithoutRolesInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutRolesInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type UserLabRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserLabRoleWhereUniqueInput
    update: XOR<UserLabRoleUpdateWithoutRoleInput, UserLabRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserLabRoleCreateWithoutRoleInput, UserLabRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserLabRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserLabRoleWhereUniqueInput
    data: XOR<UserLabRoleUpdateWithoutRoleInput, UserLabRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserLabRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserLabRoleScalarWhereInput
    data: XOR<UserLabRoleUpdateManyMutationInput, UserLabRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePrivilegeJoinUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    update: XOR<RolePrivilegeJoinUpdateWithoutRoleInput, RolePrivilegeJoinUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePrivilegeJoinCreateWithoutRoleInput, RolePrivilegeJoinUncheckedCreateWithoutRoleInput>
  }

  export type RolePrivilegeJoinUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    data: XOR<RolePrivilegeJoinUpdateWithoutRoleInput, RolePrivilegeJoinUncheckedUpdateWithoutRoleInput>
  }

  export type RolePrivilegeJoinUpdateManyWithWhereWithoutRoleInput = {
    where: RolePrivilegeJoinScalarWhereInput
    data: XOR<RolePrivilegeJoinUpdateManyMutationInput, RolePrivilegeJoinUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePrivilegeJoinScalarWhereInput = {
    AND?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
    OR?: RolePrivilegeJoinScalarWhereInput[]
    NOT?: RolePrivilegeJoinScalarWhereInput | RolePrivilegeJoinScalarWhereInput[]
    createdAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    updatedAt?: DateTimeFilter<"RolePrivilegeJoin"> | Date | string
    roleId?: StringFilter<"RolePrivilegeJoin"> | string
    privilegeId?: StringFilter<"RolePrivilegeJoin"> | string
    order?: IntNullableFilter<"RolePrivilegeJoin"> | number | null
  }

  export type UserLabJoinCreateWithoutUserLabRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLabsInput
    lab: LabCreateNestedOneWithoutCommunityInput
  }

  export type UserLabJoinUncheckedCreateWithoutUserLabRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    labId: string
  }

  export type UserLabJoinCreateOrConnectWithoutUserLabRolesInput = {
    where: UserLabJoinWhereUniqueInput
    create: XOR<UserLabJoinCreateWithoutUserLabRolesInput, UserLabJoinUncheckedCreateWithoutUserLabRolesInput>
  }

  export type RoleCreateWithoutUserLabRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    lab: LabCreateNestedOneWithoutRolesInput
    privileges?: RolePrivilegeJoinCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserLabRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    labId: string
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    privileges?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserLabRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserLabRolesInput, RoleUncheckedCreateWithoutUserLabRolesInput>
  }

  export type UserLabJoinUpsertWithoutUserLabRolesInput = {
    update: XOR<UserLabJoinUpdateWithoutUserLabRolesInput, UserLabJoinUncheckedUpdateWithoutUserLabRolesInput>
    create: XOR<UserLabJoinCreateWithoutUserLabRolesInput, UserLabJoinUncheckedCreateWithoutUserLabRolesInput>
    where?: UserLabJoinWhereInput
  }

  export type UserLabJoinUpdateToOneWithWhereWithoutUserLabRolesInput = {
    where?: UserLabJoinWhereInput
    data: XOR<UserLabJoinUpdateWithoutUserLabRolesInput, UserLabJoinUncheckedUpdateWithoutUserLabRolesInput>
  }

  export type UserLabJoinUpdateWithoutUserLabRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabsNestedInput
    lab?: LabUpdateOneRequiredWithoutCommunityNestedInput
  }

  export type UserLabJoinUncheckedUpdateWithoutUserLabRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpsertWithoutUserLabRolesInput = {
    update: XOR<RoleUpdateWithoutUserLabRolesInput, RoleUncheckedUpdateWithoutUserLabRolesInput>
    create: XOR<RoleCreateWithoutUserLabRolesInput, RoleUncheckedCreateWithoutUserLabRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserLabRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserLabRolesInput, RoleUncheckedUpdateWithoutUserLabRolesInput>
  }

  export type RoleUpdateWithoutUserLabRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutRolesNestedInput
    privileges?: RolePrivilegeJoinUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserLabRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    privileges?: RolePrivilegeJoinUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type LabCreateWithoutPrivilegesInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutPrivilegesInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutPrivilegesInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutPrivilegesInput, LabUncheckedCreateWithoutPrivilegesInput>
  }

  export type RolePrivilegeJoinCreateWithoutPrivilegeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    role: RoleCreateNestedOneWithoutPrivilegesInput
  }

  export type RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    order?: number | null
  }

  export type RolePrivilegeJoinCreateOrConnectWithoutPrivilegeInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    create: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput>
  }

  export type RolePrivilegeJoinCreateManyPrivilegeInputEnvelope = {
    data: RolePrivilegeJoinCreateManyPrivilegeInput | RolePrivilegeJoinCreateManyPrivilegeInput[]
  }

  export type LabPermissionCreateWithoutPrivilegesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    type: string
    lab: LabCreateNestedOneWithoutPermissionsInput
  }

  export type LabPermissionUncheckedCreateWithoutPrivilegesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    labId: string
    type: string
  }

  export type LabPermissionCreateOrConnectWithoutPrivilegesInput = {
    where: LabPermissionWhereUniqueInput
    create: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput>
  }

  export type LabUpsertWithoutPrivilegesInput = {
    update: XOR<LabUpdateWithoutPrivilegesInput, LabUncheckedUpdateWithoutPrivilegesInput>
    create: XOR<LabCreateWithoutPrivilegesInput, LabUncheckedCreateWithoutPrivilegesInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutPrivilegesInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutPrivilegesInput, LabUncheckedUpdateWithoutPrivilegesInput>
  }

  export type LabUpdateWithoutPrivilegesInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutPrivilegesInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type RolePrivilegeJoinUpsertWithWhereUniqueWithoutPrivilegeInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    update: XOR<RolePrivilegeJoinUpdateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedUpdateWithoutPrivilegeInput>
    create: XOR<RolePrivilegeJoinCreateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedCreateWithoutPrivilegeInput>
  }

  export type RolePrivilegeJoinUpdateWithWhereUniqueWithoutPrivilegeInput = {
    where: RolePrivilegeJoinWhereUniqueInput
    data: XOR<RolePrivilegeJoinUpdateWithoutPrivilegeInput, RolePrivilegeJoinUncheckedUpdateWithoutPrivilegeInput>
  }

  export type RolePrivilegeJoinUpdateManyWithWhereWithoutPrivilegeInput = {
    where: RolePrivilegeJoinScalarWhereInput
    data: XOR<RolePrivilegeJoinUpdateManyMutationInput, RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeInput>
  }

  export type LabPermissionUpsertWithWhereUniqueWithoutPrivilegesInput = {
    where: LabPermissionWhereUniqueInput
    update: XOR<LabPermissionUpdateWithoutPrivilegesInput, LabPermissionUncheckedUpdateWithoutPrivilegesInput>
    create: XOR<LabPermissionCreateWithoutPrivilegesInput, LabPermissionUncheckedCreateWithoutPrivilegesInput>
  }

  export type LabPermissionUpdateWithWhereUniqueWithoutPrivilegesInput = {
    where: LabPermissionWhereUniqueInput
    data: XOR<LabPermissionUpdateWithoutPrivilegesInput, LabPermissionUncheckedUpdateWithoutPrivilegesInput>
  }

  export type LabPermissionUpdateManyWithWhereWithoutPrivilegesInput = {
    where: LabPermissionScalarWhereInput
    data: XOR<LabPermissionUpdateManyMutationInput, LabPermissionUncheckedUpdateManyWithoutPrivilegesInput>
  }

  export type LabCreateWithoutPermissionsInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    content?: ContentCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutPermissionsInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    content?: ContentUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutPermissionsInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutPermissionsInput, LabUncheckedCreateWithoutPermissionsInput>
  }

  export type PrivilegeCreateWithoutLabPermissionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
    lab: LabCreateNestedOneWithoutPrivilegesInput
    roles?: RolePrivilegeJoinCreateNestedManyWithoutPrivilegeInput
  }

  export type PrivilegeUncheckedCreateWithoutLabPermissionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    labId: string
    public?: boolean
    roles?: RolePrivilegeJoinUncheckedCreateNestedManyWithoutPrivilegeInput
  }

  export type PrivilegeCreateOrConnectWithoutLabPermissionsInput = {
    where: PrivilegeWhereUniqueInput
    create: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput>
  }

  export type LabUpsertWithoutPermissionsInput = {
    update: XOR<LabUpdateWithoutPermissionsInput, LabUncheckedUpdateWithoutPermissionsInput>
    create: XOR<LabCreateWithoutPermissionsInput, LabUncheckedCreateWithoutPermissionsInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutPermissionsInput, LabUncheckedUpdateWithoutPermissionsInput>
  }

  export type LabUpdateWithoutPermissionsInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutPermissionsInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
  }

  export type PrivilegeUpsertWithWhereUniqueWithoutLabPermissionsInput = {
    where: PrivilegeWhereUniqueInput
    update: XOR<PrivilegeUpdateWithoutLabPermissionsInput, PrivilegeUncheckedUpdateWithoutLabPermissionsInput>
    create: XOR<PrivilegeCreateWithoutLabPermissionsInput, PrivilegeUncheckedCreateWithoutLabPermissionsInput>
  }

  export type PrivilegeUpdateWithWhereUniqueWithoutLabPermissionsInput = {
    where: PrivilegeWhereUniqueInput
    data: XOR<PrivilegeUpdateWithoutLabPermissionsInput, PrivilegeUncheckedUpdateWithoutLabPermissionsInput>
  }

  export type PrivilegeUpdateManyWithWhereWithoutLabPermissionsInput = {
    where: PrivilegeScalarWhereInput
    data: XOR<PrivilegeUpdateManyMutationInput, PrivilegeUncheckedUpdateManyWithoutLabPermissionsInput>
  }

  export type RoleCreateWithoutPrivilegesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    lab: LabCreateNestedOneWithoutRolesInput
    userLabRoles?: UserLabRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPrivilegesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    labId: string
    public?: boolean
    priority?: number
    isTeamRole?: boolean
    userLabRoles?: UserLabRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPrivilegesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPrivilegesInput, RoleUncheckedCreateWithoutPrivilegesInput>
  }

  export type PrivilegeCreateWithoutRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
    lab: LabCreateNestedOneWithoutPrivilegesInput
    labPermissions?: LabPermissionCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeUncheckedCreateWithoutRolesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    labId: string
    public?: boolean
    labPermissions?: LabPermissionUncheckedCreateNestedManyWithoutPrivilegesInput
  }

  export type PrivilegeCreateOrConnectWithoutRolesInput = {
    where: PrivilegeWhereUniqueInput
    create: XOR<PrivilegeCreateWithoutRolesInput, PrivilegeUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPrivilegesInput = {
    update: XOR<RoleUpdateWithoutPrivilegesInput, RoleUncheckedUpdateWithoutPrivilegesInput>
    create: XOR<RoleCreateWithoutPrivilegesInput, RoleUncheckedCreateWithoutPrivilegesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPrivilegesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPrivilegesInput, RoleUncheckedUpdateWithoutPrivilegesInput>
  }

  export type RoleUpdateWithoutPrivilegesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutRolesNestedInput
    userLabRoles?: UserLabRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPrivilegesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PrivilegeUpsertWithoutRolesInput = {
    update: XOR<PrivilegeUpdateWithoutRolesInput, PrivilegeUncheckedUpdateWithoutRolesInput>
    create: XOR<PrivilegeCreateWithoutRolesInput, PrivilegeUncheckedCreateWithoutRolesInput>
    where?: PrivilegeWhereInput
  }

  export type PrivilegeUpdateToOneWithWhereWithoutRolesInput = {
    where?: PrivilegeWhereInput
    data: XOR<PrivilegeUpdateWithoutRolesInput, PrivilegeUncheckedUpdateWithoutRolesInput>
  }

  export type PrivilegeUpdateWithoutRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutPrivilegesNestedInput
    labPermissions?: LabPermissionUpdateManyWithoutPrivilegesNestedInput
  }

  export type PrivilegeUncheckedUpdateWithoutRolesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    labPermissions?: LabPermissionUncheckedUpdateManyWithoutPrivilegesNestedInput
  }

  export type LabCreateWithoutContentInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileCreateNestedOneWithoutLabInput
    owners?: UserCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinCreateNestedManyWithoutLabInput
    roles?: RoleCreateNestedManyWithoutLabInput
    privileges?: PrivilegeCreateNestedManyWithoutLabInput
    permissions?: LabPermissionCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutContentInput = {
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    profile?: LabProfileUncheckedCreateNestedOneWithoutLabInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedLabsInput
    community?: UserLabJoinUncheckedCreateNestedManyWithoutLabInput
    roles?: RoleUncheckedCreateNestedManyWithoutLabInput
    privileges?: PrivilegeUncheckedCreateNestedManyWithoutLabInput
    permissions?: LabPermissionUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutContentInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutContentInput, LabUncheckedCreateWithoutContentInput>
  }

  export type ImageCreateWithoutContentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileCreateNestedManyWithoutProfilePhotoInput
    modules?: ModuleCreateNestedManyWithoutThumbnailInput
    classes?: ClassCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateWithoutContentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    modules?: ModuleUncheckedCreateNestedManyWithoutThumbnailInput
    classes?: ClassUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageCreateOrConnectWithoutContentsInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutContentsInput, ImageUncheckedCreateWithoutContentsInput>
  }

  export type ModuleCreateWithoutContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutModulesInput
    classes?: ClassCreateNestedManyWithoutModuleInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForModuleInput
  }

  export type ModuleUncheckedCreateWithoutContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
    classes?: ClassUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutContentInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput>
  }

  export type ModuleCreateManyContentInputEnvelope = {
    data: ModuleCreateManyContentInput | ModuleCreateManyContentInput[]
  }

  export type VideoCreateWithoutPreviewForContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForModule?: ModuleCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutPreviewForContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForModule?: ModuleUncheckedCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutPreviewForContentInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutPreviewForContentInput, VideoUncheckedCreateWithoutPreviewForContentInput>
  }

  export type LabUpsertWithoutContentInput = {
    update: XOR<LabUpdateWithoutContentInput, LabUncheckedUpdateWithoutContentInput>
    create: XOR<LabCreateWithoutContentInput, LabUncheckedCreateWithoutContentInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutContentInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutContentInput, LabUncheckedUpdateWithoutContentInput>
  }

  export type LabUpdateWithoutContentInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    owners?: UserUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutContentInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedLabsNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type ImageUpsertWithoutContentsInput = {
    update: XOR<ImageUpdateWithoutContentsInput, ImageUncheckedUpdateWithoutContentsInput>
    create: XOR<ImageCreateWithoutContentsInput, ImageUncheckedCreateWithoutContentsInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutContentsInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutContentsInput, ImageUncheckedUpdateWithoutContentsInput>
  }

  export type ImageUpdateWithoutContentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUpdateManyWithoutProfilePhotoNestedInput
    modules?: ModuleUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateWithoutContentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type ModuleUpsertWithWhereUniqueWithoutContentInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutContentInput, ModuleUncheckedUpdateWithoutContentInput>
    create: XOR<ModuleCreateWithoutContentInput, ModuleUncheckedCreateWithoutContentInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutContentInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutContentInput, ModuleUncheckedUpdateWithoutContentInput>
  }

  export type ModuleUpdateManyWithWhereWithoutContentInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutContentInput>
  }

  export type VideoUpsertWithoutPreviewForContentInput = {
    update: XOR<VideoUpdateWithoutPreviewForContentInput, VideoUncheckedUpdateWithoutPreviewForContentInput>
    create: XOR<VideoCreateWithoutPreviewForContentInput, VideoUncheckedCreateWithoutPreviewForContentInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutPreviewForContentInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutPreviewForContentInput, VideoUncheckedUpdateWithoutPreviewForContentInput>
  }

  export type VideoUpdateWithoutPreviewForContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForModule?: ModuleUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutPreviewForContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForModule?: ModuleUncheckedUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type ImageCreateWithoutModulesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentCreateNestedManyWithoutThumbnailInput
    classes?: ClassCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateWithoutModulesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentUncheckedCreateNestedManyWithoutThumbnailInput
    classes?: ClassUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageCreateOrConnectWithoutModulesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutModulesInput, ImageUncheckedCreateWithoutModulesInput>
  }

  export type ContentCreateWithoutModulesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    order: number
    lab: LabCreateNestedOneWithoutContentInput
    thumbnail?: ImageCreateNestedOneWithoutContentsInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForContentInput
  }

  export type ContentUncheckedCreateWithoutModulesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
  }

  export type ContentCreateOrConnectWithoutModulesInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutModulesInput, ContentUncheckedCreateWithoutModulesInput>
  }

  export type ClassCreateWithoutModuleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutClassesInput
    video?: VideoCreateNestedOneWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutModuleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type ClassCreateOrConnectWithoutModuleInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput>
  }

  export type ClassCreateManyModuleInputEnvelope = {
    data: ClassCreateManyModuleInput | ClassCreateManyModuleInput[]
  }

  export type VideoCreateWithoutPreviewForModuleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutPreviewForModuleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentUncheckedCreateNestedManyWithoutPreviewVideoInput
    classes?: ClassUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutPreviewForModuleInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutPreviewForModuleInput, VideoUncheckedCreateWithoutPreviewForModuleInput>
  }

  export type ImageUpsertWithoutModulesInput = {
    update: XOR<ImageUpdateWithoutModulesInput, ImageUncheckedUpdateWithoutModulesInput>
    create: XOR<ImageCreateWithoutModulesInput, ImageUncheckedCreateWithoutModulesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutModulesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutModulesInput, ImageUncheckedUpdateWithoutModulesInput>
  }

  export type ImageUpdateWithoutModulesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateWithoutModulesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUncheckedUpdateManyWithoutThumbnailNestedInput
    classes?: ClassUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type ContentUpsertWithoutModulesInput = {
    update: XOR<ContentUpdateWithoutModulesInput, ContentUncheckedUpdateWithoutModulesInput>
    create: XOR<ContentCreateWithoutModulesInput, ContentUncheckedCreateWithoutModulesInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutModulesInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutModulesInput, ContentUncheckedUpdateWithoutModulesInput>
  }

  export type ContentUpdateWithoutModulesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutContentNestedInput
    thumbnail?: ImageUpdateOneWithoutContentsNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutModulesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ClassUpsertWithWhereUniqueWithoutModuleInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutModuleInput, ClassUncheckedUpdateWithoutModuleInput>
    create: XOR<ClassCreateWithoutModuleInput, ClassUncheckedCreateWithoutModuleInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutModuleInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutModuleInput, ClassUncheckedUpdateWithoutModuleInput>
  }

  export type ClassUpdateManyWithWhereWithoutModuleInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutModuleInput>
  }

  export type VideoUpsertWithoutPreviewForModuleInput = {
    update: XOR<VideoUpdateWithoutPreviewForModuleInput, VideoUncheckedUpdateWithoutPreviewForModuleInput>
    create: XOR<VideoCreateWithoutPreviewForModuleInput, VideoUncheckedCreateWithoutPreviewForModuleInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutPreviewForModuleInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutPreviewForModuleInput, VideoUncheckedUpdateWithoutPreviewForModuleInput>
  }

  export type VideoUpdateWithoutPreviewForModuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutPreviewForModuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUncheckedUpdateManyWithoutPreviewVideoNestedInput
    classes?: ClassUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type ImageCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentCreateNestedManyWithoutThumbnailInput
    modules?: ModuleCreateNestedManyWithoutThumbnailInput
  }

  export type ImageUncheckedCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    width: number
    height: number
    size: bigint | number
    userProfiles?: UserProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    labProfiles?: LabProfileUncheckedCreateNestedManyWithoutProfilePhotoInput
    contents?: ContentUncheckedCreateNestedManyWithoutThumbnailInput
    modules?: ModuleUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type ImageCreateOrConnectWithoutClassesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutClassesInput, ImageUncheckedCreateWithoutClassesInput>
  }

  export type ModuleCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    order: number
    published: boolean
    category?: string | null
    thumbnail?: ImageCreateNestedOneWithoutModulesInput
    content: ContentCreateNestedOneWithoutModulesInput
    previewVideo?: VideoCreateNestedOneWithoutPreviewForModuleInput
  }

  export type ModuleUncheckedCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
  }

  export type ModuleCreateOrConnectWithoutClassesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
  }

  export type VideoCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentCreateNestedManyWithoutPreviewVideoInput
    previewForModule?: ModuleCreateNestedManyWithoutPreviewVideoInput
  }

  export type VideoUncheckedCreateWithoutClassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    storageRef: string
    displayName?: string | null
    durationMillis: number
    width?: number | null
    height?: number | null
    size: bigint | number
    previewForContent?: ContentUncheckedCreateNestedManyWithoutPreviewVideoInput
    previewForModule?: ModuleUncheckedCreateNestedManyWithoutPreviewVideoInput
  }

  export type VideoCreateOrConnectWithoutClassesInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutClassesInput, VideoUncheckedCreateWithoutClassesInput>
  }

  export type ImageUpsertWithoutClassesInput = {
    update: XOR<ImageUpdateWithoutClassesInput, ImageUncheckedUpdateWithoutClassesInput>
    create: XOR<ImageCreateWithoutClassesInput, ImageUncheckedCreateWithoutClassesInput>
    where?: ImageWhereInput
  }

  export type ImageUpdateToOneWithWhereWithoutClassesInput = {
    where?: ImageWhereInput
    data: XOR<ImageUpdateWithoutClassesInput, ImageUncheckedUpdateWithoutClassesInput>
  }

  export type ImageUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUpdateManyWithoutThumbnailNestedInput
  }

  export type ImageUncheckedUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    userProfiles?: UserProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    labProfiles?: LabProfileUncheckedUpdateManyWithoutProfilePhotoNestedInput
    contents?: ContentUncheckedUpdateManyWithoutThumbnailNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type ModuleUpsertWithoutClassesInput = {
    update: XOR<ModuleUpdateWithoutClassesInput, ModuleUncheckedUpdateWithoutClassesInput>
    create: XOR<ModuleCreateWithoutClassesInput, ModuleUncheckedCreateWithoutClassesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutClassesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutClassesInput, ModuleUncheckedUpdateWithoutClassesInput>
  }

  export type ModuleUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutModulesNestedInput
    content?: ContentUpdateOneRequiredWithoutModulesNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoUpsertWithoutClassesInput = {
    update: XOR<VideoUpdateWithoutClassesInput, VideoUncheckedUpdateWithoutClassesInput>
    create: XOR<VideoCreateWithoutClassesInput, VideoUncheckedCreateWithoutClassesInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutClassesInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutClassesInput, VideoUncheckedUpdateWithoutClassesInput>
  }

  export type VideoUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUpdateManyWithoutPreviewVideoNestedInput
    previewForModule?: ModuleUpdateManyWithoutPreviewVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutClassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    storageRef?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    durationMillis?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    previewForContent?: ContentUncheckedUpdateManyWithoutPreviewVideoNestedInput
    previewForModule?: ModuleUncheckedUpdateManyWithoutPreviewVideoNestedInput
  }

  export type UserProfileCreateManyProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    userId: string
    bio?: string | null
    instagram?: string | null
  }

  export type LabProfileCreateManyProfilePhotoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    bio?: string | null
    instagram?: string | null
    slug?: string | null
  }

  export type ContentCreateManyThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
  }

  export type ModuleCreateManyThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
  }

  export type ClassCreateManyThumbnailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    moduleId: string
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type UserProfileUpdateWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUncheckedUpdateManyWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabProfileUpdateWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    lab?: LabUpdateOneRequiredWithoutProfileNestedInput
  }

  export type LabProfileUncheckedUpdateWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabProfileUncheckedUpdateManyWithoutProfilePhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutContentNestedInput
    modules?: ModuleUpdateManyWithoutContentNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    modules?: ModuleUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    content?: ContentUpdateOneRequiredWithoutModulesNestedInput
    classes?: ClassUpdateManyWithoutModuleNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    module?: ModuleUpdateOneRequiredWithoutClassesNestedInput
    video?: VideoUpdateOneWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUncheckedUpdateManyWithoutThumbnailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentCreateManyPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    labId: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    order: number
  }

  export type ModuleCreateManyPreviewVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    contentId: string
    order: number
    published: boolean
    category?: string | null
  }

  export type ClassCreateManyVideoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    moduleId: string
    order: number
    published: boolean
    category?: string | null
  }

  export type ContentUpdateWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutContentNestedInput
    thumbnail?: ImageUpdateOneWithoutContentsNestedInput
    modules?: ModuleUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    modules?: ModuleUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleUpdateWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutModulesNestedInput
    content?: ContentUpdateOneRequiredWithoutModulesNestedInput
    classes?: ClassUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutPreviewVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUpdateWithoutVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutClassesNestedInput
    module?: ModuleUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUncheckedUpdateManyWithoutVideoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLabJoinCreateManyUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    labId: string
  }

  export type UserLabJoinUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: LabUpdateOneRequiredWithoutCommunityNestedInput
    userLabRoles?: UserLabRoleUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labId?: StringFieldUpdateOperationsInput | string
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labId?: StringFieldUpdateOperationsInput | string
  }

  export type LabUpdateWithoutOwnersInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUpdateOneWithoutLabNestedInput
    community?: UserLabJoinUpdateManyWithoutLabNestedInput
    roles?: RoleUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUpdateManyWithoutLabNestedInput
    content?: ContentUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutOwnersInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: LabProfileUncheckedUpdateOneWithoutLabNestedInput
    community?: UserLabJoinUncheckedUpdateManyWithoutLabNestedInput
    roles?: RoleUncheckedUpdateManyWithoutLabNestedInput
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabNestedInput
    content?: ContentUncheckedUpdateManyWithoutLabNestedInput
    permissions?: LabPermissionUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateManyWithoutOwnersInput = {
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserLabJoinCreateManyLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type RoleCreateManyLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    public?: boolean
    priority?: number
    isTeamRole?: boolean
  }

  export type PrivilegeCreateManyLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    longDescription?: string | null
    shortDescription: string
    public?: boolean
  }

  export type ContentCreateManyLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    published: boolean
    previewVideoId?: string | null
    order: number
  }

  export type LabPermissionCreateManyLabInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    type: string
  }

  export type UserUpdateWithoutOwnedLabsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    labs?: UserLabJoinUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedLabsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    labs?: UserLabJoinUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOwnedLabsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLabJoinUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabsNestedInput
    userLabRoles?: UserLabRoleUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutUserLabJoinNestedInput
  }

  export type UserLabJoinUncheckedUpdateManyWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    userLabRoles?: UserLabRoleUpdateManyWithoutRoleNestedInput
    privileges?: RolePrivilegeJoinUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
    userLabRoles?: UserLabRoleUncheckedUpdateManyWithoutRoleNestedInput
    privileges?: RolePrivilegeJoinUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    isTeamRole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrivilegeUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    roles?: RolePrivilegeJoinUpdateManyWithoutPrivilegeNestedInput
    labPermissions?: LabPermissionUpdateManyWithoutPrivilegesNestedInput
  }

  export type PrivilegeUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    roles?: RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeNestedInput
    labPermissions?: LabPermissionUncheckedUpdateManyWithoutPrivilegesNestedInput
  }

  export type PrivilegeUncheckedUpdateManyWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContentUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    thumbnail?: ImageUpdateOneWithoutContentsNestedInput
    modules?: ModuleUpdateManyWithoutContentNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    modules?: ModuleUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LabPermissionUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    privileges?: PrivilegeUpdateManyWithoutLabPermissionsNestedInput
  }

  export type LabPermissionUncheckedUpdateWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    privileges?: PrivilegeUncheckedUpdateManyWithoutLabPermissionsNestedInput
  }

  export type LabPermissionUncheckedUpdateManyWithoutLabInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserLabRoleCreateManyUserLabJoinInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    expiresAt?: Date | string | null
  }

  export type UserLabRoleUpdateWithoutUserLabJoinInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUserLabRolesNestedInput
  }

  export type UserLabRoleUncheckedUpdateWithoutUserLabJoinInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLabRoleUncheckedUpdateManyWithoutUserLabJoinInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLabRoleCreateManyRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    expiresAt?: Date | string | null
  }

  export type RolePrivilegeJoinCreateManyRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    privilegeId: string
    order?: number | null
  }

  export type UserLabRoleUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userLabJoin?: UserLabJoinUpdateOneRequiredWithoutUserLabRolesNestedInput
  }

  export type UserLabRoleUncheckedUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLabRoleUncheckedUpdateManyWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePrivilegeJoinUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    privilege?: PrivilegeUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePrivilegeJoinUncheckedUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePrivilegeJoinUncheckedUpdateManyWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePrivilegeJoinCreateManyPrivilegeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    order?: number | null
  }

  export type RolePrivilegeJoinUpdateWithoutPrivilegeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutPrivilegesNestedInput
  }

  export type RolePrivilegeJoinUncheckedUpdateWithoutPrivilegeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LabPermissionUpdateWithoutPrivilegesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lab?: LabUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type LabPermissionUncheckedUpdateWithoutPrivilegesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LabPermissionUncheckedUpdateManyWithoutPrivilegesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PrivilegeUpdateWithoutLabPermissionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    lab?: LabUpdateOneRequiredWithoutPrivilegesNestedInput
    roles?: RolePrivilegeJoinUpdateManyWithoutPrivilegeNestedInput
  }

  export type PrivilegeUncheckedUpdateWithoutLabPermissionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    roles?: RolePrivilegeJoinUncheckedUpdateManyWithoutPrivilegeNestedInput
  }

  export type PrivilegeUncheckedUpdateManyWithoutLabPermissionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: StringFieldUpdateOperationsInput | string
    labId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleCreateManyContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    order: number
    published: boolean
    category?: string | null
    previewVideoId?: string | null
  }

  export type ModuleUpdateWithoutContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutModulesNestedInput
    classes?: ClassUpdateManyWithoutModuleNestedInput
    previewVideo?: VideoUpdateOneWithoutPreviewForModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    previewVideoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateManyModuleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    name: string
    shortDescription?: string | null
    longDescription?: string | null
    thumbnailId?: string | null
    order: number
    published: boolean
    videoId?: string | null
    category?: string | null
  }

  export type ClassUpdateWithoutModuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: ImageUpdateOneWithoutClassesNestedInput
    video?: VideoUpdateOneWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutModuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUncheckedUpdateManyWithoutModuleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    published?: BoolFieldUpdateOperationsInput | boolean
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}