"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_EYVG6XQS_exports = {};
__export(chunk_EYVG6XQS_exports, {
  getSchemaFromPackageJson: () => getSchemaFromPackageJson,
  getSchemaWithPath: () => getSchemaWithPath,
  getSchemaWithPathOptional: () => getSchemaWithPathOptional,
  printSchemaLoadedMessage: () => printSchemaLoadedMessage
});
module.exports = __toCommonJS(chunk_EYVG6XQS_exports);
var import_chunk_PG5FDKSF = require("./chunk-PG5FDKSF.js");
var import_config = require("@prisma/config");
var import_debug = require("@prisma/debug");
var import_schema_files_loader = require("@prisma/schema-files-loader");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_util = require("util");
var readFile = (0, import_util.promisify)(import_fs.default.readFile);
var stat = (0, import_util.promisify)(import_fs.default.stat);
var debug = (0, import_debug.Debug)("prisma:getSchema");
async function getSchemaWithPath(schemaPathFromArgs, schemaPathFromConfig, { cwd = process.cwd(), argumentName = "--schema" } = {}) {
  const result = await getSchemaWithPathInternal(schemaPathFromArgs, schemaPathFromConfig, { cwd, argumentName });
  if (result.ok) {
    return result.schema;
  }
  throw new Error(renderDefaultLookupError(result.error, cwd));
}
async function getSchemaWithPathOptional(schemaPathFromArgs, schemaPathFromConfig, { cwd = process.cwd(), argumentName = "--schema" } = {}) {
  const result = await getSchemaWithPathInternal(schemaPathFromArgs, schemaPathFromConfig, { cwd, argumentName });
  if (result.ok) {
    return result.schema;
  }
  return null;
}
function printSchemaLoadedMessage(schemaPath) {
  process.stdout.write((0, import_chunk_PG5FDKSF.dim)(`Prisma schema loaded from ${import_path.default.relative(process.cwd(), schemaPath)}`) + "\n");
}
async function readSchemaFromSingleFile(schemaPath) {
  debug("Reading schema from single file", schemaPath);
  const typeError = await (0, import_schema_files_loader.ensureType)(schemaPath, "file");
  if (typeError) {
    return { ok: false, error: typeError };
  }
  const file = await readFile(schemaPath, { encoding: "utf-8" });
  const schemaTuple = [schemaPath, file];
  return {
    ok: true,
    schema: { schemaPath, schemaRootDir: import_path.default.dirname(schemaPath), schemas: [schemaTuple] }
  };
}
async function readSchemaFromDirectory(schemaPath) {
  debug("Reading schema from multiple files", schemaPath);
  const typeError = await (0, import_schema_files_loader.ensureType)(schemaPath, "directory");
  if (typeError) {
    return { ok: false, error: typeError };
  }
  const files = await (0, import_schema_files_loader.loadSchemaFiles)(schemaPath);
  return { ok: true, schema: { schemaPath, schemaRootDir: schemaPath, schemas: files } };
}
async function readSchemaFromFileOrDirectory(schemaPath) {
  let stats;
  try {
    stats = await stat(schemaPath);
  } catch (e) {
    if (e.code === "ENOENT") {
      return { ok: false, error: { kind: "NotFound", path: schemaPath } };
    }
    throw e;
  }
  if (stats.isFile()) {
    return readSchemaFromSingleFile(schemaPath);
  }
  if (stats.isDirectory()) {
    return readSchemaFromDirectory(schemaPath);
  }
  return { ok: false, error: { kind: "WrongType", path: schemaPath, expectedTypes: ["file", "directory"] } };
}
async function getSchemaWithPathInternal(schemaPathFromArgs, schemaPathFromConfig, { cwd, argumentName }) {
  if (schemaPathFromArgs) {
    const absPath = import_path.default.resolve(cwd, schemaPathFromArgs);
    const customSchemaResult = await readSchemaFromFileOrDirectory(absPath);
    if (!customSchemaResult.ok) {
      const relPath = import_path.default.relative(cwd, absPath);
      throw new Error(
        `Could not load \`${argumentName}\` from provided path \`${relPath}\`: ${renderLookupError(
          customSchemaResult.error
        )}`
      );
    }
    return customSchemaResult;
  }
  const prismaConfigResult = await readSchemaFromPrismaConfigBasedLocation(schemaPathFromConfig);
  if (prismaConfigResult.ok) {
    return prismaConfigResult;
  }
  const pkgJsonResult = await getSchemaFromPackageJson(cwd);
  if (pkgJsonResult.ok) {
    return pkgJsonResult;
  }
  const defaultResult = await getDefaultSchema(cwd);
  if (defaultResult.ok) {
    return defaultResult;
  }
  return {
    ok: false,
    error: defaultResult.error
  };
}
function renderLookupError(error) {
  switch (error.kind) {
    case "NotFound": {
      const expected = error.expectedType ?? "file or directory";
      return `${expected} not found`;
    }
    case "WrongType":
      return `expected ${error.expectedTypes.join(" or ")}`;
  }
}
function renderDefaultLookupError(error, cwd) {
  const parts = [
    `Could not find Prisma Schema that is required for this command.`,
    `You can either provide it with ${(0, import_chunk_PG5FDKSF.green)("`--schema`")} argument,`,
    `set it in your Prisma Config file (e.g., ${(0, import_chunk_PG5FDKSF.green)("`prisma.config.ts`")}),`,
    `set it as ${(0, import_chunk_PG5FDKSF.green)("`prisma.schema`")} in your ${(0, import_chunk_PG5FDKSF.green)("package.json")},`,
    `or put it into the default location (${(0, import_chunk_PG5FDKSF.green)("`./prisma/schema.prisma`")}, or ${(0, import_chunk_PG5FDKSF.green)("`./schema.prisma`")}.`,
    "Checked following paths:\n"
  ];
  const printedPaths = /* @__PURE__ */ new Set();
  for (const failure of error.failures) {
    const filePath = failure.path;
    if (!printedPaths.has(failure.path)) {
      parts.push(`${import_path.default.relative(cwd, filePath)}: ${renderLookupError(failure.error)}`);
      printedPaths.add(filePath);
    }
  }
  parts.push("\nSee also https://pris.ly/d/prisma-schema-location");
  return parts.join("\n");
}
async function readSchemaFromPrismaConfigBasedLocation(schemaPathFromConfig) {
  if (!schemaPathFromConfig) {
    return {
      ok: false,
      error: { kind: "PrismaConfigNotConfigured" }
    };
  }
  const schemaResult = await readSchemaFromFileOrDirectory(schemaPathFromConfig);
  if (!schemaResult.ok) {
    throw new Error(
      `Could not load schema from \`${schemaPathFromConfig}\` provided by "prisma.config.ts"\`: ${renderLookupError(
        schemaResult.error
      )}`
    );
  }
  return schemaResult;
}
async function getSchemaFromPackageJson(cwd) {
  const prismaConfig = await (0, import_config.loadConfigFromPackageJson)(cwd);
  debug("prismaConfig", prismaConfig);
  if (!prismaConfig || !prismaConfig.config?.schema) {
    return { ok: false, error: { kind: "PackageJsonNotConfigured" } };
  }
  const schemaPathFromPkgJson = prismaConfig.config.schema;
  if (typeof schemaPathFromPkgJson !== "string") {
    throw new Error(
      `Provided schema path \`${schemaPathFromPkgJson}\` from \`${import_path.default.relative(
        cwd,
        prismaConfig.loadedFromFile
      )}\` must be of type string`
    );
  }
  const absoluteSchemaPath = import_path.default.isAbsolute(schemaPathFromPkgJson) ? schemaPathFromPkgJson : import_path.default.resolve(import_path.default.dirname(prismaConfig.loadedFromFile), schemaPathFromPkgJson);
  const lookupResult = await readSchemaFromFileOrDirectory(absoluteSchemaPath);
  if (!lookupResult.ok) {
    throw new Error(
      `Could not load schema from \`${import_path.default.relative(
        cwd,
        absoluteSchemaPath
      )}\` provided by "prisma.schema" config of \`${import_path.default.relative(
        cwd,
        prismaConfig.loadedFromFile
      )}\`: ${renderLookupError(lookupResult.error)}`
    );
  }
  return lookupResult;
}
async function getDefaultSchema(cwd, failures = []) {
  const lookupPaths = [import_path.default.join(cwd, "schema.prisma"), import_path.default.join(cwd, "prisma", "schema.prisma")];
  for (const path2 of lookupPaths) {
    debug(`Checking existence of ${path2}`);
    const schema = await readSchemaFromSingleFile(path2);
    if (!schema.ok) {
      failures.push({ path: path2, error: schema.error });
      continue;
    }
    return schema;
  }
  return {
    ok: false,
    error: {
      kind: "NotFoundMultipleLocations",
      failures
    }
  };
}
