{"version":3,"sources":["../../src/runtime-v5/react.ts","../../src/runtime/common.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    UseSuspenseInfiniteQueryOptions,\n    UseSuspenseQueryOptions,\n    useInfiniteQuery,\n    useMutation,\n    useQuery,\n    useQueryClient,\n    useSuspenseInfiniteQuery,\n    useSuspenseQuery,\n    type InfiniteData,\n    type UseInfiniteQueryOptions,\n    type UseMutationOptions,\n    type UseQueryOptions,\n} from '@tanstack/react-query-v5';\nimport type { ModelMeta } from '@zenstackhq/runtime/cross';\nimport { createContext, useContext } from 'react';\nimport {\n    DEFAULT_QUERY_ENDPOINT,\n    fetcher,\n    getQueryKey,\n    makeUrl,\n    marshal,\n    setupInvalidation,\n    setupOptimisticUpdate,\n    type APIContext,\n    type ExtraMutationOptions,\n    type ExtraQueryOptions,\n    type FetchFn,\n} from '../runtime/common';\n\n/**\n * Context for configuring react hooks.\n */\nexport const RequestHandlerContext = createContext<APIContext>({\n    endpoint: DEFAULT_QUERY_ENDPOINT,\n    fetch: undefined,\n});\n\n/**\n * Hooks context.\n */\nexport function getHooksContext() {\n    const { endpoint, ...rest } = useContext(RequestHandlerContext);\n    return { endpoint: endpoint ?? DEFAULT_QUERY_ENDPOINT, ...rest };\n}\n\n/**\n * Context provider.\n */\nexport const Provider = RequestHandlerContext.Provider;\n\n/**\n * Creates a react-query query.\n *\n * @param model The name of the model under query.\n * @param url The request URL.\n * @param args The request args object, URL-encoded and appended as \"?q=\" parameter\n * @param options The react-query options object\n * @param fetch The fetch function to use for sending the HTTP request\n * @returns useQuery hook\n */\nexport function useModelQuery<TQueryFnData, TData, TError>(\n    model: string,\n    url: string,\n    args?: unknown,\n    options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions,\n    fetch?: FetchFn\n) {\n    const reqUrl = makeUrl(url, args);\n    const queryKey = getQueryKey(model, url, args, {\n        infinite: false,\n        optimisticUpdate: options?.optimisticUpdate !== false,\n    });\n    return {\n        queryKey,\n        ...useQuery({\n            queryKey,\n            queryFn: ({ signal }) => fetcher<TQueryFnData, false>(reqUrl, { signal }, fetch, false),\n            ...options,\n        }),\n    };\n}\n\n/**\n * Creates a react-query suspense query.\n *\n * @param model The name of the model under query.\n * @param url The request URL.\n * @param args The request args object, URL-encoded and appended as \"?q=\" parameter\n * @param options The react-query options object\n * @param fetch The fetch function to use for sending the HTTP request\n * @returns useSuspenseQuery hook\n */\nexport function useSuspenseModelQuery<TQueryFnData, TData, TError>(\n    model: string,\n    url: string,\n    args?: unknown,\n    options?: Omit<UseSuspenseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions,\n    fetch?: FetchFn\n) {\n    const reqUrl = makeUrl(url, args);\n    const queryKey = getQueryKey(model, url, args, {\n        infinite: false,\n        optimisticUpdate: options?.optimisticUpdate !== false,\n    });\n    return {\n        queryKey,\n        ...useSuspenseQuery({\n            queryKey,\n            queryFn: ({ signal }) => fetcher<TQueryFnData, false>(reqUrl, { signal }, fetch, false),\n            ...options,\n        }),\n    };\n}\n\n/**\n * Creates a react-query infinite query.\n *\n * @param model The name of the model under query.\n * @param url The request URL.\n * @param args The initial request args object, URL-encoded and appended as \"?q=\" parameter\n * @param options The react-query infinite query options object\n * @param fetch The fetch function to use for sending the HTTP request\n * @returns useInfiniteQuery hook\n */\nexport function useInfiniteModelQuery<TQueryFnData, TData, TError>(\n    model: string,\n    url: string,\n    args: unknown,\n    options: Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>,\n    fetch?: FetchFn\n) {\n    const queryKey = getQueryKey(model, url, args, { infinite: true, optimisticUpdate: false });\n    return {\n        queryKey,\n        ...useInfiniteQuery({\n            queryKey,\n            queryFn: ({ pageParam, signal }) => {\n                return fetcher<TQueryFnData, false>(makeUrl(url, pageParam ?? args), { signal }, fetch, false);\n            },\n            initialPageParam: args,\n            ...options,\n        }),\n    };\n}\n\n/**\n * Creates a react-query infinite suspense query.\n *\n * @param model The name of the model under query.\n * @param url The request URL.\n * @param args The initial request args object, URL-encoded and appended as \"?q=\" parameter\n * @param options The react-query infinite query options object\n * @param fetch The fetch function to use for sending the HTTP request\n * @returns useSuspenseInfiniteQuery hook\n */\nexport function useSuspenseInfiniteModelQuery<TQueryFnData, TData, TError>(\n    model: string,\n    url: string,\n    args: unknown,\n    options: Omit<\n        UseSuspenseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>,\n        'queryKey' | 'initialPageParam'\n    >,\n    fetch?: FetchFn\n) {\n    const queryKey = getQueryKey(model, url, args, { infinite: true, optimisticUpdate: false });\n    return {\n        queryKey,\n        ...useSuspenseInfiniteQuery({\n            queryKey,\n            queryFn: ({ pageParam, signal }) => {\n                return fetcher<TQueryFnData, false>(makeUrl(url, pageParam ?? args), { signal }, fetch, false);\n            },\n            initialPageParam: args,\n            ...options,\n        }),\n    };\n}\n\n/**\n * Creates a react-query mutation\n *\n * @param model The name of the model under mutation.\n * @param method The HTTP method.\n * @param url The request URL.\n * @param modelMeta The model metadata.\n * @param options The react-query options.\n * @param fetch The fetch function to use for sending the HTTP request\n * @param checkReadBack Whether to check for read back errors and return undefined if found.\n */\nexport function useModelMutation<\n    TArgs,\n    TError,\n    R = any,\n    C extends boolean = boolean,\n    Result = C extends true ? R | undefined : R\n>(\n    model: string,\n    method: 'POST' | 'PUT' | 'DELETE',\n    url: string,\n    modelMeta: ModelMeta,\n    options?: Omit<UseMutationOptions<Result, TError, TArgs>, 'mutationFn'> & ExtraMutationOptions,\n    fetch?: FetchFn,\n    checkReadBack?: C\n) {\n    const queryClient = useQueryClient();\n    const mutationFn = (data: any) => {\n        const reqUrl = method === 'DELETE' ? makeUrl(url, data) : url;\n        const fetchInit: RequestInit = {\n            method,\n            ...(method !== 'DELETE' && {\n                headers: {\n                    'content-type': 'application/json',\n                },\n                body: marshal(data),\n            }),\n        };\n        return fetcher<R, C>(reqUrl, fetchInit, fetch, checkReadBack) as Promise<Result>;\n    };\n\n    const finalOptions = { ...options, mutationFn };\n    const operation = url.split('/').pop();\n    const invalidateQueries = options?.invalidateQueries !== false;\n    const optimisticUpdate = !!options?.optimisticUpdate;\n\n    if (operation) {\n        const { logging } = useContext(RequestHandlerContext);\n        if (invalidateQueries) {\n            setupInvalidation(\n                model,\n                operation,\n                modelMeta,\n                finalOptions,\n                (predicate) => queryClient.invalidateQueries({ predicate }),\n                logging\n            );\n        }\n\n        if (optimisticUpdate) {\n            setupOptimisticUpdate(\n                model,\n                operation,\n                modelMeta,\n                finalOptions,\n                queryClient.getQueryCache().getAll(),\n                (queryKey, data) => {\n                    // update query cache\n                    queryClient.setQueryData<unknown>(queryKey, data);\n                    // cancel on-flight queries to avoid redundant cache updates,\n                    // the settlement of the current mutation will trigger a new revalidation\n                    queryClient.cancelQueries({ queryKey }, { revert: false, silent: true });\n                },\n                invalidateQueries ? (predicate) => queryClient.invalidateQueries({ predicate }) : undefined,\n                logging\n            );\n        }\n    }\n\n    return useMutation(finalOptions);\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { deserialize, serialize } from '@zenstackhq/runtime/browser';\nimport {\n    applyMutation,\n    getMutatedModels,\n    getReadModels,\n    type ModelMeta,\n    type PrismaWriteActionType,\n} from '@zenstackhq/runtime/cross';\n\n/**\n * The default query endpoint.\n */\nexport const DEFAULT_QUERY_ENDPOINT = '/api/model';\n\n/**\n * Prefix for react-query keys.\n */\nexport const QUERY_KEY_PREFIX = 'zenstack';\n\n/**\n * Function signature for `fetch`.\n */\nexport type FetchFn = (url: string, options?: RequestInit) => Promise<Response>;\n\n/**\n * Type for query and mutation errors.\n */\nexport type QueryError = Error & {\n    /**\n     * Additional error information.\n     */\n    info?: unknown;\n\n    /**\n     * HTTP status code.\n     */\n    status?: number;\n};\n\n/**\n * Result of optimistic data provider.\n */\nexport type OptimisticDataProviderResult = {\n    /**\n     * Kind of the result.\n     *   - Update: use the `data` field to update the query cache.\n     *   - Skip: skip the optimistic update for this query.\n     *   - ProceedDefault: proceed with the default optimistic update.\n     */\n    kind: 'Update' | 'Skip' | 'ProceedDefault';\n\n    /**\n     * Data to update the query cache. Only applicable if `kind` is 'Update'.\n     *\n     * If the data is an object with fields updated, it should have a `$optimistic`\n     * field set to `true`. If it's an array and an element object is created or updated,\n     * the element should have a `$optimistic` field set to `true`.\n     */\n    data?: any;\n};\n\n/**\n * Optimistic data provider.\n *\n * @param args Arguments.\n * @param args.queryModel The model of the query.\n * @param args.queryOperation The operation of the query, `findMany`, `count`, etc.\n * @param args.queryArgs The arguments of the query.\n * @param args.currentData The current cache data for the query.\n * @param args.mutationArgs The arguments of the mutation.\n */\nexport type OptimisticDataProvider = (args: {\n    queryModel: string;\n    queryOperation: string;\n    queryArgs: any;\n    currentData: any;\n    mutationArgs: any;\n}) => OptimisticDataProviderResult | Promise<OptimisticDataProviderResult>;\n\n/**\n * Extra mutation options.\n */\nexport type ExtraMutationOptions = {\n    /**\n     * Whether to automatically invalidate queries potentially affected by the mutation. Defaults to `true`.\n     */\n    invalidateQueries?: boolean;\n\n    /**\n     * Whether to optimistically update queries potentially affected by the mutation. Defaults to `false`.\n     */\n    optimisticUpdate?: boolean;\n\n    /**\n     * A callback for computing optimistic update data for each query cache entry.\n     */\n    optimisticDataProvider?: OptimisticDataProvider;\n};\n\n/**\n * Extra query options.\n */\nexport type ExtraQueryOptions = {\n    /**\n     * Whether to opt-in to optimistic updates for this query. Defaults to `true`.\n     */\n    optimisticUpdate?: boolean;\n};\n\n/**\n * Context type for configuring the hooks.\n */\nexport type APIContext = {\n    /**\n     * The endpoint to use for the queries.\n     */\n    endpoint?: string;\n\n    /**\n     * A custom fetch function for sending the HTTP requests.\n     */\n    fetch?: FetchFn;\n\n    /**\n     * If logging is enabled.\n     */\n    logging?: boolean;\n};\n\nexport async function fetcher<R, C extends boolean>(\n    url: string,\n    options?: RequestInit,\n    customFetch?: FetchFn,\n    checkReadBack?: C\n): Promise<C extends true ? R | undefined : R> {\n    // Note: 'cross-fetch' is supposed to handle fetch compatibility\n    // but it doesn't work for cloudflare workers\n    const _fetch =\n        customFetch ??\n        // check if fetch is available globally\n        (typeof fetch === 'function'\n            ? fetch\n            : // fallback to 'cross-fetch' if otherwise\n              (await import('cross-fetch')).default);\n\n    const res = await _fetch(url, options);\n    if (!res.ok) {\n        const errData = unmarshal(await res.text());\n        if (\n            checkReadBack !== false &&\n            errData.error?.prisma &&\n            errData.error?.code === 'P2004' &&\n            errData.error?.reason === 'RESULT_NOT_READABLE'\n        ) {\n            // policy doesn't allow mutation result to be read back, just return undefined\n            return undefined as any;\n        }\n        const error: QueryError = new Error('An error occurred while fetching the data.');\n        error.info = errData.error;\n        error.status = res.status;\n        throw error;\n    }\n\n    const textResult = await res.text();\n    try {\n        return unmarshal(textResult).data as R;\n    } catch (err) {\n        console.error(`Unable to deserialize data:`, textResult);\n        throw err;\n    }\n}\n\ntype QueryKey = [\n    string /* prefix */,\n    string /* model */,\n    string /* operation */,\n    unknown /* args */,\n    {\n        infinite: boolean;\n        optimisticUpdate: boolean;\n    } /* flags */\n];\n\n/**\n * Computes query key for the given model, operation and query args.\n * @param model Model name.\n * @param urlOrOperation Prisma operation (e.g, `findMany`) or request URL. If it's a URL, the last path segment will be used as the operation name.\n * @param args Prisma query arguments.\n * @param options Query options, including `infinite` indicating if it's an infinite query (defaults to false), and `optimisticUpdate` indicating if optimistic updates are enabled (defaults to true).\n * @returns Query key\n */\nexport function getQueryKey(\n    model: string,\n    urlOrOperation: string,\n    args: unknown,\n    options: { infinite: boolean; optimisticUpdate: boolean } = { infinite: false, optimisticUpdate: true }\n): QueryKey {\n    if (!urlOrOperation) {\n        throw new Error('Invalid urlOrOperation');\n    }\n    const operation = urlOrOperation.split('/').pop();\n\n    const infinite = options.infinite;\n    // infinite query doesn't support optimistic updates\n    const optimisticUpdate = options.infinite ? false : options.optimisticUpdate;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [QUERY_KEY_PREFIX, model, operation!, args, { infinite, optimisticUpdate }];\n}\n\nexport function marshal(value: unknown) {\n    const { data, meta } = serialize(value);\n    if (meta) {\n        return JSON.stringify({ ...(data as any), meta: { serialization: meta } });\n    } else {\n        return JSON.stringify(data);\n    }\n}\n\nexport function unmarshal(value: string) {\n    const parsed = JSON.parse(value);\n    if (typeof parsed === 'object' && parsed?.data && parsed?.meta?.serialization) {\n        const deserializedData = deserialize(parsed.data, parsed.meta.serialization);\n        return { ...parsed, data: deserializedData };\n    } else {\n        return parsed;\n    }\n}\n\nexport function makeUrl(url: string, args: unknown) {\n    if (!args) {\n        return url;\n    }\n\n    const { data, meta } = serialize(args);\n    let result = `${url}?q=${encodeURIComponent(JSON.stringify(data))}`;\n    if (meta) {\n        result += `&meta=${encodeURIComponent(JSON.stringify({ serialization: meta }))}`;\n    }\n    return result;\n}\n\ntype InvalidationPredicate = ({ queryKey }: { queryKey: readonly unknown[] }) => boolean;\ntype InvalidateFunc = (predicate: InvalidationPredicate) => Promise<void>;\ntype MutationOptions = {\n    onMutate?: (...args: any[]) => any;\n    onSuccess?: (...args: any[]) => any;\n    onSettled?: (...args: any[]) => any;\n};\n\n// sets up invalidation hook for a mutation\nexport function setupInvalidation(\n    model: string,\n    operation: string,\n    modelMeta: ModelMeta,\n    options: MutationOptions,\n    invalidate: InvalidateFunc,\n    logging = false\n) {\n    const origOnSuccess = options?.onSuccess;\n    options.onSuccess = async (...args: unknown[]) => {\n        const [_, variables] = args;\n        const predicate = await getInvalidationPredicate(\n            model,\n            operation as PrismaWriteActionType,\n            variables,\n            modelMeta,\n            logging\n        );\n        await invalidate(predicate);\n        return origOnSuccess?.(...args);\n    };\n}\n\n// gets a predicate for evaluating whether a query should be invalidated\nasync function getInvalidationPredicate(\n    model: string,\n    operation: PrismaWriteActionType,\n    mutationArgs: any,\n    modelMeta: ModelMeta,\n    logging = false\n) {\n    const mutatedModels = await getMutatedModels(model, operation, mutationArgs, modelMeta);\n\n    return ({ queryKey }: { queryKey: readonly unknown[] }) => {\n        const [_, queryModel, , args] = queryKey as QueryKey;\n\n        if (mutatedModels.includes(queryModel)) {\n            // direct match\n            if (logging) {\n                console.log(`Invalidating query ${JSON.stringify(queryKey)} due to mutation \"${model}.${operation}\"`);\n            }\n            return true;\n        }\n\n        if (args) {\n            // traverse query args to find nested reads that match the model under mutation\n            if (findNestedRead(queryModel, mutatedModels, modelMeta, args)) {\n                if (logging) {\n                    console.log(\n                        `Invalidating query ${JSON.stringify(queryKey)} due to mutation \"${model}.${operation}\"`\n                    );\n                }\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\n// find nested reads that match the given models\nfunction findNestedRead(visitingModel: string, targetModels: string[], modelMeta: ModelMeta, args: any) {\n    const modelsRead = getReadModels(visitingModel, modelMeta, args);\n    return targetModels.some((m) => modelsRead.includes(m));\n}\n\ntype QueryCache = {\n    queryKey: readonly unknown[];\n    state: {\n        data: unknown;\n        error: unknown;\n    };\n}[];\n\ntype SetCacheFunc = (queryKey: readonly unknown[], data: unknown) => void;\n\n/**\n * Sets up optimistic update and invalidation (after settled) for a mutation.\n */\nexport function setupOptimisticUpdate(\n    model: string,\n    operation: string,\n    modelMeta: ModelMeta,\n    options: MutationOptions & ExtraMutationOptions,\n    queryCache: QueryCache,\n    setCache: SetCacheFunc,\n    invalidate?: InvalidateFunc,\n    logging = false\n) {\n    const origOnMutate = options?.onMutate;\n    const origOnSettled = options?.onSettled;\n\n    // optimistic update on mutate\n    options.onMutate = async (...args: unknown[]) => {\n        const [variables] = args;\n        await optimisticUpdate(\n            model,\n            operation as PrismaWriteActionType,\n            variables,\n            options,\n            modelMeta,\n            queryCache,\n            setCache,\n            logging\n        );\n        return origOnMutate?.(...args);\n    };\n\n    // invalidate on settled\n    options.onSettled = async (...args: unknown[]) => {\n        if (invalidate) {\n            const [, , variables] = args;\n            const predicate = await getInvalidationPredicate(\n                model,\n                operation as PrismaWriteActionType,\n                variables,\n                modelMeta,\n                logging\n            );\n            await invalidate(predicate);\n        }\n        return origOnSettled?.(...args);\n    };\n}\n\n// optimistically updates query cache\nasync function optimisticUpdate(\n    mutationModel: string,\n    mutationOp: string,\n    mutationArgs: any,\n    options: MutationOptions & ExtraMutationOptions,\n    modelMeta: ModelMeta,\n    queryCache: QueryCache,\n    setCache: SetCacheFunc,\n    logging = false\n) {\n    for (const cacheItem of queryCache) {\n        const {\n            queryKey,\n            state: { data, error },\n        } = cacheItem;\n\n        if (!isZenStackQueryKey(queryKey)) {\n            // skip non-zenstack queries\n            continue;\n        }\n\n        if (error) {\n            if (logging) {\n                console.warn(`Skipping optimistic update for ${JSON.stringify(queryKey)} due to error:`, error);\n            }\n            continue;\n        }\n\n        const [_, queryModel, queryOperation, queryArgs, queryOptions] = queryKey;\n        if (!queryOptions?.optimisticUpdate) {\n            if (logging) {\n                console.log(`Skipping optimistic update for ${JSON.stringify(queryKey)} due to opt-out`);\n            }\n            continue;\n        }\n\n        if (options.optimisticDataProvider) {\n            const providerResult = await options.optimisticDataProvider({\n                queryModel,\n                queryOperation,\n                queryArgs,\n                currentData: data,\n                mutationArgs,\n            });\n\n            if (providerResult?.kind === 'Skip') {\n                // skip\n                if (logging) {\n                    console.log(`Skipping optimistic update for ${JSON.stringify(queryKey)} due to provider`);\n                }\n                continue;\n            } else if (providerResult?.kind === 'Update') {\n                // update cache\n                if (logging) {\n                    console.log(`Optimistically updating query ${JSON.stringify(queryKey)} due to provider`);\n                }\n                setCache(queryKey, providerResult.data);\n                continue;\n            }\n        }\n\n        // proceed with default optimistic update\n        const mutatedData = await applyMutation(\n            queryModel,\n            queryOperation,\n            data,\n            mutationModel,\n            mutationOp as PrismaWriteActionType,\n            mutationArgs,\n            modelMeta,\n            logging\n        );\n\n        if (mutatedData !== undefined) {\n            // mutation applicable to this query, update cache\n            if (logging) {\n                console.log(\n                    `Optimistically updating query ${JSON.stringify(\n                        queryKey\n                    )} due to mutation \"${mutationModel}.${mutationOp}\"`\n                );\n            }\n            setCache(queryKey, mutatedData);\n        }\n    }\n}\n\nfunction isZenStackQueryKey(queryKey: readonly unknown[]): queryKey is QueryKey {\n    if (queryKey.length < 5) {\n        return false;\n    }\n\n    if (queryKey[0] !== QUERY_KEY_PREFIX) {\n        return false;\n    }\n\n    return true;\n}\n"],"mappings":"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","names":["optimisticUpdate","fetch","optimisticUpdate"]}