"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withJsonProcessor = withJsonProcessor;
/* eslint-disable @typescript-eslint/no-explicit-any */
const cross_1 = require("../../cross");
const proxy_1 = require("./proxy");
const query_utils_1 = require("./query-utils");
/**
 * Gets an enhanced Prisma client that post-processes JSON values.
 *
 * @private
 */
function withJsonProcessor(prisma, options) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new JsonProcessorHandler(_prisma, model, options), 'json-processor');
}
class JsonProcessorHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options) {
        super(prisma, model, options);
        this.queryUtils = new query_utils_1.QueryUtils(prisma, options);
    }
    processResultEntity(_method, data) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const value of (0, cross_1.enumerate)(data)) {
                yield this.doPostProcess(value, this.model);
            }
            return data;
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    doPostProcess(entityData, model) {
        return __awaiter(this, void 0, void 0, function* () {
            const realModel = this.queryUtils.getDelegateConcreteModel(model, entityData);
            for (const field of (0, cross_1.getModelFields)(entityData)) {
                const fieldInfo = yield (0, cross_1.resolveField)(this.options.modelMeta, realModel, field);
                if (!fieldInfo) {
                    continue;
                }
                if (fieldInfo.isTypeDef) {
                    this.fixJsonDateFields(entityData[field], fieldInfo.type);
                }
                else if (fieldInfo.isDataModel) {
                    const items = fieldInfo.isArray && Array.isArray(entityData[field]) ? entityData[field] : [entityData[field]];
                    for (const item of items) {
                        // recurse
                        yield this.doPostProcess(item, fieldInfo.type);
                    }
                }
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fixJsonDateFields(entityData, typeDef) {
        if (typeof entityData !== 'object' && !Array.isArray(entityData)) {
            return;
        }
        (0, cross_1.enumerate)(entityData).forEach((item) => {
            if (!item || typeof item !== 'object') {
                return;
            }
            for (const [key, value] of Object.entries(item)) {
                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, typeDef, key, true);
                if (!fieldInfo) {
                    continue;
                }
                if (fieldInfo.isTypeDef) {
                    // recurse
                    this.fixJsonDateFields(value, fieldInfo.type);
                }
                else if (fieldInfo.type === 'DateTime' && typeof value === 'string') {
                    // convert to Date
                    const parsed = Date.parse(value);
                    if (!isNaN(parsed)) {
                        item[key] = new Date(parsed);
                    }
                }
            }
        });
    }
}
//# sourceMappingURL=json-processor.js.map