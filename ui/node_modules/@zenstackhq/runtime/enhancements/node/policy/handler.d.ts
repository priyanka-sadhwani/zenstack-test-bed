import { EnhancementContext, type DbClientContract } from '../../../types';
import type { InternalEnhancementOptions } from '../create-enhancement';
import { PrismaProxyHandler } from '../proxy';
import type { PermissionCheckArgs } from '../types';
/**
 * Prisma proxy handler for injecting access policy check.
 */
export declare class PolicyProxyHandler<DbClient extends DbClientContract> implements PrismaProxyHandler {
    private readonly prisma;
    private readonly options;
    private readonly context?;
    private readonly logger;
    private readonly policyUtils;
    private readonly model;
    private readonly modelMeta;
    private readonly prismaModule;
    private readonly queryUtils;
    constructor(prisma: DbClient, model: string, options: InternalEnhancementOptions, context?: EnhancementContext | undefined);
    private get modelClient();
    findUnique(args: any): Promise<any>;
    findUniqueOrThrow(args: any): Promise<any>;
    findFirst(args?: any): Promise<any>;
    findFirstOrThrow(args: any): Promise<any>;
    findMany(args?: any): Promise<unknown[]>;
    private findWithFluent;
    private doFind;
    create(args: any): Promise<unknown>;
    private doCreate;
    private hasNestedCreateOrConnect;
    private validateCreateInputSchema;
    createMany(args: {
        data: any;
        skipDuplicates?: boolean;
    }): Promise<{
        count: number;
    }>;
    createManyAndReturn(args: {
        data: any;
        select?: any;
        skipDuplicates?: boolean;
    }): Promise<unknown[]>;
    /**
     * Preprocess the payload of `createMany` and `createManyAndReturn` and update in place if needed.
     * @returns `true` if the operation should be converted to regular `create`s; false otherwise.
     */
    private preprocessCreateManyPayload;
    private hasRelationFieldsInPayload;
    private validateCreateInput;
    private doCreateMany;
    private hasDuplicatedUniqueConstraint;
    update(args: any): Promise<unknown>;
    private doUpdate;
    private calculatePostUpdateIds;
    private overrideForeignKeyFields;
    private validateUpdateInputSchema;
    updateMany(args: any): Promise<any>;
    updateManyAndReturn(args: any): Promise<unknown[]>;
    private doUpdateMany;
    upsert(args: any): Promise<unknown>;
    delete(args: any): Promise<unknown>;
    deleteMany(args: any): Promise<{
        count: number;
    }>;
    aggregate(args: any): Promise<any>;
    groupBy(args: any): Promise<any>;
    count(args: any): Promise<any>;
    subscribe(args: any): Promise<{
        [Symbol.asyncIterator]: () => {
            next: () => Promise<{
                done: any;
                value: any;
            }>;
            return: () => any;
            throw: () => any;
        };
    }>;
    stream(args: any): Promise<{
        [Symbol.asyncIterator]: () => {
            next: () => Promise<{
                done: any;
                value: any;
            }>;
            return: () => any;
            throw: () => any;
        };
    }>;
    private handleSubscribeStream;
    /**
     * Checks if the given operation is possibly allowed by the policy, without querying the database.
     * @param operation The CRUD operation.
     * @param fieldValues Extra field value filters to be combined with the policy constraints.
     */
    check(args: PermissionCheckArgs): Promise<boolean>;
    private get shouldLogQuery();
    private runPostWriteChecks;
    private requireBackLink;
    private mergeToParent;
    private removeFromParent;
    private buildIdFilterWithEntityChecker;
}
