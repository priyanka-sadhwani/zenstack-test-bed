import { type FieldInfo, type NestedWriteVisitorContext } from '../../cross';
import type { CrudContract, DbClientContract } from '../../types';
import { InternalEnhancementOptions } from './create-enhancement';
import { Logger } from './logger';
export declare class QueryUtils {
    private readonly prisma;
    protected readonly options: InternalEnhancementOptions;
    protected readonly logger: Logger;
    constructor(prisma: DbClientContract, options: InternalEnhancementOptions);
    getIdFields(model: string): FieldInfo[];
    makeIdSelection(model: string): any;
    getEntityIds(model: string, entityData: any): Record<string, unknown>;
    /**
     * Initiates a transaction.
     */
    transaction<T>(db: CrudContract, action: (tx: CrudContract) => Promise<T>): Promise<T>;
    /**
     * Builds a reversed query for the given nested path.
     */
    buildReversedQuery(db: CrudContract, context: NestedWriteVisitorContext, forMutationPayload?: boolean, uncheckedOperation?: boolean): Promise<any>;
    /**
     * Composes a compound unique field from multiple fields. E.g.:  { a: '1', b: '1' } => { a_b: { a: '1', b: '1' } }.
     */
    composeCompoundUniqueField(model: string, fieldData: any): any;
    /**
     * Flattens a generated unique field. E.g.: { a_b: { a: '1', b: '1' } } => { a: '1', b: '1' }.
     */
    flattenGeneratedUniqueField(model: string, args: any): void;
    validationError(message: string): Error;
    unknownError(message: string): Error;
    getModelFields(model: string): Record<string, FieldInfo> | undefined;
    /**
     * Gets information for a specific model field.
     */
    getModelField(model: string, field: string): FieldInfo | undefined;
    /**
     * Clones an object and makes sure it's not empty.
     */
    safeClone(value: unknown): any;
    getDelegateConcreteModel(model: string, data: any): string;
    /**
     * Gets relation info for a foreign key field.
     */
    getRelationForForeignKey(model: string, fkField: string): {
        relation: FieldInfo;
        idField: string;
        fkField: string;
    } | undefined;
    /**
     * Gets fields of object with defined values.
     */
    getFieldsWithDefinedValues(data: object): string[];
}
