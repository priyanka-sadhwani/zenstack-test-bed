"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEnhancement = createEnhancement;
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("../../constants");
const cross_1 = require("../../cross");
const default_auth_1 = require("./default-auth");
const delegate_1 = require("./delegate");
const encryption_1 = require("./encryption");
const json_processor_1 = require("./json-processor");
const logger_1 = require("./logger");
const omit_1 = require("./omit");
const password_1 = require("./password");
const policy_1 = require("./policy");
/**
 * All enhancement kinds
 */
const ALL_ENHANCEMENTS = ['password', 'omit', 'policy', 'validation', 'delegate', 'encryption'];
/**
 * Gets a Prisma client enhanced with all enhancement behaviors, including access
 * policy, field validation, field omission and password hashing.
 *
 * @private
 *
 * @param prisma The Prisma client to enhance.
 * @param context Context.
 * @param options Options.
 */
function createEnhancement(prisma, options, context) {
    var _a;
    if (!prisma) {
        throw new Error('Invalid prisma instance');
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const prismaVer = prisma._clientVersion;
    if (prismaVer && semver_1.default.lt(prismaVer, constants_1.PRISMA_MINIMUM_VERSION)) {
        console.warn(`ZenStack requires Prisma version "${constants_1.PRISMA_MINIMUM_VERSION}" or higher. Detected version is "${prismaVer}".`);
    }
    // TODO: move the detection logic into each enhancement
    // TODO: how to properly cache the detection result?
    const allFields = Object.values(options.modelMeta.models).flatMap((modelInfo) => Object.values(modelInfo.fields));
    if (options.modelMeta.typeDefs) {
        allFields.push(...Object.values(options.modelMeta.typeDefs).flatMap((typeDefInfo) => Object.values(typeDefInfo.fields)));
    }
    const hasPassword = allFields.some((field) => { var _a; return (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@password'); });
    const hasEncrypted = allFields.some((field) => { var _a; return (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@encrypted'); });
    const hasOmit = allFields.some((field) => { var _a; return (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@omit'); });
    const hasDefaultAuth = allFields.some((field) => field.defaultValueProvider);
    const hasTypeDefField = allFields.some((field) => field.isTypeDef);
    const kinds = (_a = options.kinds) !== null && _a !== void 0 ? _a : ALL_ENHANCEMENTS;
    let result = prisma;
    // delegate proxy needs to be wrapped inside policy proxy, since it may translate `deleteMany`
    // and `updateMany` to plain `delete` and `update`
    if (Object.values(options.modelMeta.models).some((model) => (0, cross_1.isDelegateModel)(options.modelMeta, model.name))) {
        if (!kinds.includes('delegate')) {
            const logger = new logger_1.Logger(prisma);
            logger.warn('Your ZModel contains delegate models but "delegate" enhancement kind is not enabled. This may result in unexpected behavior.');
        }
        else {
            result = (0, delegate_1.withDelegate)(result, options, context);
        }
    }
    // password and encrypted enhancement must be applied prior to policy because it changes then length of the field
    // and can break validation rules like `@length`
    if (hasPassword && kinds.includes('password')) {
        // @password proxy
        result = (0, password_1.withPassword)(result, options);
    }
    if (hasEncrypted && kinds.includes('encryption')) {
        if (!options.encryption) {
            throw new Error('Encryption options are required for @encrypted enhancement');
        }
        // @encrypted proxy
        result = (0, encryption_1.withEncrypted)(result, options);
    }
    // 'policy' and 'validation' enhancements are both enabled by `withPolicy`
    if (kinds.includes('policy') || kinds.includes('validation')) {
        result = (0, policy_1.withPolicy)(result, options, context);
        // if any enhancement is to introduce an inclusion of a relation field, the
        // inclusion payload must be processed by the policy enhancement for injecting
        // access control rules
        // TODO: this is currently a global callback shared among all enhancements, which
        // is far from ideal
        options.processIncludeRelationPayload = policy_1.policyProcessIncludeRelationPayload;
        if (kinds.includes('policy') && hasDefaultAuth) {
            // @default(auth()) proxy
            result = (0, default_auth_1.withDefaultAuth)(result, options, context);
        }
    }
    if (hasOmit && kinds.includes('omit')) {
        // @omit proxy
        result = (0, omit_1.withOmit)(result, options);
    }
    if (hasTypeDefField) {
        result = (0, json_processor_1.withJsonProcessor)(result, options);
    }
    return result;
}
//# sourceMappingURL=create-enhancement.js.map