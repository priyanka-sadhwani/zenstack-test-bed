"use strict";
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withDefaultAuth = withDefaultAuth;
const constants_1 = require("../../constants");
const cross_1 = require("../../cross");
const proxy_1 = require("./proxy");
const utils_1 = require("./utils");
/**
 * Gets an enhanced Prisma client that supports `@default(auth())` attribute.
 *
 * @private
 */
function withDefaultAuth(prisma, options, context = {}) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DefaultAuthHandler(_prisma, model, options, context), 'defaultAuth');
}
class DefaultAuthHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options, context) {
        super(prisma, model, options);
        this.context = context;
        this.userContext = this.context.user;
    }
    // base override
    preprocessArgs(action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args && constants_1.ACTIONS_WITH_WRITE_PAYLOAD.includes(action)) {
                const newArgs = yield this.preprocessWritePayload(this.model, action, args);
                return newArgs;
            }
            return args;
        });
    }
    preprocessWritePayload(model, action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const newArgs = (0, cross_1.clone)(args);
            const processCreatePayload = (model, data, context) => {
                const fields = (0, cross_1.getFields)(this.options.modelMeta, model);
                for (const fieldInfo of Object.values(fields)) {
                    if (fieldInfo.isTypeDef) {
                        this.setDefaultValueForTypeDefData(fieldInfo.type, data[fieldInfo.name]);
                        continue;
                    }
                    if (fieldInfo.name in data) {
                        // create payload already sets field value
                        continue;
                    }
                    if (!fieldInfo.defaultValueProvider) {
                        // field doesn't have a runtime default value provider
                        continue;
                    }
                    const defaultValue = this.getDefaultValue(fieldInfo);
                    if (defaultValue !== undefined) {
                        // set field value extracted from `auth()`
                        this.setDefaultValueForModelData(fieldInfo, model, data, defaultValue, context);
                    }
                }
            };
            // visit create payload and set default value to fields using `auth()` in `@default()`
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                create: (model, data, context) => {
                    processCreatePayload(model, data, context);
                },
                upsert: (model, data, context) => {
                    processCreatePayload(model, data.create, context);
                },
                createMany: (model, args, context) => {
                    for (const item of (0, cross_1.enumerate)(args.data)) {
                        processCreatePayload(model, item, context);
                    }
                },
            });
            yield visitor.visit(model, action, newArgs);
            return newArgs;
        });
    }
    setDefaultValueForModelData(fieldInfo, model, data, authDefaultValue, context) {
        var _a, _b;
        if (fieldInfo.isForeignKey) {
            // if the field being inspected is a fk field, there are several cases we should not
            // set the default value or should not set directly
            // if the field is a fk, and the relation field is already set, we should not override it
            if (fieldInfo.relationField && fieldInfo.relationField in data) {
                return;
            }
            if ((_a = context.field) === null || _a === void 0 ? void 0 : _a.backLink) {
                // if the fk field is in a creation context where its implied by the parent,
                // we should not set the default value, e.g.:
                //
                // ```
                // parent.create({ data: { child: { create: {} } } })
                // ```
                //
                // even if child's fk to parent has a default value, we should not set default
                // value here
                // get the opposite side of the relation for the current create context
                const oppositeRelationField = (0, cross_1.requireField)(this.options.modelMeta, model, context.field.backLink);
                if (oppositeRelationField.foreignKeyMapping &&
                    Object.values(oppositeRelationField.foreignKeyMapping).includes(fieldInfo.name)) {
                    return;
                }
            }
            if (!(0, utils_1.isUnsafeMutate)(model, data, this.options.modelMeta)) {
                // if the field is a fk, and the create payload is not unsafe, we need to translate
                // the fk field setting to a `connect` of the corresponding relation field
                const relFieldName = fieldInfo.relationField;
                if (!relFieldName) {
                    throw new Error(`Field \`${fieldInfo.name}\` is a foreign key field but no corresponding relation field is found`);
                }
                const relationField = (0, cross_1.requireField)(this.options.modelMeta, model, relFieldName);
                // construct a `{ connect: { ... } }` payload
                let connect = (_b = data[relationField.name]) === null || _b === void 0 ? void 0 : _b.connect;
                if (!connect) {
                    connect = {};
                    data[relationField.name] = { connect };
                }
                // sets the opposite fk field to value `authDefaultValue`
                const oppositeFkFieldName = this.getOppositeFkFieldName(relationField, fieldInfo);
                if (!oppositeFkFieldName) {
                    throw new Error(`Cannot find opposite foreign key field for \`${fieldInfo.name}\` in relation field \`${relFieldName}\``);
                }
                connect[oppositeFkFieldName] = authDefaultValue;
                return;
            }
        }
        // set default value directly
        data[fieldInfo.name] = authDefaultValue;
    }
    getOppositeFkFieldName(relationField, fieldInfo) {
        if (!relationField.foreignKeyMapping) {
            return undefined;
        }
        const entry = Object.entries(relationField.foreignKeyMapping).find(([, v]) => v === fieldInfo.name);
        return entry === null || entry === void 0 ? void 0 : entry[0];
    }
    getDefaultValue(fieldInfo) {
        var _a;
        if (!this.userContext) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Evaluating default value of field \`${fieldInfo.name}\` requires a user context`);
        }
        return (_a = fieldInfo.defaultValueProvider) === null || _a === void 0 ? void 0 : _a.call(fieldInfo, this.userContext);
    }
    setDefaultValueForTypeDefData(type, data) {
        if (!data || (typeof data !== 'object' && !Array.isArray(data))) {
            return;
        }
        const typeDef = (0, cross_1.getTypeDefInfo)(this.options.modelMeta, type);
        if (!typeDef) {
            return;
        }
        (0, cross_1.enumerate)(data).forEach((item) => {
            if (!item || typeof item !== 'object') {
                return;
            }
            for (const fieldInfo of Object.values(typeDef.fields)) {
                if (fieldInfo.isTypeDef) {
                    // recurse
                    this.setDefaultValueForTypeDefData(fieldInfo.type, item[fieldInfo.name]);
                }
                else if (!(fieldInfo.name in item)) {
                    // set default value if the payload doesn't set the field
                    const defaultValue = this.getDefaultValue(fieldInfo);
                    if (defaultValue !== undefined) {
                        item[fieldInfo.name] = defaultValue;
                    }
                }
            }
        });
    }
}
//# sourceMappingURL=default-auth.js.map