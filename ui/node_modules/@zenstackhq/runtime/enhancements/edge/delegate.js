"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegateProxyHandler = void 0;
exports.withDelegate = withDelegate;
/* eslint-disable @typescript-eslint/no-explicit-any */
const deepmerge_1 = __importDefault(require("deepmerge"));
const constants_1 = require("../../constants");
const cross_1 = require("../../cross");
const local_helpers_1 = require("../../local-helpers");
const logger_1 = require("./logger");
const proxy_1 = require("./proxy");
const query_utils_1 = require("./query-utils");
const utils_1 = require("./utils");
function withDelegate(prisma, options, context) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DelegateProxyHandler(_prisma, model, options, context), 'delegate');
}
class DelegateProxyHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options, context) {
        super(prisma, model, options);
        this.context = context;
        this.logger = new logger_1.Logger(prisma);
        this.queryUtils = new query_utils_1.QueryUtils(prisma, this.options);
    }
    // #region find
    findFirst(args) {
        return this.doFind(this.prisma, this.model, 'findFirst', args);
    }
    findFirstOrThrow(args) {
        return this.doFind(this.prisma, this.model, 'findFirstOrThrow', args);
    }
    findUnique(args) {
        return this.doFind(this.prisma, this.model, 'findUnique', args);
    }
    findUniqueOrThrow(args) {
        return this.doFind(this.prisma, this.model, 'findUniqueOrThrow', args);
    }
    findMany(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.doFind(this.prisma, this.model, 'findMany', args);
        });
    }
    doFind(db, model, method, args) {
        const _superIndex = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.involvesDelegateModel(model)) {
                return _superIndex(method).call(this, args);
            }
            args = args ? (0, cross_1.clone)(args) : {};
            this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
            yield this.injectSelectIncludeHierarchy(model, args);
            // discriminator field is needed during post process to determine the
            // actual concrete model type
            this.ensureDiscriminatorSelection(model, args);
            if (args.orderBy) {
                // `orderBy` may contain fields from base types
                (0, cross_1.enumerate)(args.orderBy).forEach((item) => this.injectWhereHierarchy(model, item));
            }
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`${method}\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const entity = yield db[model][method](args);
            if (Array.isArray(entity)) {
                return entity.map((item) => this.assembleHierarchy(model, item));
            }
            else {
                return this.assembleHierarchy(model, entity);
            }
        });
    }
    ensureDiscriminatorSelection(model, args) {
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);
        if (!(modelInfo === null || modelInfo === void 0 ? void 0 : modelInfo.discriminator)) {
            return;
        }
        if (args.select && typeof args.select === 'object') {
            args.select[modelInfo.discriminator] = true;
            return;
        }
        if (args.omit && typeof args.omit === 'object') {
            args.omit[modelInfo.discriminator] = false;
            return;
        }
    }
    injectWhereHierarchy(model, where) {
        if (!where || !(0, local_helpers_1.isPlainObject)(where)) {
            return;
        }
        Object.entries(where).forEach(([field, value]) => {
            if (['AND', 'OR', 'NOT'].includes(field)) {
                // recurse into logical group
                (0, cross_1.enumerate)(value).forEach((item) => this.injectWhereHierarchy(model, item));
                return;
            }
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {
                // not an inherited field, inject and continue
                if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.isDataModel) {
                    this.injectWhereHierarchy(fieldInfo.type, value);
                }
                return;
            }
            let base = this.getBaseModel(model);
            let target = where;
            while (base) {
                const baseRelationName = this.makeAuxRelationName(base);
                // prepare base layer where
                let thisLayer;
                if (target[baseRelationName]) {
                    thisLayer = target[baseRelationName];
                }
                else {
                    thisLayer = target[baseRelationName] = {};
                }
                if (base.name === fieldInfo.inheritedFrom) {
                    if (fieldInfo.isDataModel) {
                        this.injectWhereHierarchy(base.name, value);
                    }
                    thisLayer[field] = value;
                    delete where[field];
                    break;
                }
                else {
                    target = thisLayer;
                    base = this.getBaseModel(base.name);
                }
            }
        });
    }
    injectSelectIncludeHierarchy(model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args || typeof args !== 'object') {
                return;
            }
            // there're two cases where we need to inject polymorphic base hierarchy for fields
            // defined in base models
            // 1. base fields mentioned in select/include clause
            //     { select: { fieldFromBase: true } } => { select: { delegate_aux_[Base]: { fieldFromBase: true } } }
            // 2. base fields mentioned in _count select/include clause
            //     { select: { _count: { select: { fieldFromBase: true } } } } => { select: { delegate_aux_[Base]: { select: { _count: { select: { fieldFromBase: true } } } } } }
            //
            // Note that although structurally similar, we need to correctly deal with different injection location of the "delegate_aux" hierarchy
            // selectors for the above two cases
            const selectors = [
                // regular select: { select: { field: true } }
                (payload) => ({ data: payload.select, kind: 'select', isCount: false }),
                // regular include: { include: { field: true } }
                (payload) => ({ data: payload.include, kind: 'include', isCount: false }),
                // select _count: { select: { _count: { select: { field: true } } } }
                (payload) => {
                    var _a, _b;
                    return ({
                        data: (_b = (_a = payload.select) === null || _a === void 0 ? void 0 : _a._count) === null || _b === void 0 ? void 0 : _b.select,
                        kind: 'select',
                        isCount: true,
                    });
                },
                // include _count: { include: { _count: { select: { field: true } } } }
                (payload) => {
                    var _a, _b;
                    return ({
                        data: (_b = (_a = payload.include) === null || _a === void 0 ? void 0 : _a._count) === null || _b === void 0 ? void 0 : _b.select,
                        kind: 'include',
                        isCount: true,
                    });
                },
            ];
            for (const selector of selectors) {
                const { data, kind, isCount } = selector(args);
                if (!data || typeof data !== 'object') {
                    continue;
                }
                for (const [field, value] of Object.entries(data)) {
                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
                    if (!fieldInfo) {
                        continue;
                    }
                    if (this.isDelegateOrDescendantOfDelegate(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.type) && value) {
                        // delegate model, recursively inject hierarchy
                        if (data[field]) {
                            if (data[field] === true) {
                                // make sure the payload is an object
                                data[field] = {};
                            }
                            yield this.injectSelectIncludeHierarchy(fieldInfo.type, data[field]);
                            if (data[field].where) {
                                this.injectWhereHierarchy(fieldInfo.type, data[field].where);
                            }
                        }
                    }
                    // refetch the field select/include value because it may have been
                    // updated during injection
                    const fieldValue = data[field];
                    if (fieldValue !== undefined) {
                        if (fieldValue.orderBy) {
                            // `orderBy` may contain fields from base types
                            (0, cross_1.enumerate)(fieldValue.orderBy).forEach((item) => this.injectWhereHierarchy(fieldInfo.type, item));
                        }
                        let injected = false;
                        if (!isCount) {
                            // regular select/include injection
                            injected = yield this.injectBaseFieldSelect(model, field, fieldValue, args, kind);
                            if (injected) {
                                // if injected, remove the field from the original payload
                                delete data[field];
                            }
                        }
                        else {
                            // _count select/include injection, inject into an empty payload and then merge to the proper location
                            const injectTarget = { [kind]: {} };
                            injected = yield this.injectBaseFieldSelect(model, field, fieldValue, injectTarget, kind, true);
                            if (injected) {
                                // if injected, remove the field from the original payload
                                delete data[field];
                                if (Object.keys(data).length === 0) {
                                    // if the original "_count" payload becomes empty, remove it
                                    delete args[kind]['_count'];
                                }
                                // finally merge the injection into the original payload
                                const merged = (0, deepmerge_1.default)(args[kind], injectTarget[kind]);
                                args[kind] = merged;
                            }
                        }
                        if (!injected && fieldInfo.isDataModel) {
                            let nextValue = fieldValue;
                            if (nextValue === true) {
                                // make sure the payload is an object
                                data[field] = nextValue = {};
                            }
                            yield this.injectSelectIncludeHierarchy(fieldInfo.type, nextValue);
                        }
                    }
                }
            }
            if (!args.select) {
                // include base models upwards
                this.injectBaseIncludeRecursively(model, args);
                // include sub models downwards
                yield this.injectConcreteIncludeRecursively(model, args);
            }
        });
    }
    buildSelectIncludeHierarchy(model_1, args_1) {
        return __awaiter(this, arguments, void 0, function* (model, args, includeConcreteFields = true) {
            args = (0, cross_1.clone)(args);
            const selectInclude = this.extractSelectInclude(args) || {};
            if (selectInclude.select && typeof selectInclude.select === 'object') {
                Object.entries(selectInclude.select).forEach(([field, value]) => {
                    if (value) {
                        if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'select')) {
                            delete selectInclude.select[field];
                        }
                    }
                });
            }
            else if (selectInclude.include && typeof selectInclude.include === 'object') {
                Object.entries(selectInclude.include).forEach(([field, value]) => {
                    if (value) {
                        if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'include')) {
                            delete selectInclude.include[field];
                        }
                    }
                });
            }
            if (!selectInclude.select) {
                this.injectBaseIncludeRecursively(model, selectInclude);
                if (includeConcreteFields) {
                    yield this.injectConcreteIncludeRecursively(model, selectInclude);
                }
            }
            return selectInclude;
        });
    }
    injectBaseFieldSelect(model, field, value, selectInclude, context, forCount = false // if the injection is for a "{ _count: { select: { field: true } } }" payload
    ) {
        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
        if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {
            return false;
        }
        let base = this.getBaseModel(model);
        let target = selectInclude;
        while (base) {
            const baseRelationName = this.makeAuxRelationName(base);
            // prepare base layer select/include
            let thisLayer;
            if (target.include) {
                thisLayer = target.include;
            }
            else if (target.select) {
                thisLayer = target.select;
            }
            else {
                thisLayer = target.select = {};
            }
            if (base.name === fieldInfo.inheritedFrom) {
                if (!thisLayer[baseRelationName]) {
                    thisLayer[baseRelationName] = { [context]: {} };
                }
                if (forCount) {
                    // { _count: { select: { field: true } } } => { delegate_aux_[Base]: { select: { _count: { select: { field: true } } } } }
                    if (!thisLayer[baseRelationName][context]['_count'] ||
                        typeof thisLayer[baseRelationName][context] !== 'object') {
                        thisLayer[baseRelationName][context]['_count'] = {};
                    }
                    thisLayer[baseRelationName][context]['_count'] = (0, deepmerge_1.default)(thisLayer[baseRelationName][context]['_count'], { select: { [field]: value } });
                }
                else {
                    // { select: { field: true } } => { delegate_aux_[Base]: { select: { field: true } } }
                    thisLayer[baseRelationName][context][field] = value;
                }
                break;
            }
            else {
                if (!thisLayer[baseRelationName]) {
                    thisLayer[baseRelationName] = { select: {} };
                }
                target = thisLayer[baseRelationName];
                base = this.getBaseModel(base.name);
            }
        }
        return true;
    }
    injectBaseIncludeRecursively(model, selectInclude) {
        const base = this.getBaseModel(model);
        if (!base) {
            return;
        }
        const baseRelationName = this.makeAuxRelationName(base);
        if (selectInclude.select) {
            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.select);
            delete selectInclude.select;
        }
        else {
            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.include);
        }
        this.injectBaseIncludeRecursively(base.name, selectInclude.include[baseRelationName]);
    }
    injectConcreteIncludeRecursively(model, selectInclude) {
        return __awaiter(this, void 0, void 0, function* () {
            const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);
            if (!modelInfo) {
                return;
            }
            // get sub models of this model
            const subModels = Object.values(this.options.modelMeta.models).filter((m) => { var _a; return (_a = m.baseTypes) === null || _a === void 0 ? void 0 : _a.includes(modelInfo.name); });
            for (const subModel of subModels) {
                // include sub model relation field
                const subRelationName = this.makeAuxRelationName(subModel);
                // create a payload to include the sub model relation
                const includePayload = yield this.createConcreteRelationIncludePayload(subModel.name);
                if (selectInclude.select) {
                    selectInclude.include = Object.assign({ [subRelationName]: includePayload }, selectInclude.select);
                    delete selectInclude.select;
                }
                else {
                    selectInclude.include = Object.assign({ [subRelationName]: includePayload }, selectInclude.include);
                }
                yield this.injectConcreteIncludeRecursively(subModel.name, selectInclude.include[subRelationName]);
            }
        });
    }
    createConcreteRelationIncludePayload(model) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = {};
            if (this.options.processIncludeRelationPayload) {
                // use the callback in options to process the include payload, so enhancements
                // like 'policy' can do extra work (e.g., inject policy rules)
                // TODO: this causes both delegate base's policy rules and concrete model's rules to be injected,
                // which is not wrong but redundant
                yield this.options.processIncludeRelationPayload(this.prisma, model, result, this.options, this.context);
                const properSelectIncludeHierarchy = yield this.buildSelectIncludeHierarchy(model, result, false);
                result = Object.assign(Object.assign({}, result), properSelectIncludeHierarchy);
            }
            return result;
        });
    }
    // #endregion
    // #region create
    create(args) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
            }
            this.sanitizeMutationPayload(args.data);
            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${this.model}" is a delegate and cannot be created directly`);
            }
            if (!this.involvesDelegateModel(this.model)) {
                return _super.create.call(this, args);
            }
            return this.doCreate(this.prisma, this.model, args);
        });
    }
    sanitizeMutationPayload(data) {
        if (!data) {
            return;
        }
        const prisma = this.prisma;
        const prismaModule = this.options.prismaModule;
        (0, local_helpers_1.simpleTraverse)(data, ({ key }) => {
            if (key === null || key === void 0 ? void 0 : key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {
                throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Auxiliary relation field "${key}" cannot be set directly`);
            }
        });
    }
    createMany(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!args.data) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
        }
        this.sanitizeMutationPayload(args.data);
        if (!this.involvesDelegateModel(this.model)) {
            return super.createMany(args);
        }
        if (this.isDelegateOrDescendantOfDelegate(this.model) && args.skipDuplicates) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
        }
        // `createMany` doesn't support nested create, which is needed for creating entities
        // inheriting a delegate base, so we need to convert it to a regular `create` here.
        // Note that the main difference is `create` doesn't support `skipDuplicates` as
        // `createMany` does.
        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {
            const r = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {
                return this.doCreate(tx, this.model, { data: item });
            })));
            return { count: r.length };
        }));
    }
    createManyAndReturn(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!args.data) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
        }
        this.sanitizeMutationPayload(args.data);
        if (!this.involvesDelegateModel(this.model)) {
            return super.createManyAndReturn(args);
        }
        if (this.isDelegateOrDescendantOfDelegate(this.model) && args.skipDuplicates) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createManyAndReturn` with `skipDuplicates` set to true is not supported for delegated models');
        }
        // `createManyAndReturn` doesn't support nested create, which is needed for creating entities
        // inheriting a delegate base, so we need to convert it to a regular `create` here.
        // Note that the main difference is `create` doesn't support `skipDuplicates` as
        // `createManyAndReturn` does.
        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {
            const r = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {
                return this.doCreate(tx, this.model, { data: item, select: args.select });
            })));
            return r;
        }));
    }
    doCreate(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            args = (0, cross_1.clone)(args);
            yield this.injectCreateHierarchy(model, args);
            yield this.injectSelectIncludeHierarchy(model, args);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`create\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[model].create(args);
            return this.assembleHierarchy(model, result);
        });
    }
    injectCreateHierarchy(model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                create: (model, args, _context) => {
                    this.doProcessCreatePayload(model, args);
                },
                createMany: (model, args, context) => {
                    // `createMany` doesn't support nested create, which is needed for creating entities
                    // inheriting a delegate base, so we need to convert it to a regular `create` here.
                    // Note that the main difference is `create` doesn't support `skipDuplicates` as
                    // `createMany` does.
                    var _a;
                    if (this.isDelegateOrDescendantOfDelegate(model)) {
                        if (args.skipDuplicates) {
                            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
                        }
                        // convert to regular `create`
                        let createPayload = (_a = context.parent.create) !== null && _a !== void 0 ? _a : [];
                        if (!Array.isArray(createPayload)) {
                            createPayload = [createPayload];
                        }
                        for (const item of (0, cross_1.enumerate)(args.data)) {
                            this.doProcessCreatePayload(model, item);
                            createPayload.push(item);
                        }
                        context.parent.create = createPayload;
                        delete context.parent['createMany'];
                    }
                },
            });
            yield visitor.visit(model, 'create', args);
        });
    }
    doProcessCreatePayload(model, args) {
        if (!args) {
            return;
        }
        this.ensureBaseCreateHierarchy(model, args);
        for (const [field, value] of Object.entries(args)) {
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                this.injectBaseFieldData(model, fieldInfo, value, args, 'create');
                delete args[field];
            }
        }
    }
    // ensure the full nested "create" structure is created for base types
    ensureBaseCreateHierarchy(model, args) {
        let curr = args;
        let base = this.getBaseModel(model);
        let sub = this.getModelInfo(model);
        const hasDelegateBase = !!base;
        while (base) {
            const baseRelationName = this.makeAuxRelationName(base);
            if (!curr[baseRelationName]) {
                curr[baseRelationName] = {};
            }
            if (!curr[baseRelationName].create) {
                curr[baseRelationName].create = {};
                if (base.discriminator) {
                    // set discriminator field
                    curr[baseRelationName].create[base.discriminator] = sub.name;
                }
            }
            // Look for base id field assignments in the current level, and push
            // them down to the base level
            for (const idField of (0, cross_1.getIdFields)(this.options.modelMeta, base.name)) {
                if (curr[idField.name] !== undefined) {
                    curr[baseRelationName].create[idField.name] = curr[idField.name];
                    delete curr[idField.name];
                }
            }
            curr = curr[baseRelationName].create;
            sub = base;
            base = this.getBaseModel(base.name);
        }
        if (hasDelegateBase) {
            // A delegate base model creation is added, this can be incompatible if
            // the user-provided payload assigns foreign keys directly, because Prisma
            // doesn't permit mixed "checked" and "unchecked" fields in a payload.
            //
            // {
            //   delegate_aux_base: { ... },
            //   [fkField]: value  // <- this is not compatible
            // }
            //
            // We need to convert foreign key assignments to `connect`.
            this.fkAssignmentToConnect(model, args);
        }
    }
    // convert foreign key assignments to `connect` payload
    // e.g.: { authorId: value } -> { author: { connect: { id: value } } }
    fkAssignmentToConnect(model, args) {
        const keysToDelete = [];
        for (const [key, value] of Object.entries(args)) {
            if (value === undefined) {
                continue;
            }
            const fieldInfo = this.queryUtils.getModelField(model, key);
            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) && // fields from delegate base are handled outside
                (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.isForeignKey)) {
                const relationInfo = this.queryUtils.getRelationForForeignKey(model, key);
                if (relationInfo) {
                    // turn { [fk]: value } into { [relation]: { connect: { [id]: value } } }
                    const relationName = relationInfo.relation.name;
                    if (!args[relationName]) {
                        args[relationName] = {};
                    }
                    if (!args[relationName].connect) {
                        args[relationName].connect = {};
                    }
                    if (!(relationInfo.idField in args[relationName].connect)) {
                        args[relationName].connect[relationInfo.idField] = value;
                        keysToDelete.push(key);
                    }
                }
            }
        }
        keysToDelete.forEach((key) => delete args[key]);
    }
    // inject field data that belongs to base type into proper nesting structure
    injectBaseFieldData(model, fieldInfo, value, args, mode) {
        let base = this.getBaseModel(model);
        let curr = args;
        while (base) {
            if (base.discriminator === fieldInfo.name) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `fields "${fieldInfo.name}" is a discriminator and cannot be set directly`);
            }
            const baseRelationName = this.makeAuxRelationName(base);
            if (!curr[baseRelationName]) {
                curr[baseRelationName] = {};
            }
            if (!curr[baseRelationName][mode]) {
                curr[baseRelationName][mode] = {};
            }
            curr = curr[baseRelationName][mode];
            if (fieldInfo.inheritedFrom === base.name) {
                curr[fieldInfo.name] = value;
                break;
            }
            base = this.getBaseModel(base.name);
        }
    }
    // #endregion
    // #region update
    update(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!args.data) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
        }
        this.sanitizeMutationPayload(args.data);
        if (!this.involvesDelegateModel(this.model)) {
            return super.update(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdate(tx, this.model, args));
    }
    updateMany(args) {
        const _super = Object.create(null, {
            updateMany: { get: () => super.updateMany }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');
            }
            this.sanitizeMutationPayload(args.data);
            if (!this.involvesDelegateModel(this.model)) {
                return _super.updateMany.call(this, args);
            }
            let simpleUpdateMany = Object.keys(args.data).every((key) => {
                // check if the `data` clause involves base fields
                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, key);
                return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
            });
            // check if there are any `@updatedAt` fields from delegate base models
            if (simpleUpdateMany) {
                if (this.getUpdatedAtFromDelegateBases(this.model).length > 0) {
                    simpleUpdateMany = false;
                }
            }
            return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdateMany(tx, this.model, args, simpleUpdateMany));
        });
    }
    upsert(args) {
        const _super = Object.create(null, {
            upsert: { get: () => super.upsert }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
            }
            if (!args.where) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'where field is required in query argument');
            }
            this.sanitizeMutationPayload(args.update);
            this.sanitizeMutationPayload(args.create);
            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${this.model}" is a delegate and doesn't support upsert`);
            }
            if (!this.involvesDelegateModel(this.model)) {
                return _super.upsert.call(this, args);
            }
            args = (0, cross_1.clone)(args);
            this.injectWhereHierarchy(this.model, args === null || args === void 0 ? void 0 : args.where);
            yield this.injectSelectIncludeHierarchy(this.model, args);
            if (args.create) {
                this.doProcessCreatePayload(this.model, args.create);
            }
            if (args.update) {
                this.doProcessUpdatePayload(this.model, args.update);
            }
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`upsert\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield this.prisma[this.model].upsert(args);
            return this.assembleHierarchy(this.model, result);
        });
    }
    doUpdate(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            args = (0, cross_1.clone)(args);
            yield this.injectUpdateHierarchy(db, model, args);
            yield this.injectSelectIncludeHierarchy(model, args);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`update\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[model].update(args);
            return this.assembleHierarchy(model, result);
        });
    }
    doUpdateMany(db, model, args, simpleUpdateMany) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (simpleUpdateMany) {
                // do a direct `updateMany`
                args = (0, cross_1.clone)(args);
                yield this.injectUpdateHierarchy(db, model, args);
                if (this.options.logPrismaQuery) {
                    this.logger.info(`[delegate] \`updateMany\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
                }
                return db[model].updateMany(args);
            }
            else {
                // translate to plain `update` for nested write into base fields
                const findArgs = {
                    where: (0, cross_1.clone)((_a = args.where) !== null && _a !== void 0 ? _a : {}),
                    select: this.queryUtils.makeIdSelection(model),
                };
                yield this.injectUpdateHierarchy(db, model, findArgs);
                if (this.options.logPrismaQuery) {
                    this.logger.info(`[delegate] \`updateMany\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);
                }
                const entities = yield db[model].findMany(findArgs);
                const updatePayload = { data: (0, cross_1.clone)(args.data), select: this.queryUtils.makeIdSelection(model) };
                yield this.injectUpdateHierarchy(db, model, updatePayload);
                const result = yield Promise.all(entities.map((entity) => {
                    const updateArgs = Object.assign({ where: entity }, updatePayload);
                    if (this.options.logPrismaQuery) {
                        this.logger.info(`[delegate] \`updateMany\` update: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(updateArgs)}`);
                    }
                    return db[model].update(updateArgs);
                }));
                return { count: result.length };
            }
        });
    }
    injectUpdateHierarchy(db, model, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                update: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                    this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);
                },
                updateMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    let simpleUpdateMany = Object.keys(args.data).every((key) => {
                        // check if the `data` clause involves base fields
                        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);
                        return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
                    });
                    // check if there are any `@updatedAt` fields from delegate base models
                    if (simpleUpdateMany) {
                        if (this.getUpdatedAtFromDelegateBases(model).length > 0) {
                            simpleUpdateMany = false;
                        }
                    }
                    if (simpleUpdateMany) {
                        // check if the `where` clause involves base fields
                        simpleUpdateMany = Object.keys(args.where || {}).every((key) => {
                            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);
                            return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);
                        });
                    }
                    if (simpleUpdateMany) {
                        this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);
                    }
                    else {
                        const where = yield this.queryUtils.buildReversedQuery(db, context, false, false);
                        yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                            yield this.doUpdateMany(tx, model, Object.assign(Object.assign({}, args), { where }), simpleUpdateMany);
                        }));
                        delete context.parent['updateMany'];
                    }
                }),
                upsert: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);
                    if (args.create) {
                        this.doProcessCreatePayload(model, args === null || args === void 0 ? void 0 : args.create);
                    }
                    if (args.update) {
                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.update);
                    }
                },
                create: (model, args, _context) => {
                    if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model "${model}" is a delegate and cannot be created directly`);
                    }
                    this.doProcessCreatePayload(model, args);
                },
                createMany: (model, args, _context) => {
                    if (args.skipDuplicates) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');
                    }
                    for (const item of (0, cross_1.enumerate)(args === null || args === void 0 ? void 0 : args.data)) {
                        this.doProcessCreatePayload(model, item);
                    }
                },
                connect: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                connectOrCreate: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args.where);
                    if (args.create) {
                        this.doProcessCreatePayload(model, args.create);
                    }
                },
                disconnect: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                set: (model, args, _context) => {
                    this.injectWhereHierarchy(model, args);
                },
                delete: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {
                    const where = yield this.queryUtils.buildReversedQuery(db, context, false, false);
                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                        yield this.doDelete(tx, model, { where });
                    }));
                    delete context.parent['delete'];
                }),
                deleteMany: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {
                    const where = yield this.queryUtils.buildReversedQuery(db, context, false, false);
                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {
                        yield this.doDeleteMany(tx, model, where);
                    }));
                    delete context.parent['deleteMany'];
                }),
            });
            yield visitor.visit(model, 'update', args);
        });
    }
    doProcessUpdatePayload(model, data) {
        if (!data) {
            return;
        }
        for (const [field, value] of Object.entries(data)) {
            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);
            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                this.injectBaseFieldData(model, fieldInfo, value, data, 'update');
                delete data[field];
            }
        }
        // if we're updating any field, we need to take care of updating `@updatedAt`
        // fields inherited from delegate base models
        if (Object.keys(data).length > 0) {
            const updatedAtFields = this.getUpdatedAtFromDelegateBases(model);
            for (const fieldInfo of updatedAtFields) {
                this.injectBaseFieldData(model, fieldInfo, new Date(), data, 'update');
            }
        }
    }
    // #endregion
    // #region delete
    delete(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.delete(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {
            const selectInclude = yield this.buildSelectIncludeHierarchy(this.model, args);
            // make sure id fields are selected
            const idFields = this.getIdFields(this.model);
            for (const idField of idFields) {
                if ((selectInclude === null || selectInclude === void 0 ? void 0 : selectInclude.select) && !(idField.name in selectInclude.select)) {
                    selectInclude.select[idField.name] = true;
                }
            }
            const deleteArgs = Object.assign(Object.assign({}, (0, cross_1.clone)(args)), selectInclude);
            return this.doDelete(tx, this.model, deleteArgs);
        }));
    }
    deleteMany(args) {
        if (!this.involvesDelegateModel(this.model)) {
            return super.deleteMany(args);
        }
        return this.queryUtils.transaction(this.prisma, (tx) => this.doDeleteMany(tx, this.model, args === null || args === void 0 ? void 0 : args.where));
    }
    doDeleteMany(db, model, where) {
        return __awaiter(this, void 0, void 0, function* () {
            // query existing entities with id
            const idSelection = this.queryUtils.makeIdSelection(model);
            const findArgs = { where: (0, cross_1.clone)(where !== null && where !== void 0 ? where : {}), select: idSelection };
            this.injectWhereHierarchy(model, findArgs.where);
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`deleteMany\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);
            }
            const entities = yield db[model].findMany(findArgs);
            // recursively delete base entities (they all have the same id values)
            yield Promise.all(entities.map((entity) => {
                let deleteFilter = entity;
                if (Object.keys(deleteFilter).length > 1) {
                    // if the model has compound id fields, we need to compose a compound key filter,
                    // otherwise calling Prisma's `delete` won't work
                    deleteFilter = this.queryUtils.composeCompoundUniqueField(model, deleteFilter);
                }
                return this.doDelete(db, model, { where: deleteFilter });
            }));
            return { count: entities.length };
        });
    }
    deleteBaseRecursively(db, model, idValues) {
        return __awaiter(this, void 0, void 0, function* () {
            let base = this.getBaseModel(model);
            while (base) {
                let deleteFilter = idValues;
                if (Object.keys(idValues).length > 1) {
                    // if the model has compound id fields, we need to compose a compound key filter,
                    // otherwise calling Prisma's `delete` won't work
                    deleteFilter = this.queryUtils.composeCompoundUniqueField(base.name, deleteFilter);
                }
                yield db[base.name].delete({ where: deleteFilter });
                base = this.getBaseModel(base.name);
            }
        });
    }
    doDelete(db_1, model_1, args_1) {
        return __awaiter(this, arguments, void 0, function* (db, model, args, readBack = true) {
            this.injectWhereHierarchy(model, args.where);
            yield this.injectSelectIncludeHierarchy(model, args);
            // read relation entities that need to be cascade deleted before deleting the main entity
            const cascadeDeletes = yield this.getRelationDelegateEntitiesForCascadeDelete(db, model, args.where);
            let result = undefined;
            if (cascadeDeletes.length > 0) {
                // we'll need to do cascade deletes of relations, so first
                // read the current entity before anything changes
                if (readBack) {
                    result = yield this.doFind(db, model, 'findUnique', args);
                }
                // process cascade deletes of relations, this ensure their delegate base
                // entities are deleted as well
                yield Promise.all(cascadeDeletes.map(({ model, entity }) => this.doDelete(db, model, { where: entity }, false)));
            }
            if (this.options.logPrismaQuery) {
                this.logger.info(`[delegate] \`delete\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);
            }
            const deleteResult = yield db[model].delete(args);
            if (!result) {
                result = this.assembleHierarchy(model, deleteResult);
            }
            // recursively delete base entities (they all have the same id values)
            const idValues = this.queryUtils.getEntityIds(model, deleteResult);
            yield this.deleteBaseRecursively(db, model, idValues);
            return result;
        });
    }
    getRelationDelegateEntitiesForCascadeDelete(db, model, where) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!where || Object.keys(where).length === 0) {
                throw new Error('where clause is required for cascade delete');
            }
            const cascadeDeletes = [];
            const fields = (0, cross_1.getFields)(this.options.modelMeta, model);
            if (fields) {
                for (const fieldInfo of Object.values(fields)) {
                    if (!fieldInfo.isDataModel) {
                        continue;
                    }
                    if (fieldInfo.isRelationOwner) {
                        // this side of the relation owns the foreign key,
                        // so it won't cause cascade delete to the other side
                        continue;
                    }
                    if (fieldInfo.backLink) {
                        // get the opposite side of the relation
                        const backLinkField = this.queryUtils.getModelField(fieldInfo.type, fieldInfo.backLink);
                        if ((backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) && this.isFieldCascadeDelete(backLinkField)) {
                            // if the opposite side of the relation is to be cascade deleted,
                            // recursively delete the delegate base entities
                            const relationModel = (0, cross_1.getModelInfo)(this.options.modelMeta, fieldInfo.type);
                            if ((relationModel === null || relationModel === void 0 ? void 0 : relationModel.baseTypes) && relationModel.baseTypes.length > 0) {
                                // the relation model has delegate base, cascade the delete to the base
                                const relationEntities = yield db[relationModel.name].findMany({
                                    where: { [backLinkField.name]: where },
                                    select: this.queryUtils.makeIdSelection(relationModel.name),
                                });
                                relationEntities.forEach((entity) => {
                                    cascadeDeletes.push({ model: fieldInfo.type, entity });
                                });
                            }
                        }
                    }
                }
            }
            return cascadeDeletes;
        });
    }
    isFieldCascadeDelete(fieldInfo) {
        return fieldInfo.onDeleteAction === 'Cascade';
    }
    // #endregion
    // #region aggregation
    aggregate(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.aggregate(args);
        }
        // check if any aggregation operator is using fields from base
        this.checkAggregationArgs('aggregate', args);
        args = (0, cross_1.clone)(args);
        if (args.cursor) {
            this.injectWhereHierarchy(this.model, args.cursor);
        }
        if (args.orderBy) {
            (0, cross_1.enumerate)(args.orderBy).forEach((item) => this.injectWhereHierarchy(this.model, item));
        }
        if (args.where) {
            this.injectWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`aggregate\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.aggregate(args);
    }
    count(args) {
        if (!this.involvesDelegateModel(this.model)) {
            return super.count(args);
        }
        // check if count select is using fields from base
        this.checkAggregationArgs('count', args);
        args = (0, cross_1.clone)(args);
        if (args === null || args === void 0 ? void 0 : args.cursor) {
            this.injectWhereHierarchy(this.model, args.cursor);
        }
        if (args === null || args === void 0 ? void 0 : args.where) {
            this.injectWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`count\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.count(args);
    }
    groupBy(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');
        }
        if (!this.involvesDelegateModel(this.model)) {
            return super.groupBy(args);
        }
        // check if count select is using fields from base
        this.checkAggregationArgs('groupBy', args);
        if (args.by) {
            for (const by of (0, cross_1.enumerate)(args.by)) {
                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, by);
                if (fieldInfo && fieldInfo.inheritedFrom) {
                    throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `groupBy with fields from base type is not supported yet: "${by}"`);
                }
            }
        }
        args = (0, cross_1.clone)(args);
        if (args.where) {
            this.injectWhereHierarchy(this.model, args.where);
        }
        if (this.options.logPrismaQuery) {
            this.logger.info(`[delegate] \`groupBy\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);
        }
        return super.groupBy(args);
    }
    checkAggregationArgs(operation, args) {
        if (!args) {
            return;
        }
        for (const op of ['_count', '_sum', '_avg', '_min', '_max', 'select', 'having']) {
            if (args[op] && typeof args[op] === 'object') {
                for (const field of Object.keys(args[op])) {
                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, field);
                    if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {
                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `${operation} with fields from base type is not supported yet: "${field}"`);
                    }
                }
            }
        }
    }
    // #endregion
    // #region utils
    extractSelectInclude(args) {
        if (!args) {
            return undefined;
        }
        args = (0, cross_1.clone)(args);
        return 'select' in args
            ? { select: args['select'] }
            : 'include' in args
                ? { include: args['include'] }
                : undefined;
    }
    makeAuxRelationName(model) {
        var _a;
        const name = `${constants_1.DELEGATE_AUX_RELATION_PREFIX}_${(0, local_helpers_1.lowerCaseFirst)(model.name)}`;
        // make sure we look up into short name map to see if it's truncated
        const shortName = (_a = this.options.modelMeta.shortNameMap) === null || _a === void 0 ? void 0 : _a[name];
        return shortName !== null && shortName !== void 0 ? shortName : name;
    }
    getModelName(model) {
        const info = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        return info.name;
    }
    getIdFields(model) {
        const idFields = (0, cross_1.getIdFields)(this.options.modelMeta, model);
        if (idFields && idFields.length > 0) {
            return idFields;
        }
        const base = this.getBaseModel(model);
        return base ? this.getIdFields(base.name) : [];
    }
    getModelInfo(model) {
        return (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
    }
    getBaseModel(model) {
        const baseNames = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true).baseTypes;
        if (!baseNames) {
            return undefined;
        }
        if (baseNames.length > 1) {
            throw new Error('Multi-inheritance is not supported');
        }
        return this.options.modelMeta.models[(0, local_helpers_1.lowerCaseFirst)(baseNames[0])];
    }
    involvesDelegateModel(model, visited) {
        if (this.isDelegateOrDescendantOfDelegate(model)) {
            return true;
        }
        visited = visited !== null && visited !== void 0 ? visited : new Set();
        if (visited.has(model)) {
            return false;
        }
        visited.add(model);
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        return Object.values(modelInfo.fields).some((field) => field.isDataModel && this.involvesDelegateModel(field.type, visited));
    }
    isDelegateOrDescendantOfDelegate(model) {
        var _a;
        if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {
            return true;
        }
        const baseTypes = (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.baseTypes;
        return !!(baseTypes &&
            baseTypes.length > 0 &&
            baseTypes.some((base) => this.isDelegateOrDescendantOfDelegate(base)));
    }
    assembleHierarchy(model, entity) {
        if (!entity || typeof entity !== 'object') {
            return entity;
        }
        const upMerged = this.assembleUp(model, entity);
        const downMerged = this.assembleDown(model, entity);
        // https://www.npmjs.com/package/deepmerge#arraymerge-example-combine-arrays
        const combineMerge = (target, source, options) => {
            const destination = target.slice();
            source.forEach((item, index) => {
                if (typeof destination[index] === 'undefined') {
                    destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
                }
                else if (options.isMergeableObject(item)) {
                    destination[index] = (0, deepmerge_1.default)(target[index], item, options);
                }
                else if (target.indexOf(item) === -1) {
                    destination.push(item);
                }
            });
            return destination;
        };
        const result = (0, deepmerge_1.default)(upMerged, downMerged, {
            arrayMerge: combineMerge,
            isMergeableObject: (v) => (0, local_helpers_1.isPlainObject)(v) || Array.isArray(v), // avoid messing with Decimal, Date, etc.
        });
        return result;
    }
    assembleUp(model, entity) {
        if (!entity) {
            return entity;
        }
        const result = {};
        const base = this.getBaseModel(model);
        if (base) {
            // fully merge base fields
            const baseRelationName = this.makeAuxRelationName(base);
            const baseData = entity[baseRelationName];
            if (baseData && typeof baseData === 'object') {
                const baseAssembled = this.assembleHierarchy(base.name, baseData);
                Object.assign(result, baseAssembled);
            }
        }
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        for (const [key, value] of Object.entries(entity)) {
            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {
                continue;
            }
            const field = modelInfo.fields[key];
            if (!field) {
                // not a field, could be `_count`, `_sum`, etc.
                result[key] = value;
                continue;
            }
            if (field.inheritedFrom) {
                // already merged from base
                continue;
            }
            if (field.isDataModel) {
                if (Array.isArray(value)) {
                    result[field.name] = value.map((item) => this.assembleUp(field.type, item));
                }
                else {
                    result[field.name] = this.assembleUp(field.type, value);
                }
            }
            else {
                result[field.name] = value;
            }
        }
        return result;
    }
    assembleDown(model, entity) {
        if (!entity) {
            return entity;
        }
        const result = {};
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);
        if (modelInfo.discriminator) {
            // model is a delegate, fully merge concrete model fields
            const subModelName = entity[modelInfo.discriminator];
            if (subModelName) {
                const subModel = (0, cross_1.getModelInfo)(this.options.modelMeta, subModelName, true);
                const subRelationName = this.makeAuxRelationName(subModel);
                const subData = entity[subRelationName];
                if (subData && typeof subData === 'object') {
                    const subAssembled = this.assembleHierarchy(subModel.name, subData);
                    Object.assign(result, subAssembled);
                }
            }
        }
        for (const [key, value] of Object.entries(entity)) {
            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {
                continue;
            }
            const field = modelInfo.fields[key];
            if (!field) {
                // not a field, could be `_count`, `_sum`, etc.
                result[key] = value;
                continue;
            }
            if (field.isDataModel) {
                if (Array.isArray(value)) {
                    result[field.name] = value.map((item) => this.assembleDown(field.type, item));
                }
                else {
                    result[field.name] = this.assembleDown(field.type, value);
                }
            }
            else {
                result[field.name] = value;
            }
        }
        return result;
    }
    getUpdatedAtFromDelegateBases(model) {
        var _a;
        const result = [];
        const modelFields = (0, cross_1.getFields)(this.options.modelMeta, model);
        if (!modelFields) {
            return result;
        }
        for (const fieldInfo of Object.values(modelFields)) {
            if (((_a = fieldInfo.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@updatedAt')) &&
                fieldInfo.inheritedFrom &&
                (0, cross_1.isDelegateModel)(this.options.modelMeta, fieldInfo.inheritedFrom)) {
                result.push(fieldInfo);
            }
        }
        return result;
    }
}
exports.DelegateProxyHandler = DelegateProxyHandler;
//# sourceMappingURL=delegate.js.map