"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_46ABODUM_exports = {};
__export(chunk_46ABODUM_exports, {
  getEnvPaths: () => getEnvPaths
});
module.exports = __toCommonJS(chunk_46ABODUM_exports);
var import_chunk_3FP46GUV = require("./chunk-3FP46GUV.js");
var import_chunk_EYVG6XQS = require("./chunk-EYVG6XQS.js");
var import_debug = __toESM(require("@prisma/debug"));
var import_node_path = __toESM(require("node:path"));
var import_node_process = __toESM(require("node:process"));
var import_node_path2 = __toESM(require("node:path"));
var import_node_fs = __toESM(require("node:fs"));
var import_node_url = require("node:url");
var import_node_url2 = require("node:url");
var import_node_fs2 = __toESM(require("node:fs"));
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var typeMappings = {
  directory: "isDirectory",
  file: "isFile"
};
function checkType(type) {
  if (Object.hasOwnProperty.call(typeMappings, type)) {
    return;
  }
  throw new Error(`Invalid type specified: ${type}`);
}
var matchType = (type, stat) => stat[typeMappings[type]]();
var toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath;
function locatePathSync(paths, {
  cwd = import_node_process.default.cwd(),
  type = "file",
  allowSymlinks = true
} = {}) {
  checkType(type);
  cwd = toPath(cwd);
  const statFunction = allowSymlinks ? import_node_fs.default.statSync : import_node_fs.default.lstatSync;
  for (const path_ of paths) {
    try {
      const stat = statFunction(import_node_path2.default.resolve(cwd, path_), {
        throwIfNoEntry: false
      });
      if (!stat) {
        continue;
      }
      if (matchType(type, stat)) {
        return path_;
      }
    } catch {
    }
  }
}
function toPath2(urlOrPath) {
  return urlOrPath instanceof URL ? (0, import_node_url2.fileURLToPath)(urlOrPath) : urlOrPath;
}
function pathExistsSync(path4) {
  try {
    import_node_fs2.default.accessSync(path4);
    return true;
  } catch {
    return false;
  }
}
var findUpStop = Symbol("findUpStop");
function findUpMultipleSync(name, options = {}) {
  let directory = import_node_path.default.resolve(toPath2(options.cwd) ?? "");
  const { root } = import_node_path.default.parse(directory);
  const stopAt = import_node_path.default.resolve(directory, toPath2(options.stopAt) ?? root);
  const limit = options.limit ?? Number.POSITIVE_INFINITY;
  const paths = [name].flat();
  const runMatcher = (locateOptions) => {
    if (typeof name !== "function") {
      return locatePathSync(paths, locateOptions);
    }
    const foundPath = name(locateOptions.cwd);
    if (typeof foundPath === "string") {
      return locatePathSync([foundPath], locateOptions);
    }
    return foundPath;
  };
  const matches = [];
  while (true) {
    const foundPath = runMatcher({ ...options, cwd: directory });
    if (foundPath === findUpStop) {
      break;
    }
    if (foundPath) {
      matches.push(import_node_path.default.resolve(directory, foundPath));
    }
    if (directory === stopAt || matches.length >= limit) {
      break;
    }
    directory = import_node_path.default.dirname(directory);
  }
  return matches;
}
function findUpSync(name, options = {}) {
  const matches = findUpMultipleSync(name, { ...options, limit: 1 });
  return matches[0];
}
var debug = (0, import_debug.default)("prisma:loadEnv");
async function getEnvPaths(schemaPath, opts = { cwd: process.cwd() }) {
  const rootEnvPath = getProjectRootEnvPath({ cwd: opts.cwd }) ?? null;
  const schemaEnvPathFromArgs = schemaPathToEnvPath(schemaPath);
  const schemaEnvPathFromPkgJson = schemaPathToEnvPath(await readSchemaPathFromPkgJson());
  const schemaEnvPaths = [
    schemaEnvPathFromArgs,
    // 1 - Check --schema directory for .env
    schemaEnvPathFromPkgJson,
    // 2 - Check package.json schema directory for .env
    "./prisma/.env",
    // 3 - Check ./prisma directory for .env
    "./.env"
    // 4 - Check cwd for .env
  ];
  const schemaEnvPath = schemaEnvPaths.find(import_chunk_3FP46GUV.exists);
  return { rootEnvPath, schemaEnvPath };
}
async function readSchemaPathFromPkgJson() {
  try {
    const pkgJsonSchema = await (0, import_chunk_EYVG6XQS.getSchemaFromPackageJson)(process.cwd());
    if (pkgJsonSchema.ok) {
      pkgJsonSchema.schema.schemaPath;
    }
    return null;
  } catch {
    return null;
  }
}
function getProjectRootEnvPath(opts) {
  const pkgJsonPath = findUpSync((dir) => {
    const pkgPath = import_path.default.join(dir, "package.json");
    if (pathExistsSync(pkgPath)) {
      try {
        const pkg = JSON.parse(import_fs.default.readFileSync(pkgPath, "utf8"));
        if (pkg["name"] !== ".prisma/client") {
          debug(`project root found at ${pkgPath}`);
          return pkgPath;
        }
      } catch (e) {
        debug(`skipping package.json at ${pkgPath}`);
      }
    }
    return void 0;
  }, opts);
  if (!pkgJsonPath) {
    return null;
  }
  const candidate = import_path.default.join(import_path.default.dirname(pkgJsonPath), ".env");
  if (!import_fs.default.existsSync(candidate)) {
    return null;
  }
  return candidate;
}
function schemaPathToEnvPath(schemaPath) {
  if (!schemaPath) return null;
  return import_path.default.join(import_path.default.dirname(schemaPath), ".env");
}
