"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_GMW36QQF_exports = {};
__export(chunk_GMW36QQF_exports, {
  getEnginesInfo: () => getEnginesInfo,
  resolveEngine: () => resolveEngine
});
module.exports = __toCommonJS(chunk_GMW36QQF_exports);
var import_chunk_OAT7ZJED = require("./chunk-OAT7ZJED.js");
var import_chunk_R6QH57HZ = require("./chunk-R6QH57HZ.js");
var import_chunk_FYZCPL2Z = require("./chunk-FYZCPL2Z.js");
var import_chunk_5DBOS77Y = require("./chunk-5DBOS77Y.js");
var import_chunk_XKZ6CBLA = require("./chunk-XKZ6CBLA.js");
var import_chunk_4VNS5WPM = require("./chunk-4VNS5WPM.js");
var import_fetch_engine = require("@prisma/fetch-engine");
var import_path = __toESM(require("path"));
var import_function2 = (0, import_chunk_4VNS5WPM.__toESM)((0, import_chunk_R6QH57HZ.require_function)());
var none2 = import_chunk_5DBOS77Y.none;
var some2 = import_chunk_5DBOS77Y.some;
var getRight = function(ma) {
  return ma._tag === "Left" ? none2 : some2(ma.right);
};
var _map = function(fa, f) {
  return (0, import_chunk_5DBOS77Y.pipe)(fa, map(f));
};
var _ap = function(fab, fa) {
  return (0, import_chunk_5DBOS77Y.pipe)(fab, ap(fa));
};
var URI = "Option";
var map = function(f) {
  return function(fa) {
    return isNone(fa) ? none2 : some2(f(fa.value));
  };
};
var Functor = {
  URI,
  map: _map
};
var as2 = (0, import_chunk_5DBOS77Y.dual)(2, (0, import_chunk_5DBOS77Y.as)(Functor));
var asUnit2 = (0, import_chunk_5DBOS77Y.asUnit)(Functor);
var ap = function(fa) {
  return function(fab) {
    return isNone(fab) ? none2 : isNone(fa) ? none2 : some2(fab.value(fa.value));
  };
};
var flatMap = /* @__PURE__ */ (0, import_chunk_5DBOS77Y.dual)(2, function(ma, f) {
  return isNone(ma) ? none2 : f(ma.value);
});
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var orElse = (0, import_chunk_5DBOS77Y.dual)(2, function(self, that) {
  return isNone(self) ? that() : self;
});
var fromEither2 = getRight;
var FromEither = {
  URI,
  fromEither: fromEither2
};
var isSome2 = import_chunk_5DBOS77Y.isSome;
var isNone = function(fa) {
  return fa._tag === "None";
};
var matchW = function(onNone, onSome) {
  return function(ma) {
    return isNone(ma) ? onNone() : onSome(ma.value);
  };
};
var match = matchW;
var fold = match;
var tap2 = /* @__PURE__ */ (0, import_chunk_5DBOS77Y.dual)(2, (0, import_chunk_5DBOS77Y.tap)(Chain));
var tapEither2 = /* @__PURE__ */ (0, import_chunk_5DBOS77Y.dual)(2, (0, import_chunk_5DBOS77Y.tapEither)(FromEither, Chain));
var fromNullable = function(a) {
  return a == null ? none2 : some2(a);
};
function getEnginesInfo(enginesInfo) {
  const errors = [];
  const resolved = (0, import_chunk_XKZ6CBLA.z)(enginesInfo).with({ fromEnvVar: import_chunk_XKZ6CBLA.N.when(isSome2) }, (_engineInfo) => {
    return `, resolved by ${_engineInfo.fromEnvVar.value}`;
  }).otherwise(() => "");
  const absolutePath = (0, import_chunk_XKZ6CBLA.z)(enginesInfo).with({ path: import_chunk_XKZ6CBLA.N.when(import_chunk_5DBOS77Y.isRight) }, (_engineInfo) => {
    return _engineInfo.path.right;
  }).with({ path: import_chunk_XKZ6CBLA.N.when(import_chunk_5DBOS77Y.isLeft) }, (_engineInfo) => {
    errors.push(_engineInfo.path.left);
    return "E_CANNOT_RESOLVE_PATH";
  }).exhaustive();
  const version = (0, import_chunk_XKZ6CBLA.z)(enginesInfo).with({ version: import_chunk_XKZ6CBLA.N.when(import_chunk_5DBOS77Y.isRight) }, (_engineInfo) => {
    return _engineInfo.version.right;
  }).with({ version: import_chunk_XKZ6CBLA.N.when(import_chunk_5DBOS77Y.isLeft) }, (_engineInfo) => {
    errors.push(_engineInfo.version.left);
    return "E_CANNOT_RESOLVE_VERSION";
  }).exhaustive();
  const versionMessage = `${version} (at ${import_path.default.relative(process.cwd(), absolutePath)}${resolved})`;
  return [versionMessage, errors];
}
async function resolveEngine(binaryName) {
  const pathFromEnvOption = fromNullable((0, import_fetch_engine.getBinaryEnvVarPath)(binaryName));
  const fromEnvVarOption = (0, import_function2.pipe)(
    pathFromEnvOption,
    map((p) => p.fromEnvVar)
  );
  const enginePathEither = await (0, import_function2.pipe)(
    pathFromEnvOption,
    fold(
      () => (0, import_chunk_FYZCPL2Z.safeResolveBinary)(binaryName),
      (pathFromEnv) => (0, import_chunk_5DBOS77Y.right2)(pathFromEnv.path)
    )
  )();
  const versionEither = await (0, import_function2.pipe)(
    enginePathEither,
    import_chunk_5DBOS77Y.fromEither,
    (0, import_chunk_5DBOS77Y.chain)((enginePath) => {
      return (0, import_chunk_OAT7ZJED.safeGetEngineVersion)(enginePath, binaryName);
    })
  )();
  const engineInfo = {
    path: enginePathEither,
    version: versionEither,
    fromEnvVar: fromEnvVarOption
  };
  return engineInfo;
}
