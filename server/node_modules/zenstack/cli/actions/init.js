"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = init;
const colors_1 = __importDefault(require("colors"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const package_json_1 = __importDefault(require("../../package.json"));
const pkg_utils_1 = require("../../utils/pkg-utils");
const version_utils_1 = require("../../utils/version-utils");
const cli_error_1 = require("../cli-error");
const cli_util_1 = require("../cli-util");
/**
 * CLI action for initializing an existing project
 */
function init(projectPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!fs_1.default.existsSync(projectPath)) {
            console.error(`Path does not exist: ${projectPath}`);
            throw new cli_error_1.CliError('project path does not exist');
        }
        const defaultPrismaSchemaLocation = './prisma/schema.prisma';
        let prismaSchema = options.prisma;
        if (prismaSchema) {
            if (!fs_1.default.existsSync(prismaSchema)) {
                console.error(`Prisma schema file does not exist: ${prismaSchema}`);
                throw new cli_error_1.CliError('prisma schema does not exist');
            }
        }
        else if (fs_1.default.existsSync(defaultPrismaSchemaLocation)) {
            prismaSchema = defaultPrismaSchemaLocation;
        }
        const zmodelFile = path_1.default.join(projectPath, './schema.zmodel');
        let sampleModelGenerated = false;
        if (fs_1.default.existsSync(zmodelFile)) {
            console.warn(`ZenStack model already exists at ${zmodelFile}, not generating a new one.`);
        }
        else {
            if (prismaSchema) {
                // copy over schema.prisma
                fs_1.default.copyFileSync(prismaSchema, zmodelFile);
            }
            else {
                // create a new model
                const starterContent = fs_1.default.readFileSync(path_1.default.join(__dirname, '../../res/starter.txt'), 'utf-8');
                fs_1.default.writeFileSync(zmodelFile, starterContent);
                sampleModelGenerated = true;
            }
        }
        const latestSupportedPrismaVersion = getLatestSupportedPrismaVersion();
        (0, pkg_utils_1.ensurePackage)('prisma', true, options.packageManager, latestSupportedPrismaVersion, projectPath);
        (0, pkg_utils_1.ensurePackage)('@prisma/client', false, options.packageManager, latestSupportedPrismaVersion, projectPath);
        const tag = (_a = options.tag) !== null && _a !== void 0 ? _a : (0, version_utils_1.getVersion)();
        (0, pkg_utils_1.installPackage)('zenstack', true, options.packageManager, tag, projectPath);
        (0, pkg_utils_1.installPackage)('@zenstackhq/runtime', false, options.packageManager, tag, projectPath);
        if (sampleModelGenerated) {
            console.log(`Sample model generated at: ${colors_1.default.blue(zmodelFile)}

Learn how to use ZenStack: https://zenstack.dev/docs.`);
        }
        else if (prismaSchema) {
            console.log(`Your current Prisma schema "${prismaSchema}" has been copied to "${zmodelFile}".
Moving forward please edit this file and run "zenstack generate" to regenerate Prisma schema.`);
        }
        console.log(colors_1.default.green('\nProject initialized successfully!'));
        if (options.versionCheck) {
            yield (0, cli_util_1.checkNewVersion)();
        }
    });
}
function getLatestSupportedPrismaVersion() {
    const versionSpec = package_json_1.default.peerDependencies.prisma;
    let maxVersion;
    const hyphen = versionSpec.indexOf('-');
    if (hyphen > 0) {
        maxVersion = versionSpec.substring(hyphen + 1).trim();
    }
    else {
        maxVersion = versionSpec;
    }
    return maxVersion !== null && maxVersion !== void 0 ? maxVersion : 'latest';
}
//# sourceMappingURL=init.js.map