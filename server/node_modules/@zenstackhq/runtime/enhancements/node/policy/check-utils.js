"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPermission = checkPermission;
const ts_pattern_1 = require("ts-pattern");
const __1 = require("..");
const promise_1 = require("../promise");
const utils_1 = require("../utils");
const constraint_solver_1 = require("./constraint-solver");
function checkPermission(model, args, modelMeta, policyUtils, prisma, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
prismaModule) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, promise_1.createDeferredPromise)(() => doCheckPermission(model, args, modelMeta, policyUtils, prisma, prismaModule));
    });
}
function doCheckPermission(model, args, modelMeta, policyUtils, prisma, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
prismaModule) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!['create', 'read', 'update', 'delete'].includes(args.operation)) {
            throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Invalid "operation" ${args.operation}`);
        }
        let constraint = policyUtils.getCheckerConstraint(model, args.operation);
        if (typeof constraint === 'boolean') {
            return constraint;
        }
        if (args.where) {
            // combine runtime filters with generated constraints
            const extraConstraints = [];
            for (const [field, value] of Object.entries(args.where)) {
                if (value === undefined) {
                    continue;
                }
                if (value === null) {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Using "null" as filter value is not supported yet`);
                }
                const fieldInfo = (0, __1.requireField)(modelMeta, model, field);
                // relation and array fields are not supported
                if (fieldInfo.isDataModel || fieldInfo.isArray) {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Providing filter for field "${field}" is not supported. Only scalar fields are allowed.`);
                }
                // map field type to constraint type
                const fieldType = (0, ts_pattern_1.match)(fieldInfo.type)
                    .with(ts_pattern_1.P.union('Int', 'BigInt', 'Float', 'Decimal'), () => 'number')
                    .with('String', () => 'string')
                    .with('Boolean', () => 'boolean')
                    .otherwise(() => {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Providing filter for field "${field}" is not supported. Only number, string, and boolean fields are allowed.`);
                });
                // check value type
                const valueType = typeof value;
                if (valueType !== 'number' && valueType !== 'string' && valueType !== 'boolean') {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Invalid value type for field "${field}". Only number, string or boolean is allowed.`);
                }
                if (fieldType !== valueType) {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Invalid value type for field "${field}". Expected "${fieldType}".`);
                }
                // check number validity
                if (typeof value === 'number' && (!Number.isInteger(value) || value < 0)) {
                    throw (0, utils_1.prismaClientValidationError)(prisma, prismaModule, `Invalid value for field "${field}". Only non-negative integers are allowed.`);
                }
                // build a constraint
                extraConstraints.push({
                    kind: 'eq',
                    left: { kind: 'variable', name: field, type: fieldType },
                    right: { kind: 'value', value, type: fieldType },
                });
            }
            if (extraConstraints.length > 0) {
                // combine the constraints
                constraint = { kind: 'and', children: [constraint, ...extraConstraints] };
            }
        }
        // check satisfiability
        return new constraint_solver_1.ConstraintSolver().checkSat(constraint);
    });
}
//# sourceMappingURL=check-utils.js.map