"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryUtils = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const cross_1 = require("../../cross");
const version_1 = require("../../version");
const edge_1 = require("../edge");
const logger_1 = require("./logger");
const utils_1 = require("./utils");
class QueryUtils {
    constructor(prisma, options) {
        this.prisma = prisma;
        this.options = options;
        this.logger = new logger_1.Logger(prisma);
    }
    getIdFields(model) {
        return (0, cross_1.getIdFields)(this.options.modelMeta, model, true);
    }
    makeIdSelection(model) {
        const idFields = this.getIdFields(model);
        return Object.assign({}, ...idFields.map((f) => ({ [f.name]: true })));
    }
    getEntityIds(model, entityData) {
        const idFields = this.getIdFields(model);
        const result = {};
        for (const idField of idFields) {
            result[idField.name] = entityData[idField.name];
        }
        return result;
    }
    /**
     * Initiates a transaction.
     */
    transaction(db, action) {
        const fullDb = db;
        if (fullDb['$transaction']) {
            return fullDb.$transaction((tx) => {
                tx[Symbol.for('nodejs.util.inspect.custom')] = 'PrismaClient$tx';
                return action(tx);
            }, {
                maxWait: this.options.transactionMaxWait,
                timeout: this.options.transactionTimeout,
                isolationLevel: this.options.transactionIsolationLevel,
            });
        }
        else {
            // already in transaction, don't nest
            return action(db);
        }
    }
    /**
     * Builds a reversed query for the given nested path.
     */
    buildReversedQuery(db_1, context_1) {
        return __awaiter(this, arguments, void 0, function* (db, context, forMutationPayload = false, uncheckedOperation = false) {
            let result, currQuery;
            let currField;
            for (let i = context.nestingPath.length - 1; i >= 0; i--) {
                const { field, model, where } = context.nestingPath[i];
                // never modify the original where because it's shared in the structure
                const visitWhere = Object.assign({}, where);
                if (model && where) {
                    // make sure composite unique condition is flattened
                    this.flattenGeneratedUniqueField(model, visitWhere);
                }
                if (!result) {
                    // first segment (bottom), just use its where clause
                    result = currQuery = Object.assign({}, visitWhere);
                    currField = field;
                }
                else {
                    if (!currField) {
                        throw this.unknownError(`missing field in nested path`);
                    }
                    if (!currField.backLink) {
                        throw this.unknownError(`field ${currField.type}.${currField.name} doesn't have a backLink`);
                    }
                    const backLinkField = this.getModelField(currField.type, currField.backLink);
                    if (!backLinkField) {
                        throw this.unknownError(`missing backLink field ${currField.backLink} in ${currField.type}`);
                    }
                    if (backLinkField.isArray && !forMutationPayload) {
                        // many-side of relationship, wrap with "some" query
                        currQuery[currField.backLink] = { some: Object.assign({}, visitWhere) };
                        currQuery = currQuery[currField.backLink].some;
                    }
                    else {
                        const fkMapping = where && backLinkField.isRelationOwner && backLinkField.foreignKeyMapping;
                        // calculate if we should preserve the relation condition (e.g., { user: { id: 1 } })
                        const shouldPreserveRelationCondition = 
                        // doing a mutation
                        forMutationPayload &&
                            // and it's not an unchecked mutate
                            !uncheckedOperation &&
                            // and the current segment is the direct parent (the last one is the mutate itself),
                            // the relation condition should be preserved and will be converted to a "connect" later
                            i === context.nestingPath.length - 2;
                        if (fkMapping && !shouldPreserveRelationCondition) {
                            // turn relation condition into foreign key condition, e.g.:
                            //     { user: { id: 1 } } => { userId: 1 }
                            let parentPk = visitWhere;
                            if (Object.keys(fkMapping).some((k) => !(k in parentPk) || parentPk[k] === undefined)) {
                                // it can happen that the parent condition actually doesn't contain all id fields
                                // ï¼ˆwhen the parent condition is not a primary key but unique constraints)
                                // and in such case we need to load it to get the pks
                                if (this.options.logPrismaQuery && this.logger.enabled('info')) {
                                    this.logger.info(`[reverseLookup] \`findUniqueOrThrow\` ${model}: ${(0, edge_1.formatObject)(where)}`);
                                }
                                parentPk = yield db[model].findUniqueOrThrow({
                                    where,
                                    select: this.makeIdSelection(model),
                                });
                            }
                            for (const [r, fk] of Object.entries(fkMapping)) {
                                currQuery[fk] = parentPk[r];
                            }
                            if (i > 0) {
                                // prepare for the next segment
                                currQuery[currField.backLink] = {};
                            }
                        }
                        else {
                            // preserve the original structure
                            currQuery[currField.backLink] = Object.assign({}, visitWhere);
                        }
                        if (forMutationPayload && currQuery[currField.backLink]) {
                            // reconstruct compound unique field
                            currQuery[currField.backLink] = this.composeCompoundUniqueField(backLinkField.type, currQuery[currField.backLink]);
                        }
                        currQuery = currQuery[currField.backLink];
                    }
                    currField = field;
                }
            }
            return result;
        });
    }
    /**
     * Composes a compound unique field from multiple fields. E.g.:  { a: '1', b: '1' } => { a_b: { a: '1', b: '1' } }.
     */
    composeCompoundUniqueField(model, fieldData) {
        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);
        if (!uniqueConstraints) {
            return fieldData;
        }
        const result = this.safeClone(fieldData);
        for (const [name, constraint] of Object.entries(uniqueConstraints)) {
            if (constraint.fields.length > 1 && constraint.fields.every((f) => fieldData[f] !== undefined)) {
                // multi-field unique constraint, compose it
                result[name] = constraint.fields.reduce((prev, field) => (Object.assign(Object.assign({}, prev), { [field]: fieldData[field] })), {});
                constraint.fields.forEach((f) => delete result[f]);
            }
        }
        return result;
    }
    /**
     * Flattens a generated unique field. E.g.: { a_b: { a: '1', b: '1' } } => { a: '1', b: '1' }.
     */
    flattenGeneratedUniqueField(model, args) {
        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);
        if (uniqueConstraints && Object.keys(uniqueConstraints).length > 0) {
            for (const [field, value] of Object.entries(args)) {
                if (uniqueConstraints[field] &&
                    uniqueConstraints[field].fields.length > 1 &&
                    typeof value === 'object') {
                    // multi-field unique constraint, flatten it
                    delete args[field];
                    if (value) {
                        for (const [f, v] of Object.entries(value)) {
                            args[f] = v;
                        }
                    }
                }
            }
        }
    }
    validationError(message) {
        return (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, message);
    }
    unknownError(message) {
        return (0, utils_1.prismaClientUnknownRequestError)(this.prisma, this.options.prismaModule, message, {
            clientVersion: (0, version_1.getVersion)(),
        });
    }
    getModelFields(model) {
        var _a;
        return (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.fields;
    }
    /**
     * Gets information for a specific model field.
     */
    getModelField(model, field) {
        return (0, cross_1.resolveField)(this.options.modelMeta, model, field);
    }
    /**
     * Clones an object and makes sure it's not empty.
     */
    safeClone(value) {
        return value ? (0, cross_1.clone)(value) : value === undefined || value === null ? {} : value;
    }
    getDelegateConcreteModel(model, data) {
        if (!data || typeof data !== 'object') {
            return model;
        }
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);
        if (modelInfo === null || modelInfo === void 0 ? void 0 : modelInfo.discriminator) {
            // model has a discriminator so it can be a polymorphic base,
            // need to find the concrete model
            const concreteModelName = data[modelInfo.discriminator];
            if (typeof concreteModelName === 'string' && concreteModelName) {
                return concreteModelName;
            }
        }
        return model;
    }
    /**
     * Gets relation info for a foreign key field.
     */
    getRelationForForeignKey(model, fkField) {
        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);
        if (!modelInfo) {
            return undefined;
        }
        for (const field of Object.values(modelInfo.fields)) {
            if (field.foreignKeyMapping) {
                const entry = Object.entries(field.foreignKeyMapping).find(([, v]) => v === fkField);
                if (entry) {
                    return { relation: field, idField: entry[0], fkField: entry[1] };
                }
            }
        }
        return undefined;
    }
    /**
     * Gets fields of object with defined values.
     */
    getFieldsWithDefinedValues(data) {
        if (!data) {
            return [];
        }
        return Object.entries(data)
            .filter(([, v]) => v !== undefined)
            .map(([k]) => k);
    }
}
exports.QueryUtils = QueryUtils;
//# sourceMappingURL=query-utils.js.map