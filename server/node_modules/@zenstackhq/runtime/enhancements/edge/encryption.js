"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withEncrypted = withEncrypted;
const constants_1 = require("../../constants");
const cross_1 = require("../../cross");
const encryption_1 = require("../../encryption");
const logger_1 = require("./logger");
const proxy_1 = require("./proxy");
const query_utils_1 = require("./query-utils");
/**
 * Gets an enhanced Prisma client that supports `@encrypted` attribute.
 *
 * @private
 */
function withEncrypted(prisma, options) {
    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new EncryptedHandler(_prisma, model, options), 'encryption');
}
class EncryptedHandler extends proxy_1.DefaultPrismaProxyHandler {
    constructor(prisma, model, options) {
        super(prisma, model, options);
        this.decryptionKeys = [];
        this.queryUtils = new query_utils_1.QueryUtils(prisma, options);
        this.logger = new logger_1.Logger(prisma);
        if (!options.encryption) {
            throw this.queryUtils.unknownError('Encryption options must be provided');
        }
        if (this.isCustomEncryption(options.encryption)) {
            if (!options.encryption.encrypt || !options.encryption.decrypt) {
                throw this.queryUtils.unknownError('Custom encryption must provide encrypt and decrypt functions');
            }
        }
        else {
            if (!options.encryption.encryptionKey) {
                throw this.queryUtils.unknownError('Encryption key must be provided');
            }
            this.encrypter = new encryption_1.Encrypter(options.encryption.encryptionKey);
            this.decrypter = new encryption_1.Decrypter([
                options.encryption.encryptionKey,
                ...(options.encryption.decryptionKeys || []),
            ]);
        }
    }
    isCustomEncryption(encryption) {
        return 'encrypt' in encryption && 'decrypt' in encryption;
    }
    encrypt(field, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCustomEncryption(this.options.encryption)) {
                return this.options.encryption.encrypt(this.model, field, data);
            }
            return this.encrypter.encrypt(data);
        });
    }
    decrypt(field, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCustomEncryption(this.options.encryption)) {
                return this.options.encryption.decrypt(this.model, field, data);
            }
            return this.decrypter.decrypt(data);
        });
    }
    // base override
    preprocessArgs(action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args && constants_1.ACTIONS_WITH_WRITE_PAYLOAD.includes(action)) {
                yield this.preprocessWritePayload(this.model, action, args);
            }
            return args;
        });
    }
    // base override
    processResultEntity(method, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data || typeof data !== 'object') {
                return data;
            }
            for (const value of (0, cross_1.enumerate)(data)) {
                yield this.doPostProcess(value, this.model);
            }
            return data;
        });
    }
    doPostProcess(entityData, model) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const realModel = this.queryUtils.getDelegateConcreteModel(model, entityData);
            for (const field of (0, cross_1.getModelFields)(entityData)) {
                // don't decrypt null, undefined or empty string values
                if (!entityData[field])
                    continue;
                const fieldInfo = yield (0, cross_1.resolveField)(this.options.modelMeta, realModel, field);
                if (!fieldInfo) {
                    continue;
                }
                if (fieldInfo.isDataModel) {
                    const items = fieldInfo.isArray && Array.isArray(entityData[field]) ? entityData[field] : [entityData[field]];
                    for (const item of items) {
                        // recurse
                        yield this.doPostProcess(item, fieldInfo.type);
                    }
                }
                else {
                    const shouldDecrypt = (_a = fieldInfo.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.name === '@encrypted');
                    if (shouldDecrypt) {
                        try {
                            entityData[field] = yield this.decrypt(fieldInfo, entityData[field]);
                        }
                        catch (error) {
                            this.logger.warn(`Decryption failed, keeping original value: ${error}`);
                        }
                    }
                }
            }
        });
    }
    preprocessWritePayload(model, action, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {
                field: (field, _action, data, context) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    // don't encrypt null, undefined or empty string values
                    if (!data)
                        return;
                    const encAttr = (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.name === '@encrypted');
                    if (encAttr && field.type === 'String') {
                        try {
                            context.parent[field.name] = yield this.encrypt(field, data);
                        }
                        catch (error) {
                            this.queryUtils.unknownError(`Encryption failed for field ${field.name}: ${error}`);
                        }
                    }
                }),
            });
            yield visitor.visit(model, action, args);
        });
    }
}
//# sourceMappingURL=encryption.js.map