"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decrypter = exports.Encrypter = void 0;
const utils_1 = require("./utils");
/**
 * Default encrypter
 */
class Encrypter {
    constructor(encryptionKey) {
        this.encryptionKey = encryptionKey;
        if (encryptionKey.length !== utils_1.ENCRYPTION_KEY_BYTES) {
            throw new Error(`Encryption key must be ${utils_1.ENCRYPTION_KEY_BYTES} bytes`);
        }
    }
    /**
     * Encrypts the given data
     */
    encrypt(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.key) {
                this.key = yield (0, utils_1.loadKey)(this.encryptionKey, ['encrypt']);
            }
            if (!this.keyDigest) {
                this.keyDigest = yield (0, utils_1.getKeyDigest)(this.encryptionKey);
            }
            return (0, utils_1._encrypt)(data, this.key, this.keyDigest);
        });
    }
}
exports.Encrypter = Encrypter;
/**
 * Default decrypter
 */
class Decrypter {
    constructor(decryptionKeys) {
        this.decryptionKeys = decryptionKeys;
        this.keys = [];
        if (decryptionKeys.length === 0) {
            throw new Error('At least one decryption key must be provided');
        }
        for (const key of decryptionKeys) {
            if (key.length !== utils_1.ENCRYPTION_KEY_BYTES) {
                throw new Error(`Decryption key must be ${utils_1.ENCRYPTION_KEY_BYTES} bytes`);
            }
        }
    }
    /**
     * Decrypts the given data
     */
    decrypt(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keys.length === 0) {
                this.keys = yield Promise.all(this.decryptionKeys.map((key) => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        key: yield (0, utils_1.loadKey)(key, ['decrypt']),
                        digest: yield (0, utils_1.getKeyDigest)(key),
                    });
                })));
            }
            return (0, utils_1._decrypt)(data, (digest) => __awaiter(this, void 0, void 0, function* () { return this.keys.filter((entry) => entry.digest === digest).map((entry) => entry.key); }));
        });
    }
}
exports.Decrypter = Decrypter;
//# sourceMappingURL=index.js.map