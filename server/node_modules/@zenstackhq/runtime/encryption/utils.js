"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KEY_DIGEST_BYTES = exports.ALGORITHM = exports.IV_BYTES = exports.ENCRYPTION_KEY_BYTES = exports.ENCRYPTER_VERSION = void 0;
exports.loadKey = loadKey;
exports.getKeyDigest = getKeyDigest;
exports._encrypt = _encrypt;
exports._decrypt = _decrypt;
const zod_1 = require("zod");
exports.ENCRYPTER_VERSION = 1;
exports.ENCRYPTION_KEY_BYTES = 32;
exports.IV_BYTES = 12;
exports.ALGORITHM = 'AES-GCM';
exports.KEY_DIGEST_BYTES = 8;
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const encryptionMetaSchema = zod_1.z.object({
    // version
    v: zod_1.z.number(),
    // algorithm
    a: zod_1.z.string(),
    // key digest
    k: zod_1.z.string(),
});
function loadKey(key, keyUsages) {
    return __awaiter(this, void 0, void 0, function* () {
        return crypto.subtle.importKey('raw', key, exports.ALGORITHM, false, keyUsages);
    });
}
function getKeyDigest(key) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawDigest = yield crypto.subtle.digest('SHA-256', key);
        return new Uint8Array(rawDigest.slice(0, exports.KEY_DIGEST_BYTES)).reduce((acc, byte) => acc + byte.toString(16).padStart(2, '0'), '');
    });
}
function _encrypt(data, key, keyDigest) {
    return __awaiter(this, void 0, void 0, function* () {
        const iv = crypto.getRandomValues(new Uint8Array(exports.IV_BYTES));
        const encrypted = yield crypto.subtle.encrypt({
            name: exports.ALGORITHM,
            iv,
        }, key, encoder.encode(data));
        // combine IV and encrypted data into a single array of bytes
        const cipherBytes = [...iv, ...new Uint8Array(encrypted)];
        // encryption metadata
        const meta = { v: exports.ENCRYPTER_VERSION, a: exports.ALGORITHM, k: keyDigest };
        // convert concatenated result to base64 string
        return `${btoa(JSON.stringify(meta))}.${btoa(String.fromCharCode(...cipherBytes))}`;
    });
}
function _decrypt(data, findKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const [metaText, cipherText] = data.split('.');
        if (!metaText || !cipherText) {
            throw new Error('Malformed encrypted data');
        }
        let metaObj;
        try {
            metaObj = JSON.parse(atob(metaText));
        }
        catch (error) {
            throw new Error('Malformed metadata');
        }
        // parse meta
        const { a: algorithm, k: keyDigest } = encryptionMetaSchema.parse(metaObj);
        // find a matching decryption key
        const keys = yield findKey(keyDigest);
        if (keys.length === 0) {
            throw new Error('No matching decryption key found');
        }
        // convert base64 back to bytes
        const bytes = Uint8Array.from(atob(cipherText), (c) => c.charCodeAt(0));
        // extract IV from the head
        const iv = bytes.slice(0, exports.IV_BYTES);
        const cipher = bytes.slice(exports.IV_BYTES);
        let lastError;
        for (const key of keys) {
            let decrypted;
            try {
                decrypted = yield crypto.subtle.decrypt({ name: algorithm, iv }, key, cipher);
            }
            catch (err) {
                lastError = err;
                continue;
            }
            return decoder.decode(decrypted);
        }
        throw lastError;
    });
}
//# sourceMappingURL=utils.js.map