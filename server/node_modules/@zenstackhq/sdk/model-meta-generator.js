"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = generate;
const ast_1 = require("@zenstackhq/language/ast");
const local_helpers_1 = require("@zenstackhq/runtime/local-helpers");
const langium_1 = require("langium");
const ts_morph_1 = require("ts-morph");
const ts_pattern_1 = require("ts-pattern");
const _1 = require(".");
function generate(project, models, typeDefs, options) {
    const sf = project.createSourceFile(options.output, undefined, { overwrite: true });
    // generate: import type { ModelMeta } from '@zenstackhq/runtime';
    sf.addImportDeclaration({
        isTypeOnly: true,
        namedImports: ['ModelMeta'],
        moduleSpecifier: '@zenstackhq/runtime',
    });
    const writer = new _1.FastWriter();
    const extraFunctions = [];
    generateModelMetadata(models, typeDefs, writer, options, extraFunctions);
    sf.addVariableStatement({
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        declarations: [{ name: 'metadata', type: 'ModelMeta', initializer: writer.result }],
    });
    if (extraFunctions.length > 0) {
        sf.addFunctions(extraFunctions);
    }
    sf.addStatements('export default metadata;');
    if (options.preserveTsFiles) {
        (0, _1.saveSourceFile)(sf);
    }
    return sf;
}
function generateModelMetadata(dataModels, typeDefs, writer, options, extraFunctions) {
    writer.block(() => {
        writeModels(writer, dataModels, options, extraFunctions);
        writeTypeDefs(writer, typeDefs, options, extraFunctions);
        writeDeleteCascade(writer, dataModels);
        writeShortNameMap(options, writer);
        writeAuthModel(writer, dataModels, typeDefs);
    });
}
function writeModels(writer, dataModels, options, extraFunctions) {
    writer.write('models:');
    writer.block(() => {
        for (const model of dataModels) {
            writer.write(`${(0, local_helpers_1.lowerCaseFirst)(model.name)}:`);
            writer.block(() => {
                writer.write(`name: '${model.name}',`);
                writeBaseTypes(writer, model);
                writeFields(writer, model, options, extraFunctions);
                writeUniqueConstraints(writer, model);
                if (options.generateAttributes) {
                    writeModelAttributes(writer, model);
                }
                writeDiscriminator(writer, model);
            });
            writer.writeLine(',');
        }
    });
    writer.writeLine(',');
}
function writeTypeDefs(writer, typedDefs, options, extraFunctions) {
    if (typedDefs.length === 0) {
        return;
    }
    writer.write('typeDefs:');
    writer.block(() => {
        for (const typeDef of typedDefs) {
            writer.write(`${(0, local_helpers_1.lowerCaseFirst)(typeDef.name)}:`);
            writer.block(() => {
                writer.write(`name: '${typeDef.name}',`);
                writeFields(writer, typeDef, options, extraFunctions);
            });
            writer.writeLine(',');
        }
    });
    writer.writeLine(',');
}
function writeBaseTypes(writer, model) {
    if (model.superTypes.length > 0) {
        writer.write('baseTypes: [');
        writer.write(model.superTypes.map((t) => { var _a; return `'${(_a = t.ref) === null || _a === void 0 ? void 0 : _a.name}'`; }).join(', '));
        writer.write('],');
    }
}
function writeAuthModel(writer, dataModels, typeDefs) {
    const authModel = (0, _1.getAuthDecl)([...dataModels, ...typeDefs]);
    if (authModel) {
        writer.writeLine(`authModel: '${authModel.name}'`);
    }
}
function writeDeleteCascade(writer, dataModels) {
    writer.write('deleteCascade:');
    writer.block(() => {
        for (const model of dataModels) {
            const cascades = getDeleteCascades(model);
            if (cascades.length > 0) {
                writer.writeLine(`${(0, local_helpers_1.lowerCaseFirst)(model.name)}: [${cascades.map((n) => `'${n}'`).join(', ')}],`);
            }
        }
    });
    writer.writeLine(',');
}
function writeUniqueConstraints(writer, model) {
    const constraints = getUniqueConstraints(model);
    if (constraints.length > 0) {
        writer.write('uniqueConstraints:');
        writer.block(() => {
            for (const constraint of constraints) {
                writer.write(`${constraint.name}: {
                                name: "${constraint.name}",
                                fields: ${JSON.stringify(constraint.fields)}
                            },`);
            }
        });
        writer.write(',');
    }
}
function writeModelAttributes(writer, model) {
    const attrs = getAttributes(model);
    if (attrs.length > 0) {
        writer.write(`
attributes: ${JSON.stringify(attrs)},`);
    }
}
function writeDiscriminator(writer, model) {
    const delegateAttr = (0, _1.getAttribute)(model, '@@delegate');
    if (!delegateAttr) {
        return;
    }
    const discriminator = (0, _1.getAttributeArg)(delegateAttr, 'discriminator');
    if (!discriminator) {
        return;
    }
    if (discriminator) {
        writer.write(`discriminator: ${JSON.stringify(discriminator.target.$refText)},`);
    }
}
function writeFields(writer, container, options, extraFunctions) {
    writer.write('fields:');
    writer.block(() => {
        var _a, _b;
        for (const f of container.fields) {
            const dmField = (0, ast_1.isDataModelField)(f) ? f : undefined;
            writer.write(`${f.name}: {`);
            writer.write(`
        name: "${f.name}",
        type: "${f.type.reference
                ? f.type.reference.$refText
                : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    f.type.type}",`);
            if (dmField && (0, _1.isIdField)(dmField)) {
                writer.write(`
        isId: true,`);
            }
            if ((0, ast_1.isDataModel)((_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref)) {
                writer.write(`
        isDataModel: true,`);
            }
            else if ((0, ast_1.isTypeDef)((_b = f.type.reference) === null || _b === void 0 ? void 0 : _b.ref)) {
                writer.write(`
        isTypeDef: true,`);
            }
            if (f.type.array) {
                writer.write(`
        isArray: true,`);
            }
            if (f.type.optional) {
                writer.write(`
        isOptional: true,`);
            }
            if (options.generateAttributes) {
                const attrs = getAttributes(f);
                if (attrs.length > 0) {
                    writer.write(`
        attributes: ${JSON.stringify(attrs)},`);
                }
            }
            else {
                // only include essential attributes
                const attrs = getAttributes(f).filter((attr) => ['@default', '@updatedAt'].includes(attr.name));
                if (attrs.length > 0) {
                    writer.write(`
        attributes: ${JSON.stringify(attrs)},`);
                }
            }
            const defaultValueProvider = generateDefaultValueProvider(f, extraFunctions);
            if (defaultValueProvider) {
                writer.write(`
            defaultValueProvider: ${defaultValueProvider},`);
            }
            if (dmField) {
                // metadata specific to DataModelField
                const backlink = (0, _1.getRelationBackLink)(dmField);
                const fkMapping = generateForeignKeyMapping(dmField);
                if (backlink) {
                    writer.write(`
        backLink: '${backlink.name}',`);
                }
                if (isRelationOwner(dmField, backlink)) {
                    writer.write(`
        isRelationOwner: true,`);
                }
                const onDeleteAction = getOnDeleteAction(dmField);
                if (onDeleteAction) {
                    writer.write(`
        onDeleteAction: '${onDeleteAction}',`);
                }
                const onUpdateAction = getOnUpdateAction(dmField);
                if (onUpdateAction) {
                    writer.write(`
        onUpdateAction: '${onUpdateAction}',`);
                }
                if ((0, _1.isForeignKeyField)(dmField)) {
                    writer.write(`
        isForeignKey: true,`);
                    const relationField = (0, _1.getRelationField)(dmField);
                    if (relationField) {
                        writer.write(`
        relationField: '${relationField.name}',`);
                    }
                }
                if (fkMapping && Object.keys(fkMapping).length > 0) {
                    writer.write(`
        foreignKeyMapping: ${JSON.stringify(fkMapping)},`);
                }
                const inheritedFromDelegate = (0, _1.getInheritedFromDelegate)(dmField);
                if (inheritedFromDelegate && !(0, _1.isIdField)(dmField)) {
                    writer.write(`
        inheritedFrom: ${JSON.stringify(inheritedFromDelegate.name)},`);
                }
                if (isAutoIncrement(dmField)) {
                    writer.write(`
        isAutoIncrement: true,`);
                }
            }
            writer.write(`
    },`);
        }
    });
    writer.write(',');
}
function getAttributes(target) {
    return target.attributes
        .map((attr) => {
        var _a, _b;
        const args = [];
        for (const arg of attr.args) {
            const argName = (_b = (_a = arg.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : arg.name;
            const argValue = exprToValue(arg.value);
            args.push({ name: argName, value: argValue });
        }
        return { name: (0, _1.resolved)(attr.decl).name, args };
    })
        .filter((d) => !!d);
}
function getUniqueConstraints(model) {
    const constraints = [];
    const extractConstraint = (attr) => {
        const argsMap = (0, _1.getAttributeArgs)(attr);
        if (argsMap.fields) {
            const fieldNames = argsMap.fields.items.map((item) => (0, _1.resolved)(item.target).name);
            let constraintName = argsMap.name && (0, _1.getLiteral)(argsMap.name);
            if (!constraintName) {
                // default constraint name is fields concatenated with underscores
                constraintName = fieldNames.join('_');
            }
            return { name: constraintName, fields: fieldNames };
        }
        else {
            return undefined;
        }
    };
    const addConstraint = (constraint) => {
        if (!constraints.some((c) => c.name === constraint.name)) {
            constraints.push(constraint);
        }
    };
    // field-level @id first
    for (const field of model.fields) {
        if ((0, _1.hasAttribute)(field, '@id')) {
            addConstraint({ name: field.name, fields: [field.name] });
        }
    }
    // then model-level @@id
    for (const attr of model.attributes.filter((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@id'; })) {
        const constraint = extractConstraint(attr);
        if (constraint) {
            addConstraint(constraint);
        }
    }
    // then field-level @unique
    for (const field of model.fields) {
        if ((0, _1.hasAttribute)(field, '@unique')) {
            addConstraint({ name: field.name, fields: [field.name] });
        }
    }
    // then model-level @@unique
    for (const attr of model.attributes.filter((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@unique'; })) {
        const constraint = extractConstraint(attr);
        if (constraint) {
            addConstraint(constraint);
        }
    }
    return constraints;
}
function isRelationOwner(field, backLink) {
    var _a;
    if (!(0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref)) {
        return false;
    }
    if (!backLink) {
        // CHECKME: can this really happen?
        return true;
    }
    if (!(0, _1.hasAttribute)(field, '@relation') && !(0, _1.hasAttribute)(backLink, '@relation')) {
        // if neither side has `@relation` attribute, it's an implicit many-to-many relation,
        // both sides are owners
        return true;
    }
    return holdsForeignKey(field);
}
function holdsForeignKey(field) {
    const relation = field.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    if (!relation) {
        return false;
    }
    const fields = (0, _1.getAttributeArg)(relation, 'fields');
    return !!fields;
}
function generateForeignKeyMapping(field) {
    const relation = field.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    if (!relation) {
        return undefined;
    }
    const fields = (0, _1.getAttributeArg)(relation, 'fields');
    const references = (0, _1.getAttributeArg)(relation, 'references');
    if (!(0, ast_1.isArrayExpr)(fields) || !(0, ast_1.isArrayExpr)(references) || fields.items.length !== references.items.length) {
        return undefined;
    }
    const fieldNames = fields.items.map((item) => ((0, ast_1.isReferenceExpr)(item) ? item.target.$refText : undefined));
    const referenceNames = references.items.map((item) => ((0, ast_1.isReferenceExpr)(item) ? item.target.$refText : undefined));
    const result = {};
    referenceNames.forEach((name, i) => {
        if (name) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            result[name] = fieldNames[i];
        }
    });
    return result;
}
function getDeleteCascades(model) {
    const allModels = (0, _1.getDataModels)(model.$container);
    return allModels
        .filter((m) => {
        if (m === model) {
            return false;
        }
        const relationFields = m.fields.filter((f) => {
            var _a, _b;
            if (((_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref) !== model) {
                return false;
            }
            const relationAttr = (0, _1.getAttribute)(f, '@relation');
            if (relationAttr) {
                const onDelete = (0, _1.getAttributeArg)(relationAttr, 'onDelete');
                if (onDelete && (0, _1.isEnumFieldReference)(onDelete) && ((_b = onDelete.target.ref) === null || _b === void 0 ? void 0 : _b.name) === 'Cascade') {
                    return true;
                }
            }
            return false;
        });
        return relationFields.length > 0;
    })
        .map((m) => m.name);
}
function generateDefaultValueProvider(field, extraFunctions) {
    var _a;
    const defaultAttr = (0, _1.getAttribute)(field, '@default');
    if (!defaultAttr) {
        return undefined;
    }
    const expr = (_a = defaultAttr.args[0]) === null || _a === void 0 ? void 0 : _a.value;
    if (!expr) {
        return undefined;
    }
    // find `auth()` in default value expression
    const hasAuth = (0, langium_1.streamAst)(expr).some(_1.isAuthInvocation);
    if (!hasAuth) {
        return undefined;
    }
    // generates a provider function like:
    //     function $default$Model$field(user: any) { ... }
    const funcName = `$default$${field.$container.name}$${field.name}`;
    extraFunctions.push({
        name: funcName,
        parameters: [{ name: 'user', type: 'any' }],
        returnType: 'unknown',
        statements: (writer) => {
            const tsWriter = new _1.TypeScriptExpressionTransformer({ context: _1.ExpressionContext.DefaultValue });
            const code = tsWriter.transform(expr, false);
            writer.write(`return ${code};`);
        },
    });
    return funcName;
}
function isAutoIncrement(field) {
    var _a;
    const defaultAttr = (0, _1.getAttribute)(field, '@default');
    if (!defaultAttr) {
        return false;
    }
    const arg = (_a = defaultAttr.args[0]) === null || _a === void 0 ? void 0 : _a.value;
    if (!arg) {
        return false;
    }
    return (0, ast_1.isInvocationExpr)(arg) && arg.function.$refText === 'autoincrement';
}
function writeShortNameMap(options, writer) {
    if (options.shortNameMap && options.shortNameMap.size > 0) {
        writer.write('shortNameMap:');
        writer.block(() => {
            for (const [key, value] of options.shortNameMap) {
                writer.write(`${key}: '${value}',`);
            }
        });
        writer.write(',');
    }
}
function getOnDeleteAction(fieldInfo) {
    var _a;
    const relationAttr = (0, _1.getAttribute)(fieldInfo, '@relation');
    if (relationAttr) {
        const onDelete = (0, _1.getAttributeArg)(relationAttr, 'onDelete');
        if (onDelete && (0, _1.isEnumFieldReference)(onDelete)) {
            return (_a = onDelete.target.ref) === null || _a === void 0 ? void 0 : _a.name;
        }
    }
    return undefined;
}
function getOnUpdateAction(fieldInfo) {
    var _a;
    const relationAttr = (0, _1.getAttribute)(fieldInfo, '@relation');
    if (relationAttr) {
        const onUpdate = (0, _1.getAttributeArg)(relationAttr, 'onUpdate');
        if (onUpdate && (0, _1.isEnumFieldReference)(onUpdate)) {
            return (_a = onUpdate.target.ref) === null || _a === void 0 ? void 0 : _a.name;
        }
    }
    return undefined;
}
function exprToValue(value) {
    return (0, ts_pattern_1.match)(value)
        .when(ast_1.isStringLiteral, (v) => v.value)
        .when(ast_1.isBooleanLiteral, (v) => v.value)
        .when(ast_1.isNumberLiteral, (v) => {
        let num = parseInt(v.value);
        if (isNaN(num)) {
            num = parseFloat(v.value);
        }
        if (isNaN(num)) {
            return undefined;
        }
        return num;
    })
        .when(ast_1.isArrayExpr, (v) => v.items.map((item) => exprToValue(item)))
        .when(ast_1.isObjectExpr, (v) => exprToObject(v))
        .otherwise(() => undefined);
}
function exprToObject(value) {
    return Object.fromEntries(value.fields.map((field) => [field.name, exprToValue(field.value)]));
}
//# sourceMappingURL=model-meta-generator.js.map