import * as _tanstack_vue_query from '@tanstack/vue-query';
import { UseQueryOptions, UseInfiniteQueryOptions, InfiniteData, UseMutationOptions } from '@tanstack/vue-query';
import * as _vue_shared from '@vue/shared';
import * as vue from 'vue';
import { MaybeRefOrGetter, ComputedRef } from 'vue';
import { ModelMeta } from '@zenstackhq/runtime/cross';
import { A as APIContext, F as FetchFn, a as ExtraQueryOptions, E as ExtraMutationOptions } from './common-CXlL7vTW.js';

declare const VueQueryContextKey = "zenstack-vue-query-context";
/**
 * Provide context for the generated TanStack Query hooks.
 */
declare function provideHooksContext(context: APIContext): void;
/**
 * Hooks context.
 */
declare function getHooksContext(): {
    fetch?: FetchFn;
    logging?: boolean;
    endpoint: string;
};
/**
 * Creates a vue-query query.
 *
 * @param model The name of the model under query.
 * @param url The request URL.
 * @param args The request args object, URL-encoded and appended as "?q=" parameter
 * @param options The vue-query options object
 * @param fetch The fetch function to use for sending the HTTP request
 * @returns useQuery hook
 */
declare function useModelQuery<TQueryFnData, TData, TError>(model: string, url: string, args?: MaybeRefOrGetter<unknown> | ComputedRef<unknown>, options?: MaybeRefOrGetter<Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions> | ComputedRef<Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions>, fetch?: FetchFn): {
    data: _vue_shared.IfAny<TData, vue.Ref<TData>, [TData] extends [vue.Ref<any>] ? TData : vue.Ref<TData>>;
    error: _vue_shared.IfAny<TError, vue.Ref<TError>, [TError] extends [vue.Ref<any>] ? TError : vue.Ref<TError>>;
    isError: vue.Ref<true>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<true>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"error">;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: _vue_shared.IfAny<TData, vue.Ref<TData>, [TData] extends [vue.Ref<any>] ? TData : vue.Ref<TData>>;
    error: vue.Ref<null>;
    isError: vue.Ref<false>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<true>;
    status: vue.Ref<"success">;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: vue.Ref<undefined>;
    error: _vue_shared.IfAny<TError, vue.Ref<TError>, [TError] extends [vue.Ref<any>] ? TError : vue.Ref<TError>>;
    isError: vue.Ref<true>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<true>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"error">;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: vue.Ref<undefined>;
    error: vue.Ref<null>;
    isError: vue.Ref<false>;
    isLoading: vue.Ref<true>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"loading">;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.QueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
};
/**
 * Creates a vue-query infinite query.
 *
 * @param model The name of the model under query.
 * @param url The request URL.
 * @param args The initial request args object, URL-encoded and appended as "?q=" parameter
 * @param options The vue-query infinite query options object
 * @param fetch The fetch function to use for sending the HTTP request
 * @returns useInfiniteQuery hook
 */
declare function useInfiniteModelQuery<TQueryFnData, TData, TError>(model: string, url: string, args?: MaybeRefOrGetter<unknown> | ComputedRef<unknown>, options?: MaybeRefOrGetter<Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>> | ComputedRef<Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>>, fetch?: FetchFn): {
    data: vue.Ref<undefined>;
    error: _vue_shared.IfAny<TError, vue.Ref<TError>, [TError] extends [vue.Ref<any>] ? TError : vue.Ref<TError>>;
    isError: vue.Ref<true>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<true>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"error">;
    fetchNextPage: (options?: _tanstack_vue_query.FetchNextPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    fetchPreviousPage: (options?: _tanstack_vue_query.FetchPreviousPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    hasNextPage?: vue.Ref<boolean | undefined> | undefined;
    hasPreviousPage?: vue.Ref<boolean | undefined> | undefined;
    isFetchingNextPage: vue.Ref<boolean>;
    isFetchingPreviousPage: vue.Ref<boolean>;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<InfiniteData<TData>, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: vue.Ref<undefined>;
    error: vue.Ref<null>;
    isError: vue.Ref<false>;
    isLoading: vue.Ref<true>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"loading">;
    fetchNextPage: (options?: _tanstack_vue_query.FetchNextPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    fetchPreviousPage: (options?: _tanstack_vue_query.FetchPreviousPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    hasNextPage?: vue.Ref<boolean | undefined> | undefined;
    hasPreviousPage?: vue.Ref<boolean | undefined> | undefined;
    isFetchingNextPage: vue.Ref<boolean>;
    isFetchingPreviousPage: vue.Ref<boolean>;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<InfiniteData<TData>, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: vue.Ref<InfiniteData<TData>>;
    error: _vue_shared.IfAny<TError, vue.Ref<TError>, [TError] extends [vue.Ref<any>] ? TError : vue.Ref<TError>>;
    isError: vue.Ref<true>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<true>;
    isSuccess: vue.Ref<false>;
    status: vue.Ref<"error">;
    fetchNextPage: (options?: _tanstack_vue_query.FetchNextPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    fetchPreviousPage: (options?: _tanstack_vue_query.FetchPreviousPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    hasNextPage?: vue.Ref<boolean | undefined> | undefined;
    hasPreviousPage?: vue.Ref<boolean | undefined> | undefined;
    isFetchingNextPage: vue.Ref<boolean>;
    isFetchingPreviousPage: vue.Ref<boolean>;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<InfiniteData<TData>, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
} | {
    data: vue.Ref<InfiniteData<TData>>;
    error: vue.Ref<null>;
    isError: vue.Ref<false>;
    isLoading: vue.Ref<false>;
    isLoadingError: vue.Ref<false>;
    isRefetchError: vue.Ref<false>;
    isSuccess: vue.Ref<true>;
    status: vue.Ref<"success">;
    fetchNextPage: (options?: _tanstack_vue_query.FetchNextPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    fetchPreviousPage: (options?: _tanstack_vue_query.FetchPreviousPageOptions) => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    hasNextPage?: vue.Ref<boolean | undefined> | undefined;
    hasPreviousPage?: vue.Ref<boolean | undefined> | undefined;
    isFetchingNextPage: vue.Ref<boolean>;
    isFetchingPreviousPage: vue.Ref<boolean>;
    dataUpdatedAt: vue.Ref<number>;
    errorUpdatedAt: vue.Ref<number>;
    failureCount: vue.Ref<number>;
    failureReason: _vue_shared.IfAny<TError | null, vue.Ref<TError | null>, [TError | null] extends [vue.Ref<any>] ? vue.Ref<any> & TError : vue.Ref<TError | null>>;
    errorUpdateCount: vue.Ref<number>;
    isFetched: vue.Ref<boolean>;
    isFetchedAfterMount: vue.Ref<boolean>;
    isFetching: vue.Ref<boolean>;
    isInitialLoading: vue.Ref<boolean>;
    isPaused: vue.Ref<boolean>;
    isPlaceholderData: vue.Ref<boolean>;
    isPreviousData: vue.Ref<boolean>;
    isRefetching: vue.Ref<boolean>;
    isStale: vue.Ref<boolean>;
    refetch: <TPageData>(options?: (_tanstack_vue_query.RefetchOptions & _tanstack_vue_query.RefetchQueryFilters<TPageData>) | undefined) => Promise<_tanstack_vue_query.QueryObserverResult<InfiniteData<TData>, TError>>;
    remove: () => void;
    fetchStatus: vue.Ref<_tanstack_vue_query.FetchStatus>;
    suspense: () => Promise<_tanstack_vue_query.InfiniteQueryObserverResult<TData, TError>>;
    queryKey: [string, string, string, unknown, {
        infinite: boolean;
        optimisticUpdate: boolean;
    }];
};
/**
 * Creates a mutation with vue-query.
 *
 * @param model The name of the model under mutation.
 * @param method The HTTP method.
 * @param modelMeta The model metadata.
 * @param url The request URL.
 * @param options The vue-query options.
 * @param fetch The fetch function to use for sending the HTTP request
 * @param checkReadBack Whether to check for read back errors and return undefined if found.
 * @returns useMutation hooks
 */
declare function useModelMutation<TArgs, TError, R = any, C extends boolean = boolean, Result = C extends true ? R | undefined : R>(model: string, method: 'POST' | 'PUT' | 'DELETE', url: string, modelMeta: ModelMeta, options?: MaybeRefOrGetter<Omit<UseMutationOptions<Result, TError, TArgs, unknown>, 'mutationFn'> & ExtraMutationOptions> | ComputedRef<Omit<UseMutationOptions<Result, TError, TArgs, unknown>, 'mutationFn'> & ExtraMutationOptions>, fetch?: FetchFn, checkReadBack?: C): _tanstack_vue_query.UseMutationReturnType<Result, TError, TArgs, unknown, Omit<_tanstack_vue_query.MutationObserverIdleResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverLoadingResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverErrorResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverSuccessResult<Result, TError, TArgs, unknown>, "mutate" | "reset">>;

export { APIContext as RequestHandlerContext, VueQueryContextKey, getHooksContext, provideHooksContext, useInfiniteModelQuery, useModelMutation, useModelQuery };
